# fielddecode.py was generated by ProtoGen version 3.1.d

from fielddecode import *
from struct import *
from floatspecial import *

# supporting 64 bit sizes

def uint64FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 8 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 8
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('>Q', byteA, offset=index[0])
    index[0] = index[0] + 8

    return number[0]

def uint64FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 8 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 8
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('<Q', byteA, offset=index[0])
    index[0] = index[0] + 8

    return number[0]

def int64FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 8 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 8
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('>q', byteA, offset=index[0])
    index[0] = index[0] + 8

    return number[0]

def int64FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 8 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 8
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('<q', byteA, offset=index[0])
    index[0] = index[0] + 8

    return number[0]

def uint56FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 7 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 7
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('>7B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # transfer the unpacked bytes into the fullsized type
    full_bytes[0] = 0
    full_bytes[1] = n_byte[0]
    full_bytes[2] = n_byte[1]
    full_bytes[3] = n_byte[2]
    full_bytes[4] = n_byte[3]
    full_bytes[5] = n_byte[4]
    full_bytes[6] = n_byte[5]
    full_bytes[7] = n_byte[6]

    # unpack the full sized value
    number = unpack_from('>Q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 7
    return number[0]

def uint56FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 7 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 7
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('<7B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # transfer the unpacked bytes into the fullsized type
    full_bytes[7] = 0
    full_bytes[6] = n_byte[6]
    full_bytes[5] = n_byte[5]
    full_bytes[4] = n_byte[4]
    full_bytes[3] = n_byte[3]
    full_bytes[2] = n_byte[2]
    full_bytes[1] = n_byte[1]
    full_bytes[0] = n_byte[0]

    # unpack the full sized value
    number = unpack_from('<Q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 7
    return number[0]

def int56FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 7 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 7
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('>7B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # determine byte extesion value
    pad = 0
    if (n_byte[0] >> 7) == 1:
        pad = 255

    # transfer the unpacked bytes into the fullsized type
    full_bytes[0] = pad
    full_bytes[1] = n_byte[0]
    full_bytes[2] = n_byte[1]
    full_bytes[3] = n_byte[2]
    full_bytes[4] = n_byte[3]
    full_bytes[5] = n_byte[4]
    full_bytes[6] = n_byte[5]
    full_bytes[7] = n_byte[6]

    # unpack the full sized value
    number = unpack_from('>q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 7
    return number[0]

def int56FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 7 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 7
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('<7B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # determine byte extesion value
    pad = 0
    if (n_byte[0] >> 7) == 1:
        pad = 255

    # transfer the unpacked bytes into the fullsized type
    full_bytes[7] = pad
    full_bytes[6] = n_byte[6]
    full_bytes[5] = n_byte[5]
    full_bytes[4] = n_byte[4]
    full_bytes[3] = n_byte[3]
    full_bytes[2] = n_byte[2]
    full_bytes[1] = n_byte[1]
    full_bytes[0] = n_byte[0]

    # unpack the full sized value
    number = unpack_from('<q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 7
    return number[0]

def uint48FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 6 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 6
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('>6B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # transfer the unpacked bytes into the fullsized type
    full_bytes[0] = 0
    full_bytes[1] = 0
    full_bytes[2] = n_byte[0]
    full_bytes[3] = n_byte[1]
    full_bytes[4] = n_byte[2]
    full_bytes[5] = n_byte[3]
    full_bytes[6] = n_byte[4]
    full_bytes[7] = n_byte[5]

    # unpack the full sized value
    number = unpack_from('>Q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 6
    return number[0]

def uint48FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 6 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 6
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('<6B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # transfer the unpacked bytes into the fullsized type
    full_bytes[7] = 0
    full_bytes[6] = 0
    full_bytes[5] = n_byte[5]
    full_bytes[4] = n_byte[4]
    full_bytes[3] = n_byte[3]
    full_bytes[2] = n_byte[2]
    full_bytes[1] = n_byte[1]
    full_bytes[0] = n_byte[0]

    # unpack the full sized value
    number = unpack_from('<Q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 6
    return number[0]

def int48FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 6 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 6
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('>6B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # determine byte extesion value
    pad = 0
    if (n_byte[0] >> 7) == 1:
        pad = 255

    # transfer the unpacked bytes into the fullsized type
    full_bytes[0] = pad
    full_bytes[1] = pad
    full_bytes[2] = n_byte[0]
    full_bytes[3] = n_byte[1]
    full_bytes[4] = n_byte[2]
    full_bytes[5] = n_byte[3]
    full_bytes[6] = n_byte[4]
    full_bytes[7] = n_byte[5]

    # unpack the full sized value
    number = unpack_from('>q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 6
    return number[0]

def int48FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 6 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 6
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('<6B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # determine byte extesion value
    pad = 0
    if (n_byte[0] >> 7) == 1:
        pad = 255

    # transfer the unpacked bytes into the fullsized type
    full_bytes[7] = pad
    full_bytes[6] = pad
    full_bytes[5] = n_byte[5]
    full_bytes[4] = n_byte[4]
    full_bytes[3] = n_byte[3]
    full_bytes[2] = n_byte[2]
    full_bytes[1] = n_byte[1]
    full_bytes[0] = n_byte[0]

    # unpack the full sized value
    number = unpack_from('<q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 6
    return number[0]

def uint40FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 5 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 5
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('>5B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # transfer the unpacked bytes into the fullsized type
    full_bytes[0] = 0
    full_bytes[1] = 0
    full_bytes[2] = 0
    full_bytes[3] = n_byte[0]
    full_bytes[4] = n_byte[1]
    full_bytes[5] = n_byte[2]
    full_bytes[6] = n_byte[3]
    full_bytes[7] = n_byte[4]

    # unpack the full sized value
    number = unpack_from('>Q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 5
    return number[0]

def uint40FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 5 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 5
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('<5B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # transfer the unpacked bytes into the fullsized type
    full_bytes[7] = 0
    full_bytes[6] = 0
    full_bytes[5] = 0
    full_bytes[4] = n_byte[4]
    full_bytes[3] = n_byte[3]
    full_bytes[2] = n_byte[2]
    full_bytes[1] = n_byte[1]
    full_bytes[0] = n_byte[0]

    # unpack the full sized value
    number = unpack_from('<Q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 5
    return number[0]

def int40FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 5 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 5
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('>5B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # determine byte extesion value
    pad = 0
    if (n_byte[0] >> 7) == 1:
        pad = 255

    # transfer the unpacked bytes into the fullsized type
    full_bytes[0] = pad
    full_bytes[1] = pad
    full_bytes[2] = pad
    full_bytes[3] = n_byte[0]
    full_bytes[4] = n_byte[1]
    full_bytes[5] = n_byte[2]
    full_bytes[6] = n_byte[3]
    full_bytes[7] = n_byte[4]

    # unpack the full sized value
    number = unpack_from('>q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 5
    return number[0]

def int40FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 5 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 5
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('<5B', byteA, offset=index[0])
    full_bytes = bytearray(8)

    # determine byte extesion value
    pad = 0
    if (n_byte[0] >> 7) == 1:
        pad = 255

    # transfer the unpacked bytes into the fullsized type
    full_bytes[7] = pad
    full_bytes[6] = pad
    full_bytes[5] = pad
    full_bytes[4] = n_byte[4]
    full_bytes[3] = n_byte[3]
    full_bytes[2] = n_byte[2]
    full_bytes[1] = n_byte[1]
    full_bytes[0] = n_byte[0]

    # unpack the full sized value
    number = unpack_from('<q', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 5
    return number[0]

# end supporting 64 bit sizes

def float32FromBeBytes(byteA: bytearray, index: int) -> float:
    """Decode a 4 byte float from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 4
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('>f', byteA, offset=index[0])
    index[0] = index[0] + 4

    # Verify that the unpacked float is valid
    if isFloat32Valid(float32ToInt(number[0])) is True:
        return number[0]
    else:
        return 0

def float32FromLeBytes(byteA: bytearray, index: int) -> float:
    """Decode a 4 byte float from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 4
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('<f', byteA, offset=index[0])
    index[0] = index[0] + 4

    # Verify that the unpacked float is valid
    if isFloat32Valid(float32ToInt(number[0])) is True:
        return number[0]
    else:
        return 0

def uint32FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 4 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 4
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('>I', byteA, offset=index[0])
    index[0] = index[0] + 4

    return number[0]

def uint32FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 4 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 4
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('<I', byteA, offset=index[0])
    index[0] = index[0] + 4

    return number[0]

def int32FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 4 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 4
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('>i', byteA, offset=index[0])
    index[0] = index[0] + 4

    return number[0]

def int32FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 4 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 4
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('<i', byteA, offset=index[0])
    index[0] = index[0] + 4

    return number[0]

def uint24FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 3 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 3
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('>3B', byteA, offset=index[0])
    full_bytes = bytearray(4)

    # transfer the unpacked bytes into the fullsized type
    full_bytes[0] = 0
    full_bytes[1] = n_byte[0]
    full_bytes[2] = n_byte[1]
    full_bytes[3] = n_byte[2]

    # unpack the full sized value
    number = unpack_from('>I', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 3
    return number[0]

def uint24FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 3 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 3
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('<3B', byteA, offset=index[0])
    full_bytes = bytearray(4)

    # transfer the unpacked bytes into the fullsized type
    full_bytes[3] = 0
    full_bytes[2] = n_byte[2]
    full_bytes[1] = n_byte[1]
    full_bytes[0] = n_byte[0]

    # unpack the full sized value
    number = unpack_from('<I', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 3
    return number[0]

def int24FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 3 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 3
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('>3B', byteA, offset=index[0])
    full_bytes = bytearray(4)

    # determine byte extesion value
    pad = 0
    if (n_byte[0] >> 7) == 1:
        pad = 255

    # transfer the unpacked bytes into the fullsized type
    full_bytes[0] = pad
    full_bytes[1] = n_byte[0]
    full_bytes[2] = n_byte[1]
    full_bytes[3] = n_byte[2]

    # unpack the full sized value
    number = unpack_from('>i', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 3
    return number[0]

def int24FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 3 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 3
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    n_byte     = unpack_from('<3B', byteA, offset=index[0])
    full_bytes = bytearray(4)

    # determine byte extesion value
    pad = 0
    if (n_byte[0] >> 7) == 1:
        pad = 255

    # transfer the unpacked bytes into the fullsized type
    full_bytes[3] = pad
    full_bytes[2] = n_byte[2]
    full_bytes[1] = n_byte[1]
    full_bytes[0] = n_byte[0]

    # unpack the full sized value
    number = unpack_from('<i', full_bytes, 0)

    # update the index and return the first element of the tuple
    index[0] = index[0] + 3
    return number[0]

def uint16FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 2 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 2
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('>H', byteA, offset=index[0])
    index[0] = index[0] + 2

    return number[0]

def uint16FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a unsigned 2 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 2
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('<H', byteA, offset=index[0])
    index[0] = index[0] + 2

    return number[0]

def int16FromBeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 2 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 2
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('>h', byteA, offset=index[0])
    index[0] = index[0] + 2

    return number[0]

def int16FromLeBytes(byteA: bytearray, index: int) -> int:
    """Decode a signed 2 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 2
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('<h', byteA, offset=index[0])
    index[0] = index[0] + 2

    return number[0]

def float64FromBeBytes(byteA: bytearray, index: int) -> float:
    """Decode a 8 byte float from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 8
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('>d', byteA, offset=index[0])
    index[0] = index[0] + 8

    # Verify that the unpacked float is valid
    if isFloat64Valid(float64ToInt(number[0])) is True:
        return number[0]
    else:
        return 0

def float64FromLeBytes(byteA: bytearray, index: int) -> float:
    """Decode a 8 byte float from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 8
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference


    Returns:
        number (int): return the number decoded from the byte stream
    """
    number = unpack_from('<d', byteA, offset=index[0])
    index[0] = index[0] + 8

    # Verify that the unpacked float is valid
    if isFloat64Valid(float64ToInt(number[0])) is True:
        return number[0]
    else:
        return 0

def float24FromBeBytes(byteA: bytearray, index: int, sigbits: int) -> float:
    """Decode a signed 3 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 3
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference
        sigbits (int): the number of bits to use in the significand of the float.

    Returns:
        number (int): return the number decoded from the byte stream
    """
    return float24ToFloat32(uint24FromBeBytes(byteA, index), sigbits)

def float24FromLeBytes(byteA: bytearray, index: int, sigbits: int) -> float:
    """Decode a signed 3 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 3
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference
        sigbits (int): the number of bits to use in the significand of the float.

    Returns:
        number (int): return the number decoded from the byte stream
    """
    return float24ToFloat32(uint24FromLeBytes(byteA, index), sigbits)

def float16FromBeBytes(byteA: bytearray, index: int, sigbits: int) -> float:
    """Decode a signed 2 byte integer from a big endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 2
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference
        sigbits (int): the number of bits to use in the significand of the float.

    Returns:
        number (int): return the number decoded from the byte stream
    """
    return float16ToFloat32(uint16FromBeBytes(byteA, index), sigbits)

def float16FromLeBytes(byteA: bytearray, index: int, sigbits: int) -> float:
    """Decode a signed 2 byte integer from a little endian byte stream.

    Args:
        byteA  (byteArray): The byte stream which contains the encodes data
        index  (list): a list where index 0 is the location of the first
            byte in the byte stream and will be incremented by 2
            * this gurantees that the index will be updates
              since you cannot pass an integer by reference
        sigbits (int): the number of bits to use in the significand of the float.

    Returns:
        number (int): return the number decoded from the byte stream
    """
    return float16ToFloat32(uint16FromLeBytes(byteA, index), sigbits)

# end of fielddecode.py
