# eficomms.py was generated by ProtoGen version 3.1.d

from eficomms import *
from floatspecial import *
from fielddecode import *
from fieldencode import *
from scaleddecode import *
from scaledencode import *
from efitable import *

/*!
 * \brief Encode a efiDate_t into a byte array
 *
 * Calendar date information
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiDate_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // The day of the month from 1 to 31
    // Range of day is 0 to 31.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(day, 31) << 3;

    // The month of the year from 1 (January) to 12 (December)
    // Range of month is 0 to 15.
    _pg_tempbitfield = (unsigned int)limitMax(month, 15);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 7);

    _pg_tempbitfield >>= 1;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;

    // The year (AD) of the date
    // Range of year is 2000 to 2127.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)uint16ScaledToBitfield(year, 2000, 1, 7);
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// efiDate_t::encode

/*!
 * \brief Decode a efiDate_t from a byte array
 *
 * Calendar date information
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiDate_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // The day of the month from 1 to 31
    // Range of day is 0 to 31.
    day = (_pg_data[_pg_byteindex] >> 3);

    // The month of the year from 1 (January) to 12 (December)
    // Range of month is 0 to 15.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x7);

    _pg_tempbitfield <<= 1;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 7);

    month = _pg_tempbitfield;

    // The year (AD) of the date
    // Range of year is 2000 to 2127.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex + 1]) & 0x7F);
    year = (2000 + _pg_tempbitfield);
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiDate_t::decode

/*!
 * \brief Encode a efiDateTime_t into a byte array
 *
 * Date and time information
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiDateTime_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // 10s of milliseconds of the day from 0 to 8640000
    // Range of jiffytime is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(jiffytime, 16777215)), _pg_data, &_pg_byteindex);

    // The day of the month from 1 to 31
    // Range of day is 0 to 31.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(day, 31) << 3;

    // The month of the year from 1 (January) to 12 (December)
    // Range of month is 0 to 15.
    _pg_tempbitfield = (unsigned int)limitMax(month, 15);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 7);

    _pg_tempbitfield >>= 1;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;

    // The year (AD) of the date
    // Range of year is 2000 to 2127.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)uint16ScaledToBitfield(year, 2000, 1, 7);
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// efiDateTime_t::encode

/*!
 * \brief Decode a efiDateTime_t from a byte array
 *
 * Date and time information
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiDateTime_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // 10s of milliseconds of the day from 0 to 8640000
    // Range of jiffytime is 0 to 16777215.
    jiffytime = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // The day of the month from 1 to 31
    // Range of day is 0 to 31.
    day = (_pg_data[_pg_byteindex] >> 3);

    // The month of the year from 1 (January) to 12 (December)
    // Range of month is 0 to 15.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x7);

    _pg_tempbitfield <<= 1;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 7);

    month = _pg_tempbitfield;

    // The year (AD) of the date
    // Range of year is 2000 to 2127.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex + 1]) & 0x7F);
    year = (2000 + _pg_tempbitfield);
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiDateTime_t::decode

/*!
 * \brief Encode a efiConfigBits_t into a byte array
 *
 * One bit for every configuration packet that can be sent, requested, or
 * stored.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiConfigBits_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // One bit for each of the sensors. The least significant bit is the first sensor.
    // Range of sensors is 0 to 65535.
    _pg_tempbitfield = (unsigned int)sensors;
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // Remaining bits for future expansion
    // Range of reservedbits is 0 to 7.
    _pg_data[_pg_byteindex + 2] = (uint8_t)reservedbits << 5;

    // The cooling configuration
    _pg_data[_pg_byteindex + 2] |= (uint8_t)cooling << 4;

    // The new engine configuration
    _pg_data[_pg_byteindex + 2] |= (uint8_t)newengine << 3;

    // The SD Card journal data
    _pg_data[_pg_byteindex + 2] |= (uint8_t)sdjournal << 2;

    // The engine wear data
    _pg_data[_pg_byteindex + 2] |= (uint8_t)wear << 1;

    // The logbook data
    _pg_data[_pg_byteindex + 2] |= (uint8_t)logbook;

    // The maintenance status data
    _pg_data[_pg_byteindex + 3] = (uint8_t)maintenancestatus << 7;

    // The maintenance configuration data
    _pg_data[_pg_byteindex + 3] |= (uint8_t)maintenanceconfig << 6;

    // The oscilloscope setup data
    _pg_data[_pg_byteindex + 3] |= (uint8_t)scopesetup << 5;

    // The configuration hash data
    _pg_data[_pg_byteindex + 3] |= (uint8_t)confighash << 4;

    // The fuel pump configuration
    _pg_data[_pg_byteindex + 3] |= (uint8_t)pump << 3;

    // The communications configuration
    _pg_data[_pg_byteindex + 3] |= (uint8_t)comms << 2;

    // The throttle configuration
    _pg_data[_pg_byteindex + 3] |= (uint8_t)throttle << 1;

    // A reserved bit for future expansion
    _pg_data[_pg_byteindex + 3] |= (uint8_t)reservedbit;

    // The injector configuration
    _pg_data[_pg_byteindex + 4] = (uint8_t)injector << 7;

    // The rpm controller configuration
    _pg_data[_pg_byteindex + 4] |= (uint8_t)rpmcontroller << 6;

    // The lock control information
    _pg_data[_pg_byteindex + 4] |= (uint8_t)lockcontrol << 5;

    // The software information data
    _pg_data[_pg_byteindex + 4] |= (uint8_t)softwareinfo << 4;

    // The reset report data
    _pg_data[_pg_byteindex + 4] |= (uint8_t)resetinfo << 3;

    // The file data
    _pg_data[_pg_byteindex + 4] |= (uint8_t)file << 2;

    // The comment data
    _pg_data[_pg_byteindex + 4] |= (uint8_t)comment << 1;

    // The hardware information data
    _pg_data[_pg_byteindex + 4] |= (uint8_t)hardwareinfo;

    // One bit for each of the tables. The least significant bit is the first table.
    // Range of tables is 0 to 16777215.
    _pg_tempbitfield = (unsigned int)tables;
    _pg_data[_pg_byteindex + 7] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 6] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 5] = (uint8_t)_pg_tempbitfield;

    // More bits for future expansion
    // Range of reservedbits2 is 0 to 524287.
    _pg_tempbitfield = (unsigned int)reservedbits2;
    _pg_data[_pg_byteindex + 10] = (uint8_t)(_pg_tempbitfield << 5);

    _pg_tempbitfield >>= 3;
    _pg_data[_pg_byteindex + 9] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 8] = (uint8_t)_pg_tempbitfield;

    // One bit for each of the tables above table 23. The least significant bit is table 24.
    // Range of tables2 is 0 to 8191.
    _pg_tempbitfield = (unsigned int)tables2;
    _pg_data[_pg_byteindex + 11] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 10] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 12; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// efiConfigBits_t::encode

/*!
 * \brief Decode a efiConfigBits_t from a byte array
 *
 * One bit for every configuration packet that can be sent, requested, or
 * stored.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiConfigBits_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // One bit for each of the sensors. The least significant bit is the first sensor.
    // Range of sensors is 0 to 65535.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    sensors = _pg_tempbitfield;

    // Remaining bits for future expansion
    // Range of reservedbits is 0 to 7.
    reservedbits = (_pg_data[_pg_byteindex + 2] >> 5);

    // The cooling configuration
    cooling = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x1);

    // The new engine configuration
    newengine = ((_pg_data[_pg_byteindex + 2] >> 3) & 0x1);

    // The SD Card journal data
    sdjournal = ((_pg_data[_pg_byteindex + 2] >> 2) & 0x1);

    // The engine wear data
    wear = ((_pg_data[_pg_byteindex + 2] >> 1) & 0x1);

    // The logbook data
    logbook = ((_pg_data[_pg_byteindex + 2]) & 0x1);

    // The maintenance status data
    maintenancestatus = (_pg_data[_pg_byteindex + 3] >> 7);

    // The maintenance configuration data
    maintenanceconfig = ((_pg_data[_pg_byteindex + 3] >> 6) & 0x1);

    // The oscilloscope setup data
    scopesetup = ((_pg_data[_pg_byteindex + 3] >> 5) & 0x1);

    // The configuration hash data
    confighash = ((_pg_data[_pg_byteindex + 3] >> 4) & 0x1);

    // The fuel pump configuration
    pump = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // The communications configuration
    comms = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);

    // The throttle configuration
    throttle = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // A reserved bit for future expansion
    reservedbit = ((_pg_data[_pg_byteindex + 3]) & 0x1);

    // The injector configuration
    injector = (_pg_data[_pg_byteindex + 4] >> 7);

    // The rpm controller configuration
    rpmcontroller = ((_pg_data[_pg_byteindex + 4] >> 6) & 0x1);

    // The lock control information
    lockcontrol = ((_pg_data[_pg_byteindex + 4] >> 5) & 0x1);

    // The software information data
    softwareinfo = ((_pg_data[_pg_byteindex + 4] >> 4) & 0x1);

    // The reset report data
    resetinfo = ((_pg_data[_pg_byteindex + 4] >> 3) & 0x1);

    // The file data
    file = ((_pg_data[_pg_byteindex + 4] >> 2) & 0x1);

    // The comment data
    comment = ((_pg_data[_pg_byteindex + 4] >> 1) & 0x1);

    // The hardware information data
    hardwareinfo = ((_pg_data[_pg_byteindex + 4]) & 0x1);

    // One bit for each of the tables. The least significant bit is the first table.
    // Range of tables is 0 to 16777215.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 5] & 0xFF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 6];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 7];

    tables = _pg_tempbitfield;

    // More bits for future expansion
    // Range of reservedbits2 is 0 to 524287.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 8] & 0xFF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 9];

    _pg_tempbitfield <<= 3;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 10] >> 5);

    reservedbits2 = _pg_tempbitfield;

    // One bit for each of the tables above table 23. The least significant bit is table 24.
    // Range of tables2 is 0 to 8191.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 10] & 0x1F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 11];

    tables2 = _pg_tempbitfield;
    _pg_byteindex += 12; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiConfigBits_t::decode

/*!
 * \brief Encode a efiCrankSense_t into a byte array
 *
 * Details of a crank sense for either once-per-rev or crank wheel sensors.
 * Crank wheels provide higher resolution crank angle sensing than a typical
 * once-per-rev hall sensor arrangement. In order to use the crank wheel you
 * must specify the tooth count of the crank wheel, and the size of the
 * sychronization gap. It is possible to have a directional crank wheel which
 * uses two gaps of different size (a big gap and a small gap). Directional
 * crank wheel sensors make it possible to prevent the engine from running in
 * the wrong direction, or to enable it to run in either direction. Engine
 * rotation is defined from the persective of looking at the output end of the
 * engine (the end with the flywheel, propeller, transmission, etc.). From this
 * perspective the rotation is normal if the rotation direction is clockwise
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiCrankSense_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Set to enable crank wheel sensing. The `totalCount` and `bigGapCount` must be set correctly. If they are not then enable will be cleared.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(enableWheel, 1) << 7;

    // Set if the crank sense occurs on the rising edge, else crank sense is on the falling edge
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(activeHigh, 1) << 6;

    // Set to disable this sensor.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(disableSensor, 1) << 5;

    // Set to prefer this sensor over the other one.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(preferThisSensor, 1) << 4;

    // Time delay from crank sensor signal to detection of the crank sense signal, in microseconds. This time is subtracted from the clock time of the crank sense.
    // Range of senseDelay is 0 to 4095.
    _pg_tempbitfield = (unsigned int)limitMax(senseDelay, 4095);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // Angle of the active sense event in degrees of crank rotation after TDC. For directional crank wheel sensors this is the offset for clockwise (normal) rotation.
    // Range of normalOffset is 0.0 to 360.0.
    float32ScaledTo2UnsignedBeBytes(normalOffset, _pg_data, &_pg_byteindex, 0.0f, 182.041667f);

    // Angle of the active sense event in degrees of crank rotation after TDC, for directional crank wheels in the reversed rotation direction.
    // Range of reverseOffset is 0.0 to 360.0.
    float32ScaledTo2UnsignedBeBytes(reverseOffset, _pg_data, &_pg_byteindex, 0.0f, 182.041667f);

    // The number of teeth on the crank wheel plus the missing teeth. This is the full count, as though no synchronization teeth were removed.
    // Range of totalCount is 0 to 255.
    uint8ToBytes(totalCount, _pg_data, &_pg_byteindex);

    // The number of teeth missing in the big gap of the crank wheel. The end of the big gap is the crank angle synchronization point. There must always be a non-zero big gap count.
    // Range of bigGapCount is 0 to 255.
    uint8ToBytes(bigGapCount, _pg_data, &_pg_byteindex);

    // The number of teeth missing in the small gap of the crank wheel. The small gap count can be zero, in which case there is no small gap; and therefore no ability to detect direction of rotation. The small gap count must be less than the big gap count for a functioning crank wheel.
    // Range of smallGapCount is 0 to 255.
    uint8ToBytes(smallGapCount, _pg_data, &_pg_byteindex);

    // The number of teeth between the big gap and the small gap for normal rotation. Zero if there is no small gap.
    // Range of normalIntraGapCount is 0 to 255.
    uint8ToBytes(normalIntraGapCount, _pg_data, &_pg_byteindex);

    // The number of teeth between the big gap and the small gap for reverse rotation. Zero if there is no small gap. The intra gap count for reversed rotation should be the same as `totalCount` - `bigGapCount` - `smallGapCount` - `normalIntraGapCount`
    // Range of reverseIntraGapCount is 0 to 255.
    uint8ToBytes(reverseIntraGapCount, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efiCrankSense_t::encode

/*!
 * \brief Decode a efiCrankSense_t from a byte array
 *
 * Details of a crank sense for either once-per-rev or crank wheel sensors.
 * Crank wheels provide higher resolution crank angle sensing than a typical
 * once-per-rev hall sensor arrangement. In order to use the crank wheel you
 * must specify the tooth count of the crank wheel, and the size of the
 * sychronization gap. It is possible to have a directional crank wheel which
 * uses two gaps of different size (a big gap and a small gap). Directional
 * crank wheel sensors make it possible to prevent the engine from running in
 * the wrong direction, or to enable it to run in either direction. Engine
 * rotation is defined from the persective of looking at the output end of the
 * engine (the end with the flywheel, propeller, transmission, etc.). From this
 * perspective the rotation is normal if the rotation direction is clockwise
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiCrankSense_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Set to enable crank wheel sensing. The `totalCount` and `bigGapCount` must be set correctly. If they are not then enable will be cleared.
    enableWheel = (_pg_data[_pg_byteindex] >> 7);

    // Set if the crank sense occurs on the rising edge, else crank sense is on the falling edge
    activeHigh = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set to disable this sensor.
    disableSensor = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set to prefer this sensor over the other one.
    preferThisSensor = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Time delay from crank sensor signal to detection of the crank sense signal, in microseconds. This time is subtracted from the clock time of the crank sense.
    // Range of senseDelay is 0 to 4095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    senseDelay = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // Angle of the active sense event in degrees of crank rotation after TDC. For directional crank wheel sensors this is the offset for clockwise (normal) rotation.
    // Range of normalOffset is 0.0 to 360.0.
    normalOffset = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/182.041667f);

    // Angle of the active sense event in degrees of crank rotation after TDC, for directional crank wheels in the reversed rotation direction.
    // Range of reverseOffset is 0.0 to 360.0.
    reverseOffset = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/182.041667f);

    // The number of teeth on the crank wheel plus the missing teeth. This is the full count, as though no synchronization teeth were removed.
    // Range of totalCount is 0 to 255.
    totalCount = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The number of teeth missing in the big gap of the crank wheel. The end of the big gap is the crank angle synchronization point. There must always be a non-zero big gap count.
    // Range of bigGapCount is 0 to 255.
    bigGapCount = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The number of teeth missing in the small gap of the crank wheel. The small gap count can be zero, in which case there is no small gap; and therefore no ability to detect direction of rotation. The small gap count must be less than the big gap count for a functioning crank wheel.
    // Range of smallGapCount is 0 to 255.
    smallGapCount = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The number of teeth between the big gap and the small gap for normal rotation. Zero if there is no small gap.
    // Range of normalIntraGapCount is 0 to 255.
    normalIntraGapCount = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The number of teeth between the big gap and the small gap for reverse rotation. Zero if there is no small gap. The intra gap count for reversed rotation should be the same as `totalCount` - `bigGapCount` - `smallGapCount` - `normalIntraGapCount`
    // Range of reverseIntraGapCount is 0 to 255.
    reverseIntraGapCount = uint8FromBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiCrankSense_t::decode

/*!
 * \brief Encode a efiTable1D_t into a byte array
 *
 * One dimensional table
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTable1D_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned _pg_i = 0;

    // Table enable. If clear then this table is not used
    _pg_data[_pg_byteindex] = (uint8_t)enabled << 7;

    // Number of entries in this table
    // Range of num is 0 to 127.
    _pg_data[_pg_byteindex] |= (uint8_t)num;
    _pg_byteindex += 1; // close bit field

    // List of independent variables
    // Range of indices is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        float16ToBeBytes((float)indices[_pg_i], _pg_data, &_pg_byteindex, 10);

    // List of dependent variables
    // Range of data is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        float16ToBeBytes((float)data[_pg_i], _pg_data, &_pg_byteindex, 10);

    *_pg_bytecount = _pg_byteindex;

}// efiTable1D_t::encode

/*!
 * \brief Decode a efiTable1D_t from a byte array
 *
 * One dimensional table
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTable1D_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned _pg_i = 0;

    // Table enable. If clear then this table is not used
    enabled = (_pg_data[_pg_byteindex] >> 7);

    // Number of entries in this table
    // Range of num is 0 to 127.
    num = ((_pg_data[_pg_byteindex]) & 0x7F);
    _pg_byteindex += 1; // close bit field

    // List of independent variables
    // Range of indices is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        indices[_pg_i] = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // List of dependent variables
    // Range of data is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        data[_pg_i] = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTable1D_t::decode

/*!
 * \brief Encode a efiInterruptDetail_t into a byte array
 *
 * Details about the timing of an interrupt
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiInterruptDetail_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    // Number of times this interrupt fired during the reporting period
    // Range of count is 0 to 65535.
    uint16ToBeBytes(count, _pg_data, &_pg_byteindex);

    // Total amount of time used by this interrupt during the reporting period
    // Range of totaltime is 0 to 65535.
    uint16ToBeBytes(totaltime, _pg_data, &_pg_byteindex);

    // Number of times this interrupt was preempted
    // Range of preemptcount is 0 to 255.
    uint8ToBytes(preemptcount, _pg_data, &_pg_byteindex);

    // Maximum amount of time in microseconds this interrupt took during this reporting period
    // Range of maxtime is 0 to 255.
    uint8ToBytes(maxtime, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efiInterruptDetail_t::encode

/*!
 * \brief Decode a efiInterruptDetail_t from a byte array
 *
 * Details about the timing of an interrupt
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiInterruptDetail_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // Number of times this interrupt fired during the reporting period
    // Range of count is 0 to 65535.
    count = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Total amount of time used by this interrupt during the reporting period
    // Range of totaltime is 0 to 65535.
    totaltime = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Number of times this interrupt was preempted
    // Range of preemptcount is 0 to 255.
    preemptcount = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Maximum amount of time in microseconds this interrupt took during this reporting period
    // Range of maxtime is 0 to 255.
    maxtime = uint8FromBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiInterruptDetail_t::decode

/*!
 * \brief Create the efiTelemetryTime packet
 *
 * Time information for telemetry. The telemetry time packet is always output
 * immediately before the telemetry fast packet, and before the slow telemetry
 * packets. If fast and slow telemetry are output on the same epoch then only a
 * single time packet is output.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryTime_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Time in milliseconds since the system booted up.
    // Range of time is 0 to -2147483648.
    uint32ToBeBytes(time, _pg_data, &_pg_byteindex);

    // If set this time packet applies to fast telemetry data that immediately follows this packet.
    _pg_data[_pg_byteindex] = (uint8_t)fasttime << 7;

    // If set this time packet applies to slow telemetry data that follows this packet.
    _pg_data[_pg_byteindex] |= (uint8_t)slowtime << 6;

    // Reserved bits for future expansion.

    // Number of engine revolutions since the engine was last started.
    // Range of revcount is 0 to 268435455.
    _pg_tempbitfield = (unsigned int)limitMax(revcount, 268435455);
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 4; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryTime_t::encode

/*!
 * \brief Decode the efiTelemetryTime packet
 *
 * Time information for telemetry. The telemetry time packet is always output
 * immediately before the telemetry fast packet, and before the slow telemetry
 * packets. If fast and slow telemetry are output on the same epoch then only a
 * single time packet is output.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryTime_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Time in milliseconds since the system booted up.
    // Range of time is 0 to -2147483648.
    time = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // If set this time packet applies to fast telemetry data that immediately follows this packet.
    fasttime = (_pg_data[_pg_byteindex] >> 7);

    // If set this time packet applies to slow telemetry data that follows this packet.
    slowtime = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Reserved bits for future expansion.

    // Number of engine revolutions since the engine was last started.
    // Range of revcount is 0 to 268435455.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    revcount = _pg_tempbitfield;
    _pg_byteindex += 4; // close bit field

    return true;

}// efiTelemetryTime_t::decode

/*!
 * \brief Encode a efiTelemetryTime_t into a byte array
 *
 * Time information for telemetry. The telemetry time packet is always output
 * immediately before the telemetry fast packet, and before the slow telemetry
 * packets. If fast and slow telemetry are output on the same epoch then only a
 * single time packet is output.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetryTime_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Time in milliseconds since the system booted up.
    // Range of time is 0 to -2147483648.
    uint32ToBeBytes(time, _pg_data, &_pg_byteindex);

    // If set this time packet applies to fast telemetry data that immediately follows this packet.
    _pg_data[_pg_byteindex] = (uint8_t)fasttime << 7;

    // If set this time packet applies to slow telemetry data that follows this packet.
    _pg_data[_pg_byteindex] |= (uint8_t)slowtime << 6;

    // Reserved bits for future expansion.

    // Number of engine revolutions since the engine was last started.
    // Range of revcount is 0 to 268435455.
    _pg_tempbitfield = (unsigned int)limitMax(revcount, 268435455);
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 4; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetryTime_t::encode

/*!
 * \brief Decode a efiTelemetryTime_t from a byte array
 *
 * Time information for telemetry. The telemetry time packet is always output
 * immediately before the telemetry fast packet, and before the slow telemetry
 * packets. If fast and slow telemetry are output on the same epoch then only a
 * single time packet is output.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetryTime_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Time in milliseconds since the system booted up.
    // Range of time is 0 to -2147483648.
    time = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // If set this time packet applies to fast telemetry data that immediately follows this packet.
    fasttime = (_pg_data[_pg_byteindex] >> 7);

    // If set this time packet applies to slow telemetry data that follows this packet.
    slowtime = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Reserved bits for future expansion.

    // Number of engine revolutions since the engine was last started.
    // Range of revcount is 0 to 268435455.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    revcount = _pg_tempbitfield;
    _pg_byteindex += 4; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetryTime_t::decode

/*!
 * \brief Create the efiTelemetryFast packet
 *
 * Fast telemetry, output at the fast telemetry rate.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryFast_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Engine speed in revolutions per minute
    // Range of rpm is 0.0 to 16383.75.
    float32ScaledTo2UnsignedBeBytes(rpm, _pg_data, &_pg_byteindex, 0.0f, 4.0f);

    // Global enable based on physical input
    _pg_data[_pg_byteindex] = (uint8_t)ioEnable << 7;

    // User global enable.
    _pg_data[_pg_byteindex] |= (uint8_t)userEnable << 6;

    // User enable for spark1.
    _pg_data[_pg_byteindex] |= (uint8_t)spark1Enable << 5;

    // User enable for spark2.
    _pg_data[_pg_byteindex] |= (uint8_t)spark2Enable << 4;

    // User enable for spark3.
    _pg_data[_pg_byteindex] |= (uint8_t)spark3Enable << 3;

    // Source of the throttle command information. If the EFI is driving the throttle this is the command source. If the EFI is not driving the throttle this is the source of throttle position data.
    _pg_data[_pg_byteindex] |= (uint8_t)throttleCmdSrc;
    _pg_byteindex += 1; // close bit field


    // Throttle command (0 to 100%) going in.
    // Range of throttleCmd is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(throttleCmd, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Throttle position (0 to 100%) this may be different from the throttleCmd if a curve is applied, or if the governor is interpreting the throttle command.
    // Range of throttlePos is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(throttlePos, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // The third injector duty cycle in percent
    // Range of injector3Duty is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(injector3Duty, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // The first injector duty cycle in percent
    // Range of injector1Duty is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(injector1Duty, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // The second injector duty cycle in percent
    // Range of injector2Duty is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(injector2Duty, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryFast_t::encode

/*!
 * \brief Decode the efiTelemetryFast packet
 *
 * Fast telemetry, output at the fast telemetry rate.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryFast_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Engine speed in revolutions per minute
    // Range of rpm is 0.0 to 16383.75.
    rpm = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/4.0f);

    // Global enable based on physical input
    ioEnable = (_pg_data[_pg_byteindex] >> 7);

    // User global enable.
    userEnable = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // User enable for spark1.
    spark1Enable = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // User enable for spark2.
    spark2Enable = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // User enable for spark3.
    spark3Enable = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Source of the throttle command information. If the EFI is driving the throttle this is the command source. If the EFI is not driving the throttle this is the source of throttle position data.
    throttleCmdSrc = (efiThrottleSource)((_pg_data[_pg_byteindex]) & 0x7);
    _pg_byteindex += 1; // close bit field

    // Throttle command (0 to 100%) going in.
    // Range of throttleCmd is 0.0 to 127.5.
    throttleCmd = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Throttle position (0 to 100%) this may be different from the throttleCmd if a curve is applied, or if the governor is interpreting the throttle command.
    // Range of throttlePos is 0.0 to 127.5.
    throttlePos = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // The third injector duty cycle in percent
    // Range of injector3Duty is 0.0 to 127.5.
    injector3Duty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // The first injector duty cycle in percent
    // Range of injector1Duty is 0.0 to 127.5.
    injector1Duty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // The second injector duty cycle in percent
    // Range of injector2Duty is 0.0 to 127.5.
    injector2Duty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    return true;

}// efiTelemetryFast_t::decode

/*!
 * \brief Encode a efiTelemetryFast_t into a byte array
 *
 * Fast telemetry, output at the fast telemetry rate.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetryFast_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    // Engine speed in revolutions per minute
    // Range of rpm is 0.0 to 16383.75.
    float32ScaledTo2UnsignedBeBytes(rpm, _pg_data, &_pg_byteindex, 0.0f, 4.0f);

    // Global enable based on physical input
    _pg_data[_pg_byteindex] = (uint8_t)ioEnable << 7;

    // User global enable.
    _pg_data[_pg_byteindex] |= (uint8_t)userEnable << 6;

    // User enable for spark1.
    _pg_data[_pg_byteindex] |= (uint8_t)spark1Enable << 5;

    // User enable for spark2.
    _pg_data[_pg_byteindex] |= (uint8_t)spark2Enable << 4;

    // User enable for spark3.
    _pg_data[_pg_byteindex] |= (uint8_t)spark3Enable << 3;

    // Source of the throttle command information. If the EFI is driving the throttle this is the command source. If the EFI is not driving the throttle this is the source of throttle position data.
    _pg_data[_pg_byteindex] |= (uint8_t)throttleCmdSrc;
    _pg_byteindex += 1; // close bit field

    // Throttle command (0 to 100%) going in.
    // Range of throttleCmd is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(throttleCmd, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Throttle position (0 to 100%) this may be different from the throttleCmd if a curve is applied, or if the governor is interpreting the throttle command.
    // Range of throttlePos is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(throttlePos, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // The third injector duty cycle in percent
    // Range of injector3Duty is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(injector3Duty, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // The first injector duty cycle in percent
    // Range of injector1Duty is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(injector1Duty, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // The second injector duty cycle in percent
    // Range of injector2Duty is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(injector2Duty, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetryFast_t::encode

/*!
 * \brief Decode a efiTelemetryFast_t from a byte array
 *
 * Fast telemetry, output at the fast telemetry rate.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetryFast_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // Engine speed in revolutions per minute
    // Range of rpm is 0.0 to 16383.75.
    rpm = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/4.0f);

    // Global enable based on physical input
    ioEnable = (_pg_data[_pg_byteindex] >> 7);

    // User global enable.
    userEnable = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // User enable for spark1.
    spark1Enable = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // User enable for spark2.
    spark2Enable = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // User enable for spark3.
    spark3Enable = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Source of the throttle command information. If the EFI is driving the throttle this is the command source. If the EFI is not driving the throttle this is the source of throttle position data.
    throttleCmdSrc = (efiThrottleSource)((_pg_data[_pg_byteindex]) & 0x7);
    _pg_byteindex += 1; // close bit field

    // Throttle command (0 to 100%) going in.
    // Range of throttleCmd is 0.0 to 127.5.
    throttleCmd = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Throttle position (0 to 100%) this may be different from the throttleCmd if a curve is applied, or if the governor is interpreting the throttle command.
    // Range of throttlePos is 0.0 to 127.5.
    throttlePos = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // The third injector duty cycle in percent
    // Range of injector3Duty is 0.0 to 127.5.
    injector3Duty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // The first injector duty cycle in percent
    // Range of injector1Duty is 0.0 to 127.5.
    injector1Duty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // The second injector duty cycle in percent
    // Range of injector2Duty is 0.0 to 127.5.
    injector2Duty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetryFast_t::decode

/*!
 * \brief Create the efiTelemetrySensors packet
 *
 * First set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetrySensors_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _cht is 0.0 to 255.0.
    float32ScaledTo1UnsignedBytes(_cht, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Source of throttle position information used for table lookups
    _pg_data[_pg_byteindex] = (uint8_t)throttlePosSrc << 5;

    // This bit is set if spare temperature is configured to act as the third CHT
    _pg_data[_pg_byteindex] |= (uint8_t)spareTempIsCHT3 << 4;

    // This bit is set if spare temperature is configured to act as the second MAT
    _pg_data[_pg_byteindex] |= (uint8_t)spareTempIsMAT2 << 3;

    // This bit is set if spare temperature is configured to act as oil temperature
    _pg_data[_pg_byteindex] |= (uint8_t)spareTempIsOilT << 2;

    // Spare temperature in C
    // Range of sparetemp is -100.0 to 411.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)sparetemp, -100.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field


    // Manifold air temperature in C
    // Range of mat is -127.0 to 127.0.
    float32ScaledTo1SignedBytes(mat, _pg_data, &_pg_byteindex, 1.0f);

    // Manifold air pressure in kiloPascals.
    // Range of map is 0.0 to 131.04.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)map, 0.0f, 31.25f, 12);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;


    // Baro air pressure in kiloPascals.
    // Range of baro is 0.0 to 131.04.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)baro, 0.0f, 31.25f, 12);
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 3; // close bit field


    // Outside air temperature (as measured by the digital barometer) in C.
    // Range of oat is -127.0 to 127.0.
    float32ScaledTo1SignedBytes(oat, _pg_data, &_pg_byteindex, 1.0f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetrySensors_t::encode

/*!
 * \brief Decode the efiTelemetrySensors packet
 *
 * First set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySensors_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _cht is 0.0 to 255.0.
    _cht = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Source of throttle position information used for table lookups
    throttlePosSrc = (efiThrottleSource)(_pg_data[_pg_byteindex] >> 5);

    // This bit is set if spare temperature is configured to act as the third CHT
    spareTempIsCHT3 = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // This bit is set if spare temperature is configured to act as the second MAT
    spareTempIsMAT2 = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // This bit is set if spare temperature is configured to act as oil temperature
    spareTempIsOilT = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Spare temperature in C
    // Range of sparetemp is -100.0 to 411.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    sparetemp = float32ScaledFromBitfield(_pg_tempbitfield, -100.0f, 1.0f/2.0f);
    _pg_byteindex += 2; // close bit field

    // Manifold air temperature in C
    // Range of mat is -127.0 to 127.0.
    mat = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // Manifold air pressure in kiloPascals.
    // Range of map is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    map = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);

    // Baro air pressure in kiloPascals.
    // Range of baro is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    baro = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);
    _pg_byteindex += 3; // close bit field

    // Outside air temperature (as measured by the digital barometer) in C.
    // Range of oat is -127.0 to 127.0.
    oat = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    return true;

}// efiTelemetrySensors_t::decode

/*!
 * \brief Encode a efiTelemetrySensors_t into a byte array
 *
 * First set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetrySensors_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _cht is 0.0 to 255.0.
    float32ScaledTo1UnsignedBytes(_cht, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Source of throttle position information used for table lookups
    _pg_data[_pg_byteindex] = (uint8_t)throttlePosSrc << 5;

    // This bit is set if spare temperature is configured to act as the third CHT
    _pg_data[_pg_byteindex] |= (uint8_t)spareTempIsCHT3 << 4;

    // This bit is set if spare temperature is configured to act as the second MAT
    _pg_data[_pg_byteindex] |= (uint8_t)spareTempIsMAT2 << 3;

    // This bit is set if spare temperature is configured to act as oil temperature
    _pg_data[_pg_byteindex] |= (uint8_t)spareTempIsOilT << 2;

    // Spare temperature in C
    // Range of sparetemp is -100.0 to 411.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)sparetemp, -100.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // Manifold air temperature in C
    // Range of mat is -127.0 to 127.0.
    float32ScaledTo1SignedBytes(mat, _pg_data, &_pg_byteindex, 1.0f);

    // Manifold air pressure in kiloPascals.
    // Range of map is 0.0 to 131.04.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)map, 0.0f, 31.25f, 12);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // Baro air pressure in kiloPascals.
    // Range of baro is 0.0 to 131.04.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)baro, 0.0f, 31.25f, 12);
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 3; // close bit field

    // Outside air temperature (as measured by the digital barometer) in C.
    // Range of oat is -127.0 to 127.0.
    float32ScaledTo1SignedBytes(oat, _pg_data, &_pg_byteindex, 1.0f);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetrySensors_t::encode

/*!
 * \brief Decode a efiTelemetrySensors_t from a byte array
 *
 * First set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySensors_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _cht is 0.0 to 255.0.
    _cht = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Source of throttle position information used for table lookups
    throttlePosSrc = (efiThrottleSource)(_pg_data[_pg_byteindex] >> 5);

    // This bit is set if spare temperature is configured to act as the third CHT
    spareTempIsCHT3 = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // This bit is set if spare temperature is configured to act as the second MAT
    spareTempIsMAT2 = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // This bit is set if spare temperature is configured to act as oil temperature
    spareTempIsOilT = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Spare temperature in C
    // Range of sparetemp is -100.0 to 411.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    sparetemp = float32ScaledFromBitfield(_pg_tempbitfield, -100.0f, 1.0f/2.0f);
    _pg_byteindex += 2; // close bit field

    // Manifold air temperature in C
    // Range of mat is -127.0 to 127.0.
    mat = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // Manifold air pressure in kiloPascals.
    // Range of map is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    map = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);

    // Baro air pressure in kiloPascals.
    // Range of baro is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    baro = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);
    _pg_byteindex += 3; // close bit field

    // Outside air temperature (as measured by the digital barometer) in C.
    // Range of oat is -127.0 to 127.0.
    oat = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySensors_t::decode

/*!
 * \brief Decode the efiTelemetrySensorsapi7 packet
 *
 * First set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySensorsapi7_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _cht is 0.0 to 255.0.
    _cht = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // First cylinder head temperature in C. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _cht1 is 0.0 to 255.0.
    _cht1 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Spare temperature in C
    // Range of sparetemp is -127.0 to 127.0.
    sparetemp = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // Manifold air temperature in C
    // Range of mat is -127.0 to 127.0.
    mat = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // Manifold air pressure in kiloPascals.
    // Range of map is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    map = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);

    // Baro air pressure in kiloPascals.
    // Range of baro is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    baro = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);
    _pg_byteindex += 3; // close bit field

    // Outside air temperature (as measured by the digital barometer) in C.
    // Range of oat is -127.0 to 127.0.
    oat = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    return true;

}// efiTelemetrySensorsapi7_t::decode

/*!
 * \brief Decode a efiTelemetrySensorsapi7_t from a byte array
 *
 * First set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySensorsapi7_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _cht is 0.0 to 255.0.
    _cht = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // First cylinder head temperature in C. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _cht1 is 0.0 to 255.0.
    _cht1 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Spare temperature in C
    // Range of sparetemp is -127.0 to 127.0.
    sparetemp = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // Manifold air temperature in C
    // Range of mat is -127.0 to 127.0.
    mat = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // Manifold air pressure in kiloPascals.
    // Range of map is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    map = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);

    // Baro air pressure in kiloPascals.
    // Range of baro is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    baro = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);
    _pg_byteindex += 3; // close bit field

    // Outside air temperature (as measured by the digital barometer) in C.
    // Range of oat is -127.0 to 127.0.
    oat = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySensorsapi7_t::decode

/*!
 * \brief Create the efiTelemetrySensors2 packet
 *
 * Second set of sensor telemetry, output at slow telemetry rate. The crank
 * sense active signals will be set if the crank sense input is in the active
 * state when this message is generated. This is useful only for measuring the
 * crank sense timing, but not for determining anything when the engine is
 * running.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetrySensors2_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Measured synchronization angle of crank sense 2, as determined by crank sense 1.
    // Range of measuredCrank2Angle is 0.0 to 409.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)measuredCrank2Angle, 0.0f, 10.0f, 12);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;


    // Standard deviation of the measured synchronization angle of crank sense 2, as determined by crank sense 1.
    // Range of devCrank2Angle is 0.0 to 7.5.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)float32ScaledToBitfield((float)devCrank2Angle, 0.0f, 2.0f, 4);

    // Estimated air density in kilogram per cubic meter, deprecated in api 10.
    // Range of _density is 0.0 to 3.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)_density, 0.0f, 1365.0f, 12);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;


    // If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)1 << 3;

    // Set if this packet comes from API 8 or later
    _pg_data[_pg_byteindex + 3] |= (uint8_t)1 << 2;

    // Set if the first crank sense signal is in the active state.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)crankSense1Active << 1;

    // Set if the second crank sense signal is in the active state
    _pg_data[_pg_byteindex + 3] |= (uint8_t)crankSense2Active;
    _pg_byteindex += 4; // close bit field


    // Second cooling output in percent
    // Range of cooling2 is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(cooling2, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Error in percent between throttle output and TPS measurement
    // Range of tpsError is -12.7 to 12.7.
    float32ScaledTo1SignedBytes(tpsError, _pg_data, &_pg_byteindex, 10.0f);

    // Analog throttle position sensor in percent
    // Range of analogTPS is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(analogTPS, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // PWM throttle position sensor in percent
    // Range of pwmTPS is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(pwmTPS, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetrySensors2_t::encode

/*!
 * \brief Decode the efiTelemetrySensors2 packet
 *
 * Second set of sensor telemetry, output at slow telemetry rate. The crank
 * sense active signals will be set if the crank sense input is in the active
 * state when this message is generated. This is useful only for measuring the
 * crank sense timing, but not for determining anything when the engine is
 * running.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySensors2_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Measured synchronization angle of crank sense 2, as determined by crank sense 1.
    // Range of measuredCrank2Angle is 0.0 to 409.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    measuredCrank2Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Standard deviation of the measured synchronization angle of crank sense 2, as determined by crank sense 1.
    // Range of devCrank2Angle is 0.0 to 7.5.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex + 1]) & 0xF);
    devCrank2Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Estimated air density in kilogram per cubic meter, deprecated in api 10.
    // Range of _density is 0.0 to 3.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 4);

    _density = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1365.0f);

    // If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used.
    expectSensors4 = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // Set if this packet comes from API 8 or later
    api8 = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);
    // Decoded value must be 1
    if(api8 != 1)
        return false;

    // Set if the first crank sense signal is in the active state.
    crankSense1Active = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // Set if the second crank sense signal is in the active state
    crankSense2Active = ((_pg_data[_pg_byteindex + 3]) & 0x1);
    _pg_byteindex += 4; // close bit field

    // Second cooling output in percent
    // Range of cooling2 is 0.0 to 127.5.
    cooling2 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Error in percent between throttle output and TPS measurement
    // Range of tpsError is -12.7 to 12.7.
    tpsError = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/10.0f);

    // Analog throttle position sensor in percent
    // Range of analogTPS is 0.0 to 127.5.
    analogTPS = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // PWM throttle position sensor in percent
    // Range of pwmTPS is 0.0 to 127.5.
    pwmTPS = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    return true;

}// efiTelemetrySensors2_t::decode

/*!
 * \brief Encode a efiTelemetrySensors2_t into a byte array
 *
 * Second set of sensor telemetry, output at slow telemetry rate. The crank
 * sense active signals will be set if the crank sense input is in the active
 * state when this message is generated. This is useful only for measuring the
 * crank sense timing, but not for determining anything when the engine is
 * running.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetrySensors2_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Measured synchronization angle of crank sense 2, as determined by crank sense 1.
    // Range of measuredCrank2Angle is 0.0 to 409.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)measuredCrank2Angle, 0.0f, 10.0f, 12);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // Standard deviation of the measured synchronization angle of crank sense 2, as determined by crank sense 1.
    // Range of devCrank2Angle is 0.0 to 7.5.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)float32ScaledToBitfield((float)devCrank2Angle, 0.0f, 2.0f, 4);

    // Estimated air density in kilogram per cubic meter, deprecated in api 10.
    // Range of _density is 0.0 to 3.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)_density, 0.0f, 1365.0f, 12);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    // If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)1 << 3;

    // Set if this packet comes from API 8 or later
    _pg_data[_pg_byteindex + 3] |= (uint8_t)1 << 2;

    // Set if the first crank sense signal is in the active state.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)crankSense1Active << 1;

    // Set if the second crank sense signal is in the active state
    _pg_data[_pg_byteindex + 3] |= (uint8_t)crankSense2Active;
    _pg_byteindex += 4; // close bit field

    // Second cooling output in percent
    // Range of cooling2 is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(cooling2, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Error in percent between throttle output and TPS measurement
    // Range of tpsError is -12.7 to 12.7.
    float32ScaledTo1SignedBytes(tpsError, _pg_data, &_pg_byteindex, 10.0f);

    // Analog throttle position sensor in percent
    // Range of analogTPS is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(analogTPS, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // PWM throttle position sensor in percent
    // Range of pwmTPS is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(pwmTPS, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetrySensors2_t::encode

/*!
 * \brief Decode a efiTelemetrySensors2_t from a byte array
 *
 * Second set of sensor telemetry, output at slow telemetry rate. The crank
 * sense active signals will be set if the crank sense input is in the active
 * state when this message is generated. This is useful only for measuring the
 * crank sense timing, but not for determining anything when the engine is
 * running.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySensors2_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Measured synchronization angle of crank sense 2, as determined by crank sense 1.
    // Range of measuredCrank2Angle is 0.0 to 409.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    measuredCrank2Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Standard deviation of the measured synchronization angle of crank sense 2, as determined by crank sense 1.
    // Range of devCrank2Angle is 0.0 to 7.5.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex + 1]) & 0xF);
    devCrank2Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Estimated air density in kilogram per cubic meter, deprecated in api 10.
    // Range of _density is 0.0 to 3.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 4);

    _density = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1365.0f);

    // If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used.
    expectSensors4 = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // Set if this packet comes from API 8 or later
    api8 = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);
    // Decoded value must be 1
    if(api8 != 1)
        return false;

    // Set if the first crank sense signal is in the active state.
    crankSense1Active = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // Set if the second crank sense signal is in the active state
    crankSense2Active = ((_pg_data[_pg_byteindex + 3]) & 0x1);
    _pg_byteindex += 4; // close bit field

    // Second cooling output in percent
    // Range of cooling2 is 0.0 to 127.5.
    cooling2 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Error in percent between throttle output and TPS measurement
    // Range of tpsError is -12.7 to 12.7.
    tpsError = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/10.0f);

    // Analog throttle position sensor in percent
    // Range of analogTPS is 0.0 to 127.5.
    analogTPS = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // PWM throttle position sensor in percent
    // Range of pwmTPS is 0.0 to 127.5.
    pwmTPS = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySensors2_t::decode

/*!
 * \brief Decode the efiTelemetrySensors2api7 packet
 *
 * Second set of sensor telemetry, output at slow telemetry rate. The crank
 * sense active signals will be set if the crank sense input is in the active
 * state when this message is generated. This is useful only for measuring the
 * crank sense timing, but not for determining anything when the engine is
 * running.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySensors2api7_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Fuel pressure in kiloPascals. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _fuelp is 0.0 to 1310.7.
    _fuelp = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Estimated air density in kilogram per cubic meter.
    // Range of density is 0.0 to 3.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    density = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1365.0f);

    // If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used.
    expectSensors4 = ((_pg_data[_pg_byteindex + 1] >> 3) & 0x1);

    // Clear if this packet comes from before API 8
    api8 = ((_pg_data[_pg_byteindex + 1] >> 2) & 0x1);
    // Decoded value must be 0
    if(api8 != 0)
        return false;

    // Set if the first crank sense signal is in the active state.
    crankSense1Active = ((_pg_data[_pg_byteindex + 1] >> 1) & 0x1);

    // Set if the second crank sense signal is in the active state
    crankSense2Active = ((_pg_data[_pg_byteindex + 1]) & 0x1);
    _pg_byteindex += 2; // close bit field

    // Second cooling output in percent
    // Range of cooling2 is 0.0 to 127.5.
    cooling2 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Error in percent between throttle output and TPS measurement
    // Range of tpsError is -12.7 to 12.7.
    tpsError = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/10.0f);

    // Analog throttle position sensor in percent
    // Range of analogTPS is 0.0 to 127.5.
    analogTPS = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // PWM throttle position sensor in percent
    // Range of pwmTPS is 0.0 to 127.5.
    pwmTPS = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    return true;

}// efiTelemetrySensors2api7_t::decode

/*!
 * \brief Decode a efiTelemetrySensors2api7_t from a byte array
 *
 * Second set of sensor telemetry, output at slow telemetry rate. The crank
 * sense active signals will be set if the crank sense input is in the active
 * state when this message is generated. This is useful only for measuring the
 * crank sense timing, but not for determining anything when the engine is
 * running.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySensors2api7_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Fuel pressure in kiloPascals. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    // Range of _fuelp is 0.0 to 1310.7.
    _fuelp = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Estimated air density in kilogram per cubic meter.
    // Range of density is 0.0 to 3.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    density = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1365.0f);

    // If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used.
    expectSensors4 = ((_pg_data[_pg_byteindex + 1] >> 3) & 0x1);

    // Clear if this packet comes from before API 8
    api8 = ((_pg_data[_pg_byteindex + 1] >> 2) & 0x1);
    // Decoded value must be 0
    if(api8 != 0)
        return false;

    // Set if the first crank sense signal is in the active state.
    crankSense1Active = ((_pg_data[_pg_byteindex + 1] >> 1) & 0x1);

    // Set if the second crank sense signal is in the active state
    crankSense2Active = ((_pg_data[_pg_byteindex + 1]) & 0x1);
    _pg_byteindex += 2; // close bit field

    // Second cooling output in percent
    // Range of cooling2 is 0.0 to 127.5.
    cooling2 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Error in percent between throttle output and TPS measurement
    // Range of tpsError is -12.7 to 12.7.
    tpsError = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/10.0f);

    // Analog throttle position sensor in percent
    // Range of analogTPS is 0.0 to 127.5.
    analogTPS = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // PWM throttle position sensor in percent
    // Range of pwmTPS is 0.0 to 127.5.
    pwmTPS = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySensors2api7_t::decode

/*!
 * \brief Decode the efiTelemetrySensors3api0 packet
 *
 * Third set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySensors3api0_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Input voltage in Volts.
    // Range of inputVolts is 0.0 to 51.1.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 1;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 7);

    inputVolts = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Input current in Amps.
    // Range of inputCurrent is 0.0 to 3.175.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex + 1]) & 0x7F);
    inputCurrent = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/40.0f);
    _pg_byteindex += 2; // close bit field

    // 12V rail voltage in Volts.
    // Range of volts12 is 7.0 to 17.2.
    volts12 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 7.0f, 1.0f/25.0f);

    // 12V rail current in Amps.
    // Range of current12 is 0.0 to 6.375.
    current12 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/40.0f);

    return true;

}// efiTelemetrySensors3api0_t::decode

/*!
 * \brief Decode a efiTelemetrySensors3api0_t from a byte array
 *
 * Third set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySensors3api0_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Input voltage in Volts.
    // Range of inputVolts is 0.0 to 51.1.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 1;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 7);

    inputVolts = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Input current in Amps.
    // Range of inputCurrent is 0.0 to 3.175.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex + 1]) & 0x7F);
    inputCurrent = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/40.0f);
    _pg_byteindex += 2; // close bit field

    // 12V rail voltage in Volts.
    // Range of volts12 is 7.0 to 17.2.
    volts12 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 7.0f, 1.0f/25.0f);

    // 12V rail current in Amps.
    // Range of current12 is 0.0 to 6.375.
    current12 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/40.0f);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySensors3api0_t::decode

/*!
 * \brief Create the efiTelemetrySensors3 packet
 *
 * Third set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetrySensors3_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Input voltage in Volts.
    // Range of inputVolts is 0.0 to 51.1.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)inputVolts, 0.0f, 10.0f, 9);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 7);

    _pg_tempbitfield >>= 1;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;


    // Input current in Amps.
    // Range of inputCurrent is 0.0 to 3.175.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)float32ScaledToBitfield((float)inputCurrent, 0.0f, 40.0f, 7);
    _pg_byteindex += 2; // close bit field


    // 12V rail voltage in Volts.
    // Range of volts12 is 7.0 to 17.2.
    float32ScaledTo1UnsignedBytes(volts12, _pg_data, &_pg_byteindex, 7.0f, 25.0f);

    // 12V rail current in Amps.
    // Range of current12 is 0.0 to 6.375.
    float32ScaledTo1UnsignedBytes(current12, _pg_data, &_pg_byteindex, 0.0f, 40.0f);

    // Baro air pressure in kiloPascals from the digital barometer.
    // Range of baroDigital is 0.0 to 131.04.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)baroDigital, 0.0f, 31.25f, 12);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;


    // Baro air pressure in kiloPascals from the analog barometer.
    // Range of baroAnalog is 0.0 to 131.04.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)baroAnalog, 0.0f, 31.25f, 12);
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 3; // close bit field


    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetrySensors3_t::encode

/*!
 * \brief Decode the efiTelemetrySensors3 packet
 *
 * Third set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySensors3_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Input voltage in Volts.
    // Range of inputVolts is 0.0 to 51.1.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 1;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 7);

    inputVolts = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Input current in Amps.
    // Range of inputCurrent is 0.0 to 3.175.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex + 1]) & 0x7F);
    inputCurrent = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/40.0f);
    _pg_byteindex += 2; // close bit field

    // 12V rail voltage in Volts.
    // Range of volts12 is 7.0 to 17.2.
    volts12 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 7.0f, 1.0f/25.0f);

    // 12V rail current in Amps.
    // Range of current12 is 0.0 to 6.375.
    current12 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/40.0f);

    // Baro air pressure in kiloPascals from the digital barometer.
    // Range of baroDigital is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    baroDigital = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);

    // Baro air pressure in kiloPascals from the analog barometer.
    // Range of baroAnalog is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    baroAnalog = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);
    _pg_byteindex += 3; // close bit field

    // Skip over reserved space
    _pg_byteindex += 1;

    return true;

}// efiTelemetrySensors3_t::decode

/*!
 * \brief Encode a efiTelemetrySensors3_t into a byte array
 *
 * Third set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetrySensors3_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Input voltage in Volts.
    // Range of inputVolts is 0.0 to 51.1.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)inputVolts, 0.0f, 10.0f, 9);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 7);

    _pg_tempbitfield >>= 1;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // Input current in Amps.
    // Range of inputCurrent is 0.0 to 3.175.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)float32ScaledToBitfield((float)inputCurrent, 0.0f, 40.0f, 7);
    _pg_byteindex += 2; // close bit field

    // 12V rail voltage in Volts.
    // Range of volts12 is 7.0 to 17.2.
    float32ScaledTo1UnsignedBytes(volts12, _pg_data, &_pg_byteindex, 7.0f, 25.0f);

    // 12V rail current in Amps.
    // Range of current12 is 0.0 to 6.375.
    float32ScaledTo1UnsignedBytes(current12, _pg_data, &_pg_byteindex, 0.0f, 40.0f);

    // Baro air pressure in kiloPascals from the digital barometer.
    // Range of baroDigital is 0.0 to 131.04.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)baroDigital, 0.0f, 31.25f, 12);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // Baro air pressure in kiloPascals from the analog barometer.
    // Range of baroAnalog is 0.0 to 131.04.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)baroAnalog, 0.0f, 31.25f, 12);
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 3; // close bit field

    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetrySensors3_t::encode

/*!
 * \brief Decode a efiTelemetrySensors3_t from a byte array
 *
 * Third set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySensors3_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Input voltage in Volts.
    // Range of inputVolts is 0.0 to 51.1.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 1;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 7);

    inputVolts = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Input current in Amps.
    // Range of inputCurrent is 0.0 to 3.175.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex + 1]) & 0x7F);
    inputCurrent = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/40.0f);
    _pg_byteindex += 2; // close bit field

    // 12V rail voltage in Volts.
    // Range of volts12 is 7.0 to 17.2.
    volts12 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 7.0f, 1.0f/25.0f);

    // 12V rail current in Amps.
    // Range of current12 is 0.0 to 6.375.
    current12 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/40.0f);

    // Baro air pressure in kiloPascals from the digital barometer.
    // Range of baroDigital is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    baroDigital = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);

    // Baro air pressure in kiloPascals from the analog barometer.
    // Range of baroAnalog is 0.0 to 131.04.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    baroAnalog = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/31.25f);
    _pg_byteindex += 3; // close bit field

    // Skip over reserved space
    _pg_byteindex += 1;

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySensors3_t::decode

/*!
 * \brief Create the efiTelemetrySensors4 packet
 *
 * Fourth set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetrySensors4_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Average cylinder head temperature in C.
    // Range of cht is -100.0 to 411.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)cht, -100.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;


    // First cylinder head temperature in C.
    // Range of cht1 is -100.0 to 411.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)cht1, -100.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;

    // Second cylinder head temperature in C.
    // Range of cht2 is -100.0 to 411.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)cht2, -100.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;

    // The direction of rotation measured by the crank wheel(s) or by the once-per-rev sensors.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)crankdirection;
    _pg_byteindex += 4; // close bit field


    // Charge temperature coefficient from 0 to 1 that determines how much CHT is used in the computation of charge temperature.
    // Range of chargeTempCoef is 0.0 to 1.275.
    float32ScaledTo1UnsignedBytes(chargeTempCoef, _pg_data, &_pg_byteindex, 0.0f, 200.0f);

    // Deprecated in API 10, do not use.
    float32ScaledTo1UnsignedBytes(1, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Fuel pressure in kiloPascals.
    // Range of fuelp is -65504.0 to 65504.0.
    float16ToBeBytes((float)fuelp, _pg_data, &_pg_byteindex, 10);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetrySensors4_t::encode

/*!
 * \brief Decode the efiTelemetrySensors4 packet
 *
 * Fourth set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySensors4_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Average cylinder head temperature in C.
    // Range of cht is -100.0 to 411.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 6);

    cht = float32ScaledFromBitfield(_pg_tempbitfield, -100.0f, 1.0f/2.0f);

    // First cylinder head temperature in C.
    // Range of cht1 is -100.0 to 411.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0x3F);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    cht1 = float32ScaledFromBitfield(_pg_tempbitfield, -100.0f, 1.0f/2.0f);

    // Second cylinder head temperature in C.
    // Range of cht2 is -100.0 to 411.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 2);

    cht2 = float32ScaledFromBitfield(_pg_tempbitfield, -100.0f, 1.0f/2.0f);

    // The direction of rotation measured by the crank wheel(s) or by the once-per-rev sensors.
    crankdirection = (efiCrankDirection)((_pg_data[_pg_byteindex + 3]) & 0x3);
    _pg_byteindex += 4; // close bit field

    // Charge temperature coefficient from 0 to 1 that determines how much CHT is used in the computation of charge temperature.
    // Range of chargeTempCoef is 0.0 to 1.275.
    chargeTempCoef = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/200.0f);

    // Deprecated in API 10, do not use.
    // Range of _fmHeadTemp2 is 0.0 to 2.55.
    _fmHeadTemp2 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    // Fuel pressure in kiloPascals.
    // Range of fuelp is -65504.0 to 65504.0.
    fuelp = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    return true;

}// efiTelemetrySensors4_t::decode

/*!
 * \brief Encode a efiTelemetrySensors4_t into a byte array
 *
 * Fourth set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetrySensors4_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Average cylinder head temperature in C.
    // Range of cht is -100.0 to 411.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)cht, -100.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // First cylinder head temperature in C.
    // Range of cht1 is -100.0 to 411.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)cht1, -100.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;

    // Second cylinder head temperature in C.
    // Range of cht2 is -100.0 to 411.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)cht2, -100.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;

    // The direction of rotation measured by the crank wheel(s) or by the once-per-rev sensors.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)crankdirection;
    _pg_byteindex += 4; // close bit field

    // Charge temperature coefficient from 0 to 1 that determines how much CHT is used in the computation of charge temperature.
    // Range of chargeTempCoef is 0.0 to 1.275.
    float32ScaledTo1UnsignedBytes(chargeTempCoef, _pg_data, &_pg_byteindex, 0.0f, 200.0f);

    // Deprecated in API 10, do not use.
    float32ScaledTo1UnsignedBytes(1, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Fuel pressure in kiloPascals.
    // Range of fuelp is -65504.0 to 65504.0.
    float16ToBeBytes((float)fuelp, _pg_data, &_pg_byteindex, 10);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetrySensors4_t::encode

/*!
 * \brief Decode a efiTelemetrySensors4_t from a byte array
 *
 * Fourth set of sensor telemetry, output at slow telemetry rate.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySensors4_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Average cylinder head temperature in C.
    // Range of cht is -100.0 to 411.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 6);

    cht = float32ScaledFromBitfield(_pg_tempbitfield, -100.0f, 1.0f/2.0f);

    // First cylinder head temperature in C.
    // Range of cht1 is -100.0 to 411.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0x3F);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    cht1 = float32ScaledFromBitfield(_pg_tempbitfield, -100.0f, 1.0f/2.0f);

    // Second cylinder head temperature in C.
    // Range of cht2 is -100.0 to 411.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 2);

    cht2 = float32ScaledFromBitfield(_pg_tempbitfield, -100.0f, 1.0f/2.0f);

    // The direction of rotation measured by the crank wheel(s) or by the once-per-rev sensors.
    crankdirection = (efiCrankDirection)((_pg_data[_pg_byteindex + 3]) & 0x3);
    _pg_byteindex += 4; // close bit field

    // Charge temperature coefficient from 0 to 1 that determines how much CHT is used in the computation of charge temperature.
    // Range of chargeTempCoef is 0.0 to 1.275.
    chargeTempCoef = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/200.0f);

    // Deprecated in API 10, do not use.
    // Range of _fmHeadTemp2 is 0.0 to 2.55.
    _fmHeadTemp2 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    // Fuel pressure in kiloPascals.
    // Range of fuelp is -65504.0 to 65504.0.
    fuelp = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySensors4_t::decode

/*!
 * \brief Create the efiTelemetryFuel packet
 *
 * Fueling telemetry, output at the slow telemetry rate
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryFuel_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Fuel flow rate in grams per minute.
    // Range of fuelFlowRate is -65504.0 to 65504.0.
    float16ToBeBytes((float)fuelFlowRate, _pg_data, &_pg_byteindex, 10);

    // Fuel consumption in grams since the system turned on.
    // Range of fuelConsumption is -65504.0 to 65504.0.
    float16ToBeBytes((float)fuelConsumption, _pg_data, &_pg_byteindex, 10);

    // Total fuel multiplier for injector 1, including the main fuel multiplier.
    // Range of fmInjector1 is 0.0 to 5.1.
    float32ScaledTo1UnsignedBytes(fmInjector1, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    // Total fuel multiplier for injector 2, including the main fuel multiplier.
    // Range of fmInjector2 is 0.0 to 5.1.
    float32ScaledTo1UnsignedBytes(fmInjector2, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    // Total fuel multiplier for injector 3, including the main fuel multiplier.
    // Range of fmInjector3 is 0.0 to 5.1.
    float32ScaledTo1UnsignedBytes(fmInjector3, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryFuel_t::encode

/*!
 * \brief Decode the efiTelemetryFuel packet
 *
 * Fueling telemetry, output at the slow telemetry rate
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryFuel_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Fuel flow rate in grams per minute.
    // Range of fuelFlowRate is -65504.0 to 65504.0.
    fuelFlowRate = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Fuel consumption in grams since the system turned on.
    // Range of fuelConsumption is -65504.0 to 65504.0.
    fuelConsumption = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Total fuel multiplier for injector 1, including the main fuel multiplier.
    // Range of fmInjector1 is 0.0 to 5.1.
    fmInjector1 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Total fuel multiplier for injector 2, including the main fuel multiplier.
    // Range of fmInjector2 is 0.0 to 5.1.
    fmInjector2 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Total fuel multiplier for injector 3, including the main fuel multiplier.
    // Range of fmInjector3 is 0.0 to 5.1.
    fmInjector3 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Skip over reserved space
    _pg_byteindex += 1;

    return true;

}// efiTelemetryFuel_t::decode

/*!
 * \brief Encode a efiTelemetryFuel_t into a byte array
 *
 * Fueling telemetry, output at the slow telemetry rate
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetryFuel_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    // Fuel flow rate in grams per minute.
    // Range of fuelFlowRate is -65504.0 to 65504.0.
    float16ToBeBytes((float)fuelFlowRate, _pg_data, &_pg_byteindex, 10);

    // Fuel consumption in grams since the system turned on.
    // Range of fuelConsumption is -65504.0 to 65504.0.
    float16ToBeBytes((float)fuelConsumption, _pg_data, &_pg_byteindex, 10);

    // Total fuel multiplier for injector 1, including the main fuel multiplier.
    // Range of fmInjector1 is 0.0 to 5.1.
    float32ScaledTo1UnsignedBytes(fmInjector1, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    // Total fuel multiplier for injector 2, including the main fuel multiplier.
    // Range of fmInjector2 is 0.0 to 5.1.
    float32ScaledTo1UnsignedBytes(fmInjector2, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    // Total fuel multiplier for injector 3, including the main fuel multiplier.
    // Range of fmInjector3 is 0.0 to 5.1.
    float32ScaledTo1UnsignedBytes(fmInjector3, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetryFuel_t::encode

/*!
 * \brief Decode a efiTelemetryFuel_t from a byte array
 *
 * Fueling telemetry, output at the slow telemetry rate
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetryFuel_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // Fuel flow rate in grams per minute.
    // Range of fuelFlowRate is -65504.0 to 65504.0.
    fuelFlowRate = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Fuel consumption in grams since the system turned on.
    // Range of fuelConsumption is -65504.0 to 65504.0.
    fuelConsumption = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Total fuel multiplier for injector 1, including the main fuel multiplier.
    // Range of fmInjector1 is 0.0 to 5.1.
    fmInjector1 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Total fuel multiplier for injector 2, including the main fuel multiplier.
    // Range of fmInjector2 is 0.0 to 5.1.
    fmInjector2 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Total fuel multiplier for injector 3, including the main fuel multiplier.
    // Range of fmInjector3 is 0.0 to 5.1.
    fmInjector3 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Skip over reserved space
    _pg_byteindex += 1;

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetryFuel_t::decode

/*!
 * \brief Create the efiTelemetryInjector packet
 *
 * Operational details for injectors 1 and 2
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryInjector_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    _pg_data[_pg_byteindex] = 0;

    // Set if injector 1 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)injector1usesense1 << 6;

    // Set if injector 1 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)injector1usesense2 << 5;

    // First injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector1Time is 0.0 to 131071.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injector1Time, 0.0f, 1.0f, 17);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;

    // Crank angle of the first injection.
    // Range of injection1Angle is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injection1Angle, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;


    _pg_data[_pg_byteindex + 4] = 0;

    // Set if injector 2 is being triggered by sense 1
    _pg_data[_pg_byteindex + 4] |= (uint8_t)injector2usesense1 << 6;

    // Set if injector 2 is being triggered by sense 2
    _pg_data[_pg_byteindex + 4] |= (uint8_t)injector2usesense2 << 5;

    // Second injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector2Time is 0.0 to 131071.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injector2Time, 0.0f, 1.0f, 17);
    _pg_data[_pg_byteindex + 6] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 5] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 4] |= (uint8_t)_pg_tempbitfield;

    // Crank angle of the second injection.
    // Range of injection2Angle is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injection2Angle, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 7] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 6] |= (uint8_t)_pg_tempbitfield;

    // Set if injector 3 is being triggered by sense 1
    _pg_data[_pg_byteindex + 7] |= (uint8_t)injector3usesense1 << 1;

    // Set if injector 3 is being triggered by sense 2
    _pg_data[_pg_byteindex + 7] |= (uint8_t)injector3usesense2;
    _pg_byteindex += 8; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryInjector_t::encode

/*!
 * \brief Decode the efiTelemetryInjector packet
 *
 * Operational details for injectors 1 and 2
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryInjector_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Set if injector 1 is being triggered by sense 1
    injector1usesense1 = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if injector 1 is being triggered by sense 2
    injector1usesense2 = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // First injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector1Time is 0.0 to 131071.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x1F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    injector1Time = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);

    // Crank angle of the first injection.
    // Range of injection1Angle is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 2);

    injection1Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Set if injector 2 is being triggered by sense 1
    injector2usesense1 = ((_pg_data[_pg_byteindex + 4] >> 6) & 0x1);

    // Set if injector 2 is being triggered by sense 2
    injector2usesense2 = ((_pg_data[_pg_byteindex + 4] >> 5) & 0x1);

    // Second injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector2Time is 0.0 to 131071.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 4] & 0x1F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 5];

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 6] >> 4);

    injector2Time = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);

    // Crank angle of the second injection.
    // Range of injection2Angle is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 6] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 7] >> 2);

    injection2Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Set if injector 3 is being triggered by sense 1
    injector3usesense1 = ((_pg_data[_pg_byteindex + 7] >> 1) & 0x1);

    // Set if injector 3 is being triggered by sense 2
    injector3usesense2 = ((_pg_data[_pg_byteindex + 7]) & 0x1);
    _pg_byteindex += 8; // close bit field

    return true;

}// efiTelemetryInjector_t::decode

/*!
 * \brief Encode a efiTelemetryInjector_t into a byte array
 *
 * Operational details for injectors 1 and 2
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetryInjector_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    _pg_data[_pg_byteindex] = 0;

    // Set if injector 1 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)injector1usesense1 << 6;

    // Set if injector 1 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)injector1usesense2 << 5;

    // First injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector1Time is 0.0 to 131071.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injector1Time, 0.0f, 1.0f, 17);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;

    // Crank angle of the first injection.
    // Range of injection1Angle is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injection1Angle, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;

    _pg_data[_pg_byteindex + 4] = 0;

    // Set if injector 2 is being triggered by sense 1
    _pg_data[_pg_byteindex + 4] |= (uint8_t)injector2usesense1 << 6;

    // Set if injector 2 is being triggered by sense 2
    _pg_data[_pg_byteindex + 4] |= (uint8_t)injector2usesense2 << 5;

    // Second injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector2Time is 0.0 to 131071.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injector2Time, 0.0f, 1.0f, 17);
    _pg_data[_pg_byteindex + 6] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 5] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 4] |= (uint8_t)_pg_tempbitfield;

    // Crank angle of the second injection.
    // Range of injection2Angle is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injection2Angle, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 7] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 6] |= (uint8_t)_pg_tempbitfield;

    // Set if injector 3 is being triggered by sense 1
    _pg_data[_pg_byteindex + 7] |= (uint8_t)injector3usesense1 << 1;

    // Set if injector 3 is being triggered by sense 2
    _pg_data[_pg_byteindex + 7] |= (uint8_t)injector3usesense2;
    _pg_byteindex += 8; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetryInjector_t::encode

/*!
 * \brief Decode a efiTelemetryInjector_t from a byte array
 *
 * Operational details for injectors 1 and 2
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetryInjector_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Set if injector 1 is being triggered by sense 1
    injector1usesense1 = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if injector 1 is being triggered by sense 2
    injector1usesense2 = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // First injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector1Time is 0.0 to 131071.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x1F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    injector1Time = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);

    // Crank angle of the first injection.
    // Range of injection1Angle is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 2);

    injection1Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Set if injector 2 is being triggered by sense 1
    injector2usesense1 = ((_pg_data[_pg_byteindex + 4] >> 6) & 0x1);

    // Set if injector 2 is being triggered by sense 2
    injector2usesense2 = ((_pg_data[_pg_byteindex + 4] >> 5) & 0x1);

    // Second injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector2Time is 0.0 to 131071.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 4] & 0x1F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 5];

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 6] >> 4);

    injector2Time = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);

    // Crank angle of the second injection.
    // Range of injection2Angle is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 6] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 7] >> 2);

    injection2Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Set if injector 3 is being triggered by sense 1
    injector3usesense1 = ((_pg_data[_pg_byteindex + 7] >> 1) & 0x1);

    // Set if injector 3 is being triggered by sense 2
    injector3usesense2 = ((_pg_data[_pg_byteindex + 7]) & 0x1);
    _pg_byteindex += 8; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetryInjector_t::decode

/*!
 * \brief Create the efiTelemetryExtendedOutputs packet
 *
 * Operational details for the third injector and second and third spark
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryExtendedOutputs_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Spark advance in degrees for the second spark output.
    // Range of sparkAdvance2 is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)sparkAdvance2, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;


    // Spark advance in degrees for the third spark output.
    // Range of sparkAdvance3 is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)sparkAdvance3, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;

    // Crank angle of the third injection.
    // Range of injection3Angle is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injection3Angle, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;


    // third injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector3Time is 0.0 to 131071.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injector3Time, 0.0f, 1.0f, 17);
    _pg_data[_pg_byteindex + 5] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 4] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 6; // close bit field


    // Deprecated in API 10, do not use
    float32ScaledTo1UnsignedBytes(1, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Deprecated in API 10, do not use
    float32ScaledTo1UnsignedBytes(1, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryExtendedOutputs_t::encode

/*!
 * \brief Decode the efiTelemetryExtendedOutputs packet
 *
 * Operational details for the third injector and second and third spark
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryExtendedOutputs_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Spark advance in degrees for the second spark output.
    // Range of sparkAdvance2 is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 6);

    sparkAdvance2 = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Spark advance in degrees for the third spark output.
    // Range of sparkAdvance3 is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0x3F);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    sparkAdvance3 = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Crank angle of the third injection.
    // Range of injection3Angle is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 2);

    injection3Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // third injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector3Time is 0.0 to 131071.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 3] & 0x1);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 4];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 5];

    injector3Time = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);
    _pg_byteindex += 6; // close bit field

    // Deprecated in API 10, do not use
    // Range of _fmChargeTemp3 is 0.0 to 2.55.
    _fmChargeTemp3 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    // Deprecated in API 10, do not use
    // Range of _fmHeadTemp3 is 0.0 to 2.55.
    _fmHeadTemp3 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    return true;

}// efiTelemetryExtendedOutputs_t::decode

/*!
 * \brief Encode a efiTelemetryExtendedOutputs_t into a byte array
 *
 * Operational details for the third injector and second and third spark
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetryExtendedOutputs_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Spark advance in degrees for the second spark output.
    // Range of sparkAdvance2 is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)sparkAdvance2, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // Spark advance in degrees for the third spark output.
    // Range of sparkAdvance3 is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)sparkAdvance3, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;

    // Crank angle of the third injection.
    // Range of injection3Angle is 0.0 to 511.5.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injection3Angle, 0.0f, 2.0f, 10);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;

    // third injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector3Time is 0.0 to 131071.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)injector3Time, 0.0f, 1.0f, 17);
    _pg_data[_pg_byteindex + 5] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 4] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 6; // close bit field

    // Deprecated in API 10, do not use
    float32ScaledTo1UnsignedBytes(1, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Deprecated in API 10, do not use
    float32ScaledTo1UnsignedBytes(1, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetryExtendedOutputs_t::encode

/*!
 * \brief Decode a efiTelemetryExtendedOutputs_t from a byte array
 *
 * Operational details for the third injector and second and third spark
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetryExtendedOutputs_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Spark advance in degrees for the second spark output.
    // Range of sparkAdvance2 is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 6);

    sparkAdvance2 = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Spark advance in degrees for the third spark output.
    // Range of sparkAdvance3 is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0x3F);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    sparkAdvance3 = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Crank angle of the third injection.
    // Range of injection3Angle is 0.0 to 511.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 2);

    injection3Angle = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // third injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    // Range of injector3Time is 0.0 to 131071.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 3] & 0x1);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 4];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 5];

    injector3Time = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);
    _pg_byteindex += 6; // close bit field

    // Deprecated in API 10, do not use
    // Range of _fmChargeTemp3 is 0.0 to 2.55.
    _fmChargeTemp3 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    // Deprecated in API 10, do not use
    // Range of _fmHeadTemp3 is 0.0 to 2.55.
    _fmHeadTemp3 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetryExtendedOutputs_t::decode

/*!
 * \brief Create the efiTelemetrySlow packet
 *
 * Miscellanious telemetry, output at the slow telemetry rate. For any slow
 * output epoch this is always the last packet. Therefore you should trigger
 * display of slow packet data on receipt of this packet (or the slow summary
 * packet).
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetrySlow_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Spark advance in degrees for the first spark output.
    // Range of sparkAdvance1 is -63.5 to 63.5.
    float32ScaledTo1SignedBytes(sparkAdvance1, _pg_data, &_pg_byteindex, 2.0f);

    _pg_data[_pg_byteindex] = 0;

    // Set if spark 1 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)spark1usesense1 << 5;

    // Set if spark 1 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)spark1usesense2 << 4;

    // Set if spark 2 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)spark2usesense1 << 3;

    // Set if spark 2 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)spark2usesense2 << 2;

    // Set if spark 3 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)spark3usesense1 << 1;

    // Set if spark 3 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)spark3usesense2;
    _pg_byteindex += 1; // close bit field


    // Estimated engine shaft power in Watts.
    // Range of power is -65504.0 to 65504.0.
    float16ToBeBytes((float)power, _pg_data, &_pg_byteindex, 10);

    // Set if the RPM controller is running and gettings its command from the user.
    _pg_data[_pg_byteindex] = (uint8_t)rpmControllerFromUser << 7;

    // Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter.
    _pg_data[_pg_byteindex] |= (uint8_t)rpmControllerFromThrottle << 6;

    // Engine speed command in revolutions per minute.
    // Range of rpmcmd is 0.0 to 16383.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)rpmcmd, 0.0f, 1.0f, 14);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field


    // Fuel pump duty cycle in percent
    // Range of pumpduty is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(pumpduty, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // First cooling output in percent
    // Range of cooling1 is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(cooling1, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetrySlow_t::encode

/*!
 * \brief Decode the efiTelemetrySlow packet
 *
 * Miscellanious telemetry, output at the slow telemetry rate. For any slow
 * output epoch this is always the last packet. Therefore you should trigger
 * display of slow packet data on receipt of this packet (or the slow summary
 * packet).
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlow_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Spark advance in degrees for the first spark output.
    // Range of sparkAdvance1 is -63.5 to 63.5.
    sparkAdvance1 = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/2.0f);

    // Set if spark 1 is being triggered by sense 1
    spark1usesense1 = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if spark 1 is being triggered by sense 2
    spark1usesense2 = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set if spark 2 is being triggered by sense 1
    spark2usesense1 = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set if spark 2 is being triggered by sense 2
    spark2usesense2 = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set if spark 3 is being triggered by sense 1
    spark3usesense1 = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set if spark 3 is being triggered by sense 2
    spark3usesense2 = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    // Estimated engine shaft power in Watts.
    // Range of power is -65504.0 to 65504.0.
    power = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Set if the RPM controller is running and gettings its command from the user.
    rpmControllerFromUser = (_pg_data[_pg_byteindex] >> 7);

    // Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter.
    rpmControllerFromThrottle = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Engine speed command in revolutions per minute.
    // Range of rpmcmd is 0.0 to 16383.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    rpmcmd = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);
    _pg_byteindex += 2; // close bit field

    // Fuel pump duty cycle in percent
    // Range of pumpduty is 0.0 to 127.5.
    pumpduty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // First cooling output in percent
    // Range of cooling1 is 0.0 to 127.5.
    cooling1 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    return true;

}// efiTelemetrySlow_t::decode

/*!
 * \brief Encode a efiTelemetrySlow_t into a byte array
 *
 * Miscellanious telemetry, output at the slow telemetry rate. For any slow
 * output epoch this is always the last packet. Therefore you should trigger
 * display of slow packet data on receipt of this packet (or the slow summary
 * packet).
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetrySlow_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Spark advance in degrees for the first spark output.
    // Range of sparkAdvance1 is -63.5 to 63.5.
    float32ScaledTo1SignedBytes(sparkAdvance1, _pg_data, &_pg_byteindex, 2.0f);

    _pg_data[_pg_byteindex] = 0;

    // Set if spark 1 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)spark1usesense1 << 5;

    // Set if spark 1 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)spark1usesense2 << 4;

    // Set if spark 2 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)spark2usesense1 << 3;

    // Set if spark 2 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)spark2usesense2 << 2;

    // Set if spark 3 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)spark3usesense1 << 1;

    // Set if spark 3 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)spark3usesense2;
    _pg_byteindex += 1; // close bit field

    // Estimated engine shaft power in Watts.
    // Range of power is -65504.0 to 65504.0.
    float16ToBeBytes((float)power, _pg_data, &_pg_byteindex, 10);

    // Set if the RPM controller is running and gettings its command from the user.
    _pg_data[_pg_byteindex] = (uint8_t)rpmControllerFromUser << 7;

    // Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter.
    _pg_data[_pg_byteindex] |= (uint8_t)rpmControllerFromThrottle << 6;

    // Engine speed command in revolutions per minute.
    // Range of rpmcmd is 0.0 to 16383.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)rpmcmd, 0.0f, 1.0f, 14);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // Fuel pump duty cycle in percent
    // Range of pumpduty is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(pumpduty, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // First cooling output in percent
    // Range of cooling1 is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(cooling1, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetrySlow_t::encode

/*!
 * \brief Decode a efiTelemetrySlow_t from a byte array
 *
 * Miscellanious telemetry, output at the slow telemetry rate. For any slow
 * output epoch this is always the last packet. Therefore you should trigger
 * display of slow packet data on receipt of this packet (or the slow summary
 * packet).
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySlow_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Spark advance in degrees for the first spark output.
    // Range of sparkAdvance1 is -63.5 to 63.5.
    sparkAdvance1 = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/2.0f);

    // Set if spark 1 is being triggered by sense 1
    spark1usesense1 = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if spark 1 is being triggered by sense 2
    spark1usesense2 = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set if spark 2 is being triggered by sense 1
    spark2usesense1 = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set if spark 2 is being triggered by sense 2
    spark2usesense2 = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set if spark 3 is being triggered by sense 1
    spark3usesense1 = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set if spark 3 is being triggered by sense 2
    spark3usesense2 = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    // Estimated engine shaft power in Watts.
    // Range of power is -65504.0 to 65504.0.
    power = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Set if the RPM controller is running and gettings its command from the user.
    rpmControllerFromUser = (_pg_data[_pg_byteindex] >> 7);

    // Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter.
    rpmControllerFromThrottle = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Engine speed command in revolutions per minute.
    // Range of rpmcmd is 0.0 to 16383.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    rpmcmd = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);
    _pg_byteindex += 2; // close bit field

    // Fuel pump duty cycle in percent
    // Range of pumpduty is 0.0 to 127.5.
    pumpduty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // First cooling output in percent
    // Range of cooling1 is 0.0 to 127.5.
    cooling1 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySlow_t::decode

/*!
 * \brief Decode the efiTelemetrySlowapi7 packet
 *
 * Miscellanious telemetry, output at the slow telemetry rate. For any slow
 * output epoch this is always the last packet. Therefore you should trigger
 * display of slow packet data on receipt of this packet (or the slow summary
 * packet).
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlowapi7_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Spark advance in degrees for the first spark output.
    // Range of sparkAdvance1 is -63.5 to 63.5.
    sparkAdvance1 = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/2.0f);

    // Spark advance in degrees for the second spark output.
    // Range of _sparkAdvance2 is -63.5 to 63.5.
    _sparkAdvance2 = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/2.0f);

    // Estimated engine shaft power in Watts.
    // Range of power is -65504.0 to 65504.0.
    power = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Set if the RPM controller is running and gettings its command from the user.
    rpmControllerFromUser = (_pg_data[_pg_byteindex] >> 7);

    // Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter.
    rpmControllerFromThrottle = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Engine speed command in revolutions per minute.
    // Range of rpmcmd is 0.0 to 16383.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    rpmcmd = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);
    _pg_byteindex += 2; // close bit field

    // Fuel pump duty cycle in percent
    // Range of pumpduty is 0.0 to 127.5.
    pumpduty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // First cooling output in percent
    // Range of cooling1 is 0.0 to 127.5.
    cooling1 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    return true;

}// efiTelemetrySlowapi7_t::decode

/*!
 * \brief Decode a efiTelemetrySlowapi7_t from a byte array
 *
 * Miscellanious telemetry, output at the slow telemetry rate. For any slow
 * output epoch this is always the last packet. Therefore you should trigger
 * display of slow packet data on receipt of this packet (or the slow summary
 * packet).
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySlowapi7_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Spark advance in degrees for the first spark output.
    // Range of sparkAdvance1 is -63.5 to 63.5.
    sparkAdvance1 = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/2.0f);

    // Spark advance in degrees for the second spark output.
    // Range of _sparkAdvance2 is -63.5 to 63.5.
    _sparkAdvance2 = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/2.0f);

    // Estimated engine shaft power in Watts.
    // Range of power is -65504.0 to 65504.0.
    power = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Set if the RPM controller is running and gettings its command from the user.
    rpmControllerFromUser = (_pg_data[_pg_byteindex] >> 7);

    // Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter.
    rpmControllerFromThrottle = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Engine speed command in revolutions per minute.
    // Range of rpmcmd is 0.0 to 16383.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    rpmcmd = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);
    _pg_byteindex += 2; // close bit field

    // Fuel pump duty cycle in percent
    // Range of pumpduty is 0.0 to 127.5.
    pumpduty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // First cooling output in percent
    // Range of cooling1 is 0.0 to 127.5.
    cooling1 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySlowapi7_t::decode

/*!
 * \brief Create the efiTelemetryCPU packet
 *
 * Run time system information including CPU loading
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryCPU_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Total cpu loading in percent
    // Range of cpuLoad is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(cpuLoad, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Percentage of CPU time spent in interrupts
    // Range of intLoad is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(intLoad, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Percentage of available stack space that has been used
    // Range of stack is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(stack, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // CPU temperature in C.
    // Range of cpuTemp is -127.0 to 127.0.
    float32ScaledTo1SignedBytes(cpuTemp, _pg_data, &_pg_byteindex, 1.0f);

    // If set the system booted in safe mode due to too many resets. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system.
    _pg_data[_pg_byteindex] = (uint8_t)safeModeActive << 7;

    // If set the EFI requires a password to be unlocked.
    _pg_data[_pg_byteindex] |= (uint8_t)passwordRequired << 6;

    // EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked
    // Range of unlockLevel is 0 to 3.
    _pg_data[_pg_byteindex] |= (uint8_t)unlockLevel << 4;

    // If set an SD card is detected and configured for data recording, and the SD card telemetry packet should be expected.
    _pg_data[_pg_byteindex] |= (uint8_t)sdcardPresent << 3;

    // If set a GCU (generator control unit) is detected on the CNA bus and the GCU telemetry packet should be expected.
    _pg_data[_pg_byteindex] |= (uint8_t)gcuPresent << 2;

    // reserved bits
    _pg_byteindex += 1; // close bit field


    // Maximum interval of time, in microseconds, between watchdog service events.
    // Range of watchdog is 0.0 to 2550.0.
    float32ScaledTo1UnsignedBytes((float)watchdog, _pg_data, &_pg_byteindex, 0.0f, 0.1f);

    // reserved bits
    _pg_data[_pg_byteindex] = 0;

    // Application programming interface number. Changes to the ICD will increment this number.
    _pg_data[_pg_byteindex] |= (uint8_t)geteficommsApi();
    _pg_byteindex += 1; // close bit field


    // Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds.
    // Range of interrupt is 0 to 255.
    uint8ToBytes((uint8_t)(limitMax(interrupt, 255)), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryCPU_t::encode

/*!
 * \brief Decode the efiTelemetryCPU packet
 *
 * Run time system information including CPU loading
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryCPU_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Total cpu loading in percent
    // Range of cpuLoad is 0.0 to 127.5.
    cpuLoad = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Percentage of CPU time spent in interrupts
    // Range of intLoad is 0.0 to 25.5.
    intLoad = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Percentage of available stack space that has been used
    // Range of stack is 0.0 to 127.5.
    stack = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // CPU temperature in C.
    // Range of cpuTemp is -127.0 to 127.0.
    cpuTemp = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // If set the system booted in safe mode due to too many resets. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system.
    safeModeActive = (_pg_data[_pg_byteindex] >> 7);

    // If set the EFI requires a password to be unlocked.
    passwordRequired = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked
    // Range of unlockLevel is 0 to 3.
    unlockLevel = ((_pg_data[_pg_byteindex] >> 4) & 0x3);

    // If set an SD card is detected and configured for data recording, and the SD card telemetry packet should be expected.
    sdcardPresent = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // If set a GCU (generator control unit) is detected on the CNA bus and the GCU telemetry packet should be expected.
    gcuPresent = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // reserved bits
    _pg_byteindex += 1; // close bit field

    // Maximum interval of time, in microseconds, between watchdog service events.
    // Range of watchdog is 0.0 to 2550.0.
    watchdog = (uint32_t)float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.1f);

    // reserved bits

    // Application programming interface number. Changes to the ICD will increment this number.
    // Range of api is 0 to 31.
    api = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    // Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds.
    // Range of interrupt is 0 to 255.
    interrupt = (uint32_t)uint8FromBytes(_pg_data, &_pg_byteindex);

    return true;

}// efiTelemetryCPU_t::decode

/*!
 * \brief Encode a efiTelemetryCPU_t into a byte array
 *
 * Run time system information including CPU loading
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetryCPU_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    // Total cpu loading in percent
    // Range of cpuLoad is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(cpuLoad, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Percentage of CPU time spent in interrupts
    // Range of intLoad is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(intLoad, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Percentage of available stack space that has been used
    // Range of stack is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(stack, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // CPU temperature in C.
    // Range of cpuTemp is -127.0 to 127.0.
    float32ScaledTo1SignedBytes(cpuTemp, _pg_data, &_pg_byteindex, 1.0f);

    // If set the system booted in safe mode due to too many resets. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system.
    _pg_data[_pg_byteindex] = (uint8_t)safeModeActive << 7;

    // If set the EFI requires a password to be unlocked.
    _pg_data[_pg_byteindex] |= (uint8_t)passwordRequired << 6;

    // EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked
    // Range of unlockLevel is 0 to 3.
    _pg_data[_pg_byteindex] |= (uint8_t)unlockLevel << 4;

    // If set an SD card is detected and configured for data recording, and the SD card telemetry packet should be expected.
    _pg_data[_pg_byteindex] |= (uint8_t)sdcardPresent << 3;

    // If set a GCU (generator control unit) is detected on the CNA bus and the GCU telemetry packet should be expected.
    _pg_data[_pg_byteindex] |= (uint8_t)gcuPresent << 2;

    // reserved bits
    _pg_byteindex += 1; // close bit field

    // Maximum interval of time, in microseconds, between watchdog service events.
    // Range of watchdog is 0.0 to 2550.0.
    float32ScaledTo1UnsignedBytes((float)watchdog, _pg_data, &_pg_byteindex, 0.0f, 0.1f);

    // reserved bits
    _pg_data[_pg_byteindex] = 0;

    // Application programming interface number. Changes to the ICD will increment this number.
    _pg_data[_pg_byteindex] |= (uint8_t)geteficommsApi();
    _pg_byteindex += 1; // close bit field

    // Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds.
    // Range of interrupt is 0 to 255.
    uint8ToBytes((uint8_t)(limitMax(interrupt, 255)), _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetryCPU_t::encode

/*!
 * \brief Decode a efiTelemetryCPU_t from a byte array
 *
 * Run time system information including CPU loading
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetryCPU_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // Total cpu loading in percent
    // Range of cpuLoad is 0.0 to 127.5.
    cpuLoad = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Percentage of CPU time spent in interrupts
    // Range of intLoad is 0.0 to 25.5.
    intLoad = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Percentage of available stack space that has been used
    // Range of stack is 0.0 to 127.5.
    stack = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // CPU temperature in C.
    // Range of cpuTemp is -127.0 to 127.0.
    cpuTemp = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // If set the system booted in safe mode due to too many resets. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system.
    safeModeActive = (_pg_data[_pg_byteindex] >> 7);

    // If set the EFI requires a password to be unlocked.
    passwordRequired = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked
    // Range of unlockLevel is 0 to 3.
    unlockLevel = ((_pg_data[_pg_byteindex] >> 4) & 0x3);

    // If set an SD card is detected and configured for data recording, and the SD card telemetry packet should be expected.
    sdcardPresent = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // If set a GCU (generator control unit) is detected on the CNA bus and the GCU telemetry packet should be expected.
    gcuPresent = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // reserved bits
    _pg_byteindex += 1; // close bit field

    // Maximum interval of time, in microseconds, between watchdog service events.
    // Range of watchdog is 0.0 to 2550.0.
    watchdog = (uint32_t)float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.1f);

    // reserved bits

    // Application programming interface number. Changes to the ICD will increment this number.
    // Range of api is 0 to 31.
    api = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    // Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds.
    // Range of interrupt is 0 to 255.
    interrupt = (uint32_t)uint8FromBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetryCPU_t::decode

/*!
 * \brief Decode the efiTelemetryCPUapi4 packet
 *
 * Run time system information including CPU loading
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryCPUapi4_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Total cpu loading in percent
    // Range of cpuLoad is 0.0 to 127.5.
    cpuLoad = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Percentage of CPU time spent in interrupts
    // Range of intLoad is 0.0 to 25.5.
    intLoad = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Percentage of available stack space that has been used
    // Range of stack is 0.0 to 127.5.
    stack = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // CPU temperature in C.
    // Range of cpuTemp is -127.0 to 127.0.
    cpuTemp = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // reserved bits

    // If set the EFI requires a password to be unlocked.
    passwordRequired = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked
    // Range of unlockLevel is 0 to 3.
    unlockLevel = ((_pg_data[_pg_byteindex] >> 4) & 0x3);

    // Maximum interval of time, in microseconds, between watchdog service events.
    // Range of watchdog is 0.0 to 1638300.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 6);

    watchdog = (uint32_t)float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/0.01f);

    // Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds.
    // Range of interrupt is 0 to 16383.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0x3F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    interrupt = _pg_tempbitfield;
    _pg_byteindex += 4; // close bit field

    return true;

}// efiTelemetryCPUapi4_t::decode

/*!
 * \brief Decode a efiTelemetryCPUapi4_t from a byte array
 *
 * Run time system information including CPU loading
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetryCPUapi4_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Total cpu loading in percent
    // Range of cpuLoad is 0.0 to 127.5.
    cpuLoad = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Percentage of CPU time spent in interrupts
    // Range of intLoad is 0.0 to 25.5.
    intLoad = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Percentage of available stack space that has been used
    // Range of stack is 0.0 to 127.5.
    stack = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // CPU temperature in C.
    // Range of cpuTemp is -127.0 to 127.0.
    cpuTemp = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // reserved bits

    // If set the EFI requires a password to be unlocked.
    passwordRequired = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked
    // Range of unlockLevel is 0 to 3.
    unlockLevel = ((_pg_data[_pg_byteindex] >> 4) & 0x3);

    // Maximum interval of time, in microseconds, between watchdog service events.
    // Range of watchdog is 0.0 to 1638300.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 6);

    watchdog = (uint32_t)float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/0.01f);

    // Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds.
    // Range of interrupt is 0 to 16383.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0x3F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    interrupt = _pg_tempbitfield;
    _pg_byteindex += 4; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetryCPUapi4_t::decode

/*!
 * \brief Create the efiErrors packet
 *
 * Error information, output at the slow telemetry rate. There are two types of
 * error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`)
 * and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors
 * indicate the current error condition, and will automatically clear when the
 * error condition is resolved. Sticky errors are only cleared by sending
 * `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_id is the packet identifier for _pg_pkt
 */
void efiErrors_t::encode(efiPacket_t* _pg_pkt, uint32_t _pg_id)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Set if input voltage is too low
    _pg_data[_pg_byteindex] = (uint8_t)inputvoltagelow << 7;

    // Set if input voltage is too high
    _pg_data[_pg_byteindex] |= (uint8_t)inputvoltagehigh << 6;

    // Set if manifold air temperature sensor is out of range low
    _pg_data[_pg_byteindex] |= (uint8_t)matsensorunderrng << 5;

    // Set if manifold air temperature sensor is out of range high
    _pg_data[_pg_byteindex] |= (uint8_t)matsensoroverrng << 4;

    // Set if first cylinder head temperature sensor is out of range low
    _pg_data[_pg_byteindex] |= (uint8_t)cht1sensorunderrng << 3;

    // Set if first cylinder head temperature sensor is out of range high
    _pg_data[_pg_byteindex] |= (uint8_t)cht1sensoroverrng << 2;

    // Set if second cylinder head temperature sensor is out of range low
    _pg_data[_pg_byteindex] |= (uint8_t)cht2sensorunderrng << 1;

    // Set if second cylinder head temperature sensor is out of range high
    _pg_data[_pg_byteindex] |= (uint8_t)cht2sensoroverrng;

    // Set if manifold air pressure sensor is out of range low
    _pg_data[_pg_byteindex + 1] = (uint8_t)mapsensorunderrng << 7;

    // Set if manifold air pressure sensor is out of range high
    _pg_data[_pg_byteindex + 1] |= (uint8_t)mapsensoroverrng << 6;

    // Set if fuel pressure sensor is out of range low
    _pg_data[_pg_byteindex + 1] |= (uint8_t)fuelpsensorunderrng << 5;

    // Set if fuel pressure sensor is out of range high
    _pg_data[_pg_byteindex + 1] |= (uint8_t)fuelpsensoroverrng << 4;

    // Set if analog TPS sensor is out of range low
    _pg_data[_pg_byteindex + 1] |= (uint8_t)analogtpssensorunderrng << 3;

    // Set if analog TPS is out of range high
    _pg_data[_pg_byteindex + 1] |= (uint8_t)analogtpssensoroverrng << 2;

    // Set if CPU temperature is too low
    _pg_data[_pg_byteindex + 1] |= (uint8_t)cputemplow << 1;

    // Set if CPU temperature is too high
    _pg_data[_pg_byteindex + 1] |= (uint8_t)cputemphigh;

    // Set if spare temperature sensor is out of range low
    _pg_data[_pg_byteindex + 2] = (uint8_t)sparetempsensorunderrng << 7;

    // Set if spare temperature sensor is out of range high
    _pg_data[_pg_byteindex + 2] |= (uint8_t)sparetempsensoroverrng << 6;

    // Set if barometric air pressure sensor is out of range low
    _pg_data[_pg_byteindex + 2] |= (uint8_t)barosensorunderrng << 5;

    // Set if barometric air pressure sensor is out of range high
    _pg_data[_pg_byteindex + 2] |= (uint8_t)barosensoroverrng << 4;

    // Enumerated errors from crank sense1, clear if no errors
    // Range of crank1error is 0 to 7.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)crank1error << 1;

    // Enumerated errors from crank sense2, clear if no errors
    // Range of crank2error is 0 to 7.
    _pg_tempbitfield = (unsigned int)crank2error;
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;

    // Set if the first cylinder head temperature is too low, the head is overcooled
    _pg_data[_pg_byteindex + 3] |= (uint8_t)cht1low << 5;

    // Set if the first cylinder head temperature is too high, the head is overheating
    _pg_data[_pg_byteindex + 3] |= (uint8_t)cht1high << 4;

    // Set if the second cylinder head temperature is too low, the head is overcooled
    _pg_data[_pg_byteindex + 3] |= (uint8_t)cht2low << 3;

    // Set if the second cylinder head temperature is too high, the head is overheating
    _pg_data[_pg_byteindex + 3] |= (uint8_t)cht2high << 2;

    // Set if the fuel pressure is too low
    _pg_data[_pg_byteindex + 3] |= (uint8_t)fuelplow << 1;

    // Set if the fuel pressure is too high
    _pg_data[_pg_byteindex + 3] |= (uint8_t)fuelphigh;

    // Set if the engine RPM exceeded the hard rev limit
    _pg_data[_pg_byteindex + 4] = (uint8_t)hardoverspeed << 7;

    // Set if the engine RPM exceeded the soft rev limit
    _pg_data[_pg_byteindex + 4] |= (uint8_t)softoverspeed << 6;

    // Set if the nonvolatile parameters did not hash to the expected value
    _pg_data[_pg_byteindex + 4] |= (uint8_t)parameterhash << 5;

    // Set if 12V voltage is too low
    _pg_data[_pg_byteindex + 4] |= (uint8_t)voltage12low << 4;

    // Set if 12V voltage is too high
    _pg_data[_pg_byteindex + 4] |= (uint8_t)voltage12high << 3;

    // Set if the input current is too low
    _pg_data[_pg_byteindex + 4] |= (uint8_t)inputcurrentlow << 2;

    // Set if the input current is too high
    _pg_data[_pg_byteindex + 4] |= (uint8_t)inputcurrenthigh << 1;

    // Set if the current of the 12 volt rail is too low
    _pg_data[_pg_byteindex + 4] |= (uint8_t)current12low;

    // Set if the current of the 12 volt rail too high
    _pg_data[_pg_byteindex + 5] = (uint8_t)current12high << 7;

    // Set if the 6 volt power supply is faulted
    _pg_data[_pg_byteindex + 5] |= (uint8_t)power6fault << 6;

    // Set if the first injector has a fault
    _pg_data[_pg_byteindex + 5] |= (uint8_t)injector1fault << 5;

    // Set if the second injector has a fault
    _pg_data[_pg_byteindex + 5] |= (uint8_t)injector2fault << 4;

    // Set if there is a user storage error
    _pg_data[_pg_byteindex + 5] |= (uint8_t)userStorageError << 3;

    // Set if the analog barometric air pressure sensor is out of range low
    _pg_data[_pg_byteindex + 5] |= (uint8_t)analogbarosensorunderrng << 2;

    // Set if the analog barometric air pressure sensor is out of range high
    _pg_data[_pg_byteindex + 5] |= (uint8_t)analogbarosensoroverrng << 1;

    // Set if barometric air pressure sensor is out of range low
    _pg_data[_pg_byteindex + 5] |= (uint8_t)oatsensorunderrng;

    // Set if barometric air pressure sensor is out of range high
    _pg_data[_pg_byteindex + 6] = (uint8_t)oatsensoroverrng << 7;

    // Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    _pg_data[_pg_byteindex + 6] |= (uint8_t)canThrottleMissing << 6;

    // Set if the CAN throttle servo has an error bit set
    _pg_data[_pg_byteindex + 6] |= (uint8_t)canThrottleError << 5;

    // Set if the cooling output 1 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    _pg_data[_pg_byteindex + 6] |= (uint8_t)canCooling1Missing << 4;

    // Set if the CAN cooling 1 servo has an error bit set
    _pg_data[_pg_byteindex + 6] |= (uint8_t)canCooling1Error << 3;

    // Set if throttle was greater than the maximum start throttle while the engine was cranking for start. In that case spark and injector outputs are suspended.
    _pg_data[_pg_byteindex + 6] |= (uint8_t)maxstartthrottle << 2;

    // Set if manifold air pressure sensor is low compared to the estimate
    _pg_data[_pg_byteindex + 6] |= (uint8_t)maplow << 1;

    // Set if manifold air pressure sensor is high compared to the estimate
    _pg_data[_pg_byteindex + 6] |= (uint8_t)maphigh;

    // Set if there is no throttle position source, but the system is configured for one.
    _pg_data[_pg_byteindex + 7] = (uint8_t)tpsmissing << 7;

    // Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle).
    _pg_data[_pg_byteindex + 7] |= (uint8_t)tpserror << 6;

    // Set if an error occurred with the SD card recording. This error will only assert after the SD card has been successfully detected.
    _pg_data[_pg_byteindex + 7] |= (uint8_t)sdcarderror << 5;

    // Reserved for future expansion
    _pg_data[_pg_byteindex + 7] |= (uint8_t)reserved1 << 4;

    // Set if the cooling output 2 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    _pg_data[_pg_byteindex + 7] |= (uint8_t)canCooling2Missing << 3;

    // Set if the CAN cooling 2 servo has an error bit set
    _pg_data[_pg_byteindex + 7] |= (uint8_t)canCooling2Error << 2;

    // If set a maintenance item has been triggered, see the maintenance packet for details.
    _pg_data[_pg_byteindex + 7] |= (uint8_t)maintenanceNeeded << 1;

    // If set the EFI is in test mode or is autocalibrating the throttle servo, refer to packet EFI_PKT_TESTMODE
    _pg_data[_pg_byteindex + 7] |= (uint8_t)testModeActive;
    _pg_byteindex += 8; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, _pg_id);

}// efiErrors_t::encode

/*!
 * \brief Decode the efiErrors packet
 *
 * Error information, output at the slow telemetry rate. There are two types of
 * error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`)
 * and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors
 * indicate the current error condition, and will automatically clear when the
 * error condition is resolved. Sticky errors are only cleared by sending
 * `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiErrors_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier, multiple options exist
    uint32_t _pg_packetid = geteficommsPacketID(_pg_pkt);
    if( _pg_packetid != EFI_PKT_STICKY_ERRORS &&
        _pg_packetid != EFI_PKT_TELEMETRYERRORS )
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Set if input voltage is too low
    inputvoltagelow = (_pg_data[_pg_byteindex] >> 7);

    // Set if input voltage is too high
    inputvoltagehigh = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if manifold air temperature sensor is out of range low
    matsensorunderrng = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if manifold air temperature sensor is out of range high
    matsensoroverrng = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set if first cylinder head temperature sensor is out of range low
    cht1sensorunderrng = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set if first cylinder head temperature sensor is out of range high
    cht1sensoroverrng = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set if second cylinder head temperature sensor is out of range low
    cht2sensorunderrng = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set if second cylinder head temperature sensor is out of range high
    cht2sensoroverrng = ((_pg_data[_pg_byteindex]) & 0x1);

    // Set if manifold air pressure sensor is out of range low
    mapsensorunderrng = (_pg_data[_pg_byteindex + 1] >> 7);

    // Set if manifold air pressure sensor is out of range high
    mapsensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // Set if fuel pressure sensor is out of range low
    fuelpsensorunderrng = ((_pg_data[_pg_byteindex + 1] >> 5) & 0x1);

    // Set if fuel pressure sensor is out of range high
    fuelpsensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 4) & 0x1);

    // Set if analog TPS sensor is out of range low
    analogtpssensorunderrng = ((_pg_data[_pg_byteindex + 1] >> 3) & 0x1);

    // Set if analog TPS is out of range high
    analogtpssensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 2) & 0x1);

    // Set if CPU temperature is too low
    cputemplow = ((_pg_data[_pg_byteindex + 1] >> 1) & 0x1);

    // Set if CPU temperature is too high
    cputemphigh = ((_pg_data[_pg_byteindex + 1]) & 0x1);

    // Set if spare temperature sensor is out of range low
    sparetempsensorunderrng = (_pg_data[_pg_byteindex + 2] >> 7);

    // Set if spare temperature sensor is out of range high
    sparetempsensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 6) & 0x1);

    // Set if barometric air pressure sensor is out of range low
    barosensorunderrng = ((_pg_data[_pg_byteindex + 2] >> 5) & 0x1);

    // Set if barometric air pressure sensor is out of range high
    barosensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x1);

    // Enumerated errors from crank sense1, clear if no errors
    // Range of crank1error is 0 to 7.
    crank1error = ((_pg_data[_pg_byteindex + 2] >> 1) & 0x7);

    // Enumerated errors from crank sense2, clear if no errors
    // Range of crank2error is 0 to 7.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0x1);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 6);

    crank2error = _pg_tempbitfield;

    // Set if the first cylinder head temperature is too low, the head is overcooled
    cht1low = ((_pg_data[_pg_byteindex + 3] >> 5) & 0x1);

    // Set if the first cylinder head temperature is too high, the head is overheating
    cht1high = ((_pg_data[_pg_byteindex + 3] >> 4) & 0x1);

    // Set if the second cylinder head temperature is too low, the head is overcooled
    cht2low = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // Set if the second cylinder head temperature is too high, the head is overheating
    cht2high = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);

    // Set if the fuel pressure is too low
    fuelplow = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // Set if the fuel pressure is too high
    fuelphigh = ((_pg_data[_pg_byteindex + 3]) & 0x1);

    // Set if the engine RPM exceeded the hard rev limit
    hardoverspeed = (_pg_data[_pg_byteindex + 4] >> 7);

    // Set if the engine RPM exceeded the soft rev limit
    softoverspeed = ((_pg_data[_pg_byteindex + 4] >> 6) & 0x1);

    // Set if the nonvolatile parameters did not hash to the expected value
    parameterhash = ((_pg_data[_pg_byteindex + 4] >> 5) & 0x1);

    // Set if 12V voltage is too low
    voltage12low = ((_pg_data[_pg_byteindex + 4] >> 4) & 0x1);

    // Set if 12V voltage is too high
    voltage12high = ((_pg_data[_pg_byteindex + 4] >> 3) & 0x1);

    // Set if the input current is too low
    inputcurrentlow = ((_pg_data[_pg_byteindex + 4] >> 2) & 0x1);

    // Set if the input current is too high
    inputcurrenthigh = ((_pg_data[_pg_byteindex + 4] >> 1) & 0x1);

    // Set if the current of the 12 volt rail is too low
    current12low = ((_pg_data[_pg_byteindex + 4]) & 0x1);

    // Set if the current of the 12 volt rail too high
    current12high = (_pg_data[_pg_byteindex + 5] >> 7);

    // Set if the 6 volt power supply is faulted
    power6fault = ((_pg_data[_pg_byteindex + 5] >> 6) & 0x1);

    // Set if the first injector has a fault
    injector1fault = ((_pg_data[_pg_byteindex + 5] >> 5) & 0x1);

    // Set if the second injector has a fault
    injector2fault = ((_pg_data[_pg_byteindex + 5] >> 4) & 0x1);

    // Set if there is a user storage error
    userStorageError = ((_pg_data[_pg_byteindex + 5] >> 3) & 0x1);

    // Set if the analog barometric air pressure sensor is out of range low
    analogbarosensorunderrng = ((_pg_data[_pg_byteindex + 5] >> 2) & 0x1);

    // Set if the analog barometric air pressure sensor is out of range high
    analogbarosensoroverrng = ((_pg_data[_pg_byteindex + 5] >> 1) & 0x1);

    // Set if barometric air pressure sensor is out of range low
    oatsensorunderrng = ((_pg_data[_pg_byteindex + 5]) & 0x1);

    // Set if barometric air pressure sensor is out of range high
    oatsensoroverrng = (_pg_data[_pg_byteindex + 6] >> 7);

    // Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canThrottleMissing = ((_pg_data[_pg_byteindex + 6] >> 6) & 0x1);

    // Set if the CAN throttle servo has an error bit set
    canThrottleError = ((_pg_data[_pg_byteindex + 6] >> 5) & 0x1);

    // Set if the cooling output 1 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canCooling1Missing = ((_pg_data[_pg_byteindex + 6] >> 4) & 0x1);

    // Set if the CAN cooling 1 servo has an error bit set
    canCooling1Error = ((_pg_data[_pg_byteindex + 6] >> 3) & 0x1);

    // Set if throttle was greater than the maximum start throttle while the engine was cranking for start. In that case spark and injector outputs are suspended.
    maxstartthrottle = ((_pg_data[_pg_byteindex + 6] >> 2) & 0x1);

    // Set if manifold air pressure sensor is low compared to the estimate
    maplow = ((_pg_data[_pg_byteindex + 6] >> 1) & 0x1);

    // Set if manifold air pressure sensor is high compared to the estimate
    maphigh = ((_pg_data[_pg_byteindex + 6]) & 0x1);

    // Set if there is no throttle position source, but the system is configured for one.
    tpsmissing = (_pg_data[_pg_byteindex + 7] >> 7);

    // Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle).
    tpserror = ((_pg_data[_pg_byteindex + 7] >> 6) & 0x1);

    // Set if an error occurred with the SD card recording. This error will only assert after the SD card has been successfully detected.
    sdcarderror = ((_pg_data[_pg_byteindex + 7] >> 5) & 0x1);

    // Reserved for future expansion
    reserved1 = ((_pg_data[_pg_byteindex + 7] >> 4) & 0x1);

    // Set if the cooling output 2 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canCooling2Missing = ((_pg_data[_pg_byteindex + 7] >> 3) & 0x1);

    // Set if the CAN cooling 2 servo has an error bit set
    canCooling2Error = ((_pg_data[_pg_byteindex + 7] >> 2) & 0x1);

    // If set a maintenance item has been triggered, see the maintenance packet for details.
    maintenanceNeeded = ((_pg_data[_pg_byteindex + 7] >> 1) & 0x1);

    // If set the EFI is in test mode or is autocalibrating the throttle servo, refer to packet EFI_PKT_TESTMODE
    testModeActive = ((_pg_data[_pg_byteindex + 7]) & 0x1);
    _pg_byteindex += 8; // close bit field

    return true;

}// efiErrors_t::decode

/*!
 * \brief Encode a efiErrors_t into a byte array
 *
 * Error information, output at the slow telemetry rate. There are two types of
 * error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`)
 * and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors
 * indicate the current error condition, and will automatically clear when the
 * error condition is resolved. Sticky errors are only cleared by sending
 * `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiErrors_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Set if input voltage is too low
    _pg_data[_pg_byteindex] = (uint8_t)inputvoltagelow << 7;

    // Set if input voltage is too high
    _pg_data[_pg_byteindex] |= (uint8_t)inputvoltagehigh << 6;

    // Set if manifold air temperature sensor is out of range low
    _pg_data[_pg_byteindex] |= (uint8_t)matsensorunderrng << 5;

    // Set if manifold air temperature sensor is out of range high
    _pg_data[_pg_byteindex] |= (uint8_t)matsensoroverrng << 4;

    // Set if first cylinder head temperature sensor is out of range low
    _pg_data[_pg_byteindex] |= (uint8_t)cht1sensorunderrng << 3;

    // Set if first cylinder head temperature sensor is out of range high
    _pg_data[_pg_byteindex] |= (uint8_t)cht1sensoroverrng << 2;

    // Set if second cylinder head temperature sensor is out of range low
    _pg_data[_pg_byteindex] |= (uint8_t)cht2sensorunderrng << 1;

    // Set if second cylinder head temperature sensor is out of range high
    _pg_data[_pg_byteindex] |= (uint8_t)cht2sensoroverrng;

    // Set if manifold air pressure sensor is out of range low
    _pg_data[_pg_byteindex + 1] = (uint8_t)mapsensorunderrng << 7;

    // Set if manifold air pressure sensor is out of range high
    _pg_data[_pg_byteindex + 1] |= (uint8_t)mapsensoroverrng << 6;

    // Set if fuel pressure sensor is out of range low
    _pg_data[_pg_byteindex + 1] |= (uint8_t)fuelpsensorunderrng << 5;

    // Set if fuel pressure sensor is out of range high
    _pg_data[_pg_byteindex + 1] |= (uint8_t)fuelpsensoroverrng << 4;

    // Set if analog TPS sensor is out of range low
    _pg_data[_pg_byteindex + 1] |= (uint8_t)analogtpssensorunderrng << 3;

    // Set if analog TPS is out of range high
    _pg_data[_pg_byteindex + 1] |= (uint8_t)analogtpssensoroverrng << 2;

    // Set if CPU temperature is too low
    _pg_data[_pg_byteindex + 1] |= (uint8_t)cputemplow << 1;

    // Set if CPU temperature is too high
    _pg_data[_pg_byteindex + 1] |= (uint8_t)cputemphigh;

    // Set if spare temperature sensor is out of range low
    _pg_data[_pg_byteindex + 2] = (uint8_t)sparetempsensorunderrng << 7;

    // Set if spare temperature sensor is out of range high
    _pg_data[_pg_byteindex + 2] |= (uint8_t)sparetempsensoroverrng << 6;

    // Set if barometric air pressure sensor is out of range low
    _pg_data[_pg_byteindex + 2] |= (uint8_t)barosensorunderrng << 5;

    // Set if barometric air pressure sensor is out of range high
    _pg_data[_pg_byteindex + 2] |= (uint8_t)barosensoroverrng << 4;

    // Enumerated errors from crank sense1, clear if no errors
    // Range of crank1error is 0 to 7.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)crank1error << 1;

    // Enumerated errors from crank sense2, clear if no errors
    // Range of crank2error is 0 to 7.
    _pg_tempbitfield = (unsigned int)crank2error;
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;

    // Set if the first cylinder head temperature is too low, the head is overcooled
    _pg_data[_pg_byteindex + 3] |= (uint8_t)cht1low << 5;

    // Set if the first cylinder head temperature is too high, the head is overheating
    _pg_data[_pg_byteindex + 3] |= (uint8_t)cht1high << 4;

    // Set if the second cylinder head temperature is too low, the head is overcooled
    _pg_data[_pg_byteindex + 3] |= (uint8_t)cht2low << 3;

    // Set if the second cylinder head temperature is too high, the head is overheating
    _pg_data[_pg_byteindex + 3] |= (uint8_t)cht2high << 2;

    // Set if the fuel pressure is too low
    _pg_data[_pg_byteindex + 3] |= (uint8_t)fuelplow << 1;

    // Set if the fuel pressure is too high
    _pg_data[_pg_byteindex + 3] |= (uint8_t)fuelphigh;

    // Set if the engine RPM exceeded the hard rev limit
    _pg_data[_pg_byteindex + 4] = (uint8_t)hardoverspeed << 7;

    // Set if the engine RPM exceeded the soft rev limit
    _pg_data[_pg_byteindex + 4] |= (uint8_t)softoverspeed << 6;

    // Set if the nonvolatile parameters did not hash to the expected value
    _pg_data[_pg_byteindex + 4] |= (uint8_t)parameterhash << 5;

    // Set if 12V voltage is too low
    _pg_data[_pg_byteindex + 4] |= (uint8_t)voltage12low << 4;

    // Set if 12V voltage is too high
    _pg_data[_pg_byteindex + 4] |= (uint8_t)voltage12high << 3;

    // Set if the input current is too low
    _pg_data[_pg_byteindex + 4] |= (uint8_t)inputcurrentlow << 2;

    // Set if the input current is too high
    _pg_data[_pg_byteindex + 4] |= (uint8_t)inputcurrenthigh << 1;

    // Set if the current of the 12 volt rail is too low
    _pg_data[_pg_byteindex + 4] |= (uint8_t)current12low;

    // Set if the current of the 12 volt rail too high
    _pg_data[_pg_byteindex + 5] = (uint8_t)current12high << 7;

    // Set if the 6 volt power supply is faulted
    _pg_data[_pg_byteindex + 5] |= (uint8_t)power6fault << 6;

    // Set if the first injector has a fault
    _pg_data[_pg_byteindex + 5] |= (uint8_t)injector1fault << 5;

    // Set if the second injector has a fault
    _pg_data[_pg_byteindex + 5] |= (uint8_t)injector2fault << 4;

    // Set if there is a user storage error
    _pg_data[_pg_byteindex + 5] |= (uint8_t)userStorageError << 3;

    // Set if the analog barometric air pressure sensor is out of range low
    _pg_data[_pg_byteindex + 5] |= (uint8_t)analogbarosensorunderrng << 2;

    // Set if the analog barometric air pressure sensor is out of range high
    _pg_data[_pg_byteindex + 5] |= (uint8_t)analogbarosensoroverrng << 1;

    // Set if barometric air pressure sensor is out of range low
    _pg_data[_pg_byteindex + 5] |= (uint8_t)oatsensorunderrng;

    // Set if barometric air pressure sensor is out of range high
    _pg_data[_pg_byteindex + 6] = (uint8_t)oatsensoroverrng << 7;

    // Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    _pg_data[_pg_byteindex + 6] |= (uint8_t)canThrottleMissing << 6;

    // Set if the CAN throttle servo has an error bit set
    _pg_data[_pg_byteindex + 6] |= (uint8_t)canThrottleError << 5;

    // Set if the cooling output 1 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    _pg_data[_pg_byteindex + 6] |= (uint8_t)canCooling1Missing << 4;

    // Set if the CAN cooling 1 servo has an error bit set
    _pg_data[_pg_byteindex + 6] |= (uint8_t)canCooling1Error << 3;

    // Set if throttle was greater than the maximum start throttle while the engine was cranking for start. In that case spark and injector outputs are suspended.
    _pg_data[_pg_byteindex + 6] |= (uint8_t)maxstartthrottle << 2;

    // Set if manifold air pressure sensor is low compared to the estimate
    _pg_data[_pg_byteindex + 6] |= (uint8_t)maplow << 1;

    // Set if manifold air pressure sensor is high compared to the estimate
    _pg_data[_pg_byteindex + 6] |= (uint8_t)maphigh;

    // Set if there is no throttle position source, but the system is configured for one.
    _pg_data[_pg_byteindex + 7] = (uint8_t)tpsmissing << 7;

    // Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle).
    _pg_data[_pg_byteindex + 7] |= (uint8_t)tpserror << 6;

    // Set if an error occurred with the SD card recording. This error will only assert after the SD card has been successfully detected.
    _pg_data[_pg_byteindex + 7] |= (uint8_t)sdcarderror << 5;

    // Reserved for future expansion
    _pg_data[_pg_byteindex + 7] |= (uint8_t)reserved1 << 4;

    // Set if the cooling output 2 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    _pg_data[_pg_byteindex + 7] |= (uint8_t)canCooling2Missing << 3;

    // Set if the CAN cooling 2 servo has an error bit set
    _pg_data[_pg_byteindex + 7] |= (uint8_t)canCooling2Error << 2;

    // If set a maintenance item has been triggered, see the maintenance packet for details.
    _pg_data[_pg_byteindex + 7] |= (uint8_t)maintenanceNeeded << 1;

    // If set the EFI is in test mode or is autocalibrating the throttle servo, refer to packet EFI_PKT_TESTMODE
    _pg_data[_pg_byteindex + 7] |= (uint8_t)testModeActive;
    _pg_byteindex += 8; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// efiErrors_t::encode

/*!
 * \brief Decode a efiErrors_t from a byte array
 *
 * Error information, output at the slow telemetry rate. There are two types of
 * error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`)
 * and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors
 * indicate the current error condition, and will automatically clear when the
 * error condition is resolved. Sticky errors are only cleared by sending
 * `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiErrors_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Set if input voltage is too low
    inputvoltagelow = (_pg_data[_pg_byteindex] >> 7);

    // Set if input voltage is too high
    inputvoltagehigh = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if manifold air temperature sensor is out of range low
    matsensorunderrng = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if manifold air temperature sensor is out of range high
    matsensoroverrng = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set if first cylinder head temperature sensor is out of range low
    cht1sensorunderrng = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set if first cylinder head temperature sensor is out of range high
    cht1sensoroverrng = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set if second cylinder head temperature sensor is out of range low
    cht2sensorunderrng = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set if second cylinder head temperature sensor is out of range high
    cht2sensoroverrng = ((_pg_data[_pg_byteindex]) & 0x1);

    // Set if manifold air pressure sensor is out of range low
    mapsensorunderrng = (_pg_data[_pg_byteindex + 1] >> 7);

    // Set if manifold air pressure sensor is out of range high
    mapsensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // Set if fuel pressure sensor is out of range low
    fuelpsensorunderrng = ((_pg_data[_pg_byteindex + 1] >> 5) & 0x1);

    // Set if fuel pressure sensor is out of range high
    fuelpsensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 4) & 0x1);

    // Set if analog TPS sensor is out of range low
    analogtpssensorunderrng = ((_pg_data[_pg_byteindex + 1] >> 3) & 0x1);

    // Set if analog TPS is out of range high
    analogtpssensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 2) & 0x1);

    // Set if CPU temperature is too low
    cputemplow = ((_pg_data[_pg_byteindex + 1] >> 1) & 0x1);

    // Set if CPU temperature is too high
    cputemphigh = ((_pg_data[_pg_byteindex + 1]) & 0x1);

    // Set if spare temperature sensor is out of range low
    sparetempsensorunderrng = (_pg_data[_pg_byteindex + 2] >> 7);

    // Set if spare temperature sensor is out of range high
    sparetempsensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 6) & 0x1);

    // Set if barometric air pressure sensor is out of range low
    barosensorunderrng = ((_pg_data[_pg_byteindex + 2] >> 5) & 0x1);

    // Set if barometric air pressure sensor is out of range high
    barosensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x1);

    // Enumerated errors from crank sense1, clear if no errors
    // Range of crank1error is 0 to 7.
    crank1error = ((_pg_data[_pg_byteindex + 2] >> 1) & 0x7);

    // Enumerated errors from crank sense2, clear if no errors
    // Range of crank2error is 0 to 7.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0x1);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 6);

    crank2error = _pg_tempbitfield;

    // Set if the first cylinder head temperature is too low, the head is overcooled
    cht1low = ((_pg_data[_pg_byteindex + 3] >> 5) & 0x1);

    // Set if the first cylinder head temperature is too high, the head is overheating
    cht1high = ((_pg_data[_pg_byteindex + 3] >> 4) & 0x1);

    // Set if the second cylinder head temperature is too low, the head is overcooled
    cht2low = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // Set if the second cylinder head temperature is too high, the head is overheating
    cht2high = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);

    // Set if the fuel pressure is too low
    fuelplow = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // Set if the fuel pressure is too high
    fuelphigh = ((_pg_data[_pg_byteindex + 3]) & 0x1);

    // Set if the engine RPM exceeded the hard rev limit
    hardoverspeed = (_pg_data[_pg_byteindex + 4] >> 7);

    // Set if the engine RPM exceeded the soft rev limit
    softoverspeed = ((_pg_data[_pg_byteindex + 4] >> 6) & 0x1);

    // Set if the nonvolatile parameters did not hash to the expected value
    parameterhash = ((_pg_data[_pg_byteindex + 4] >> 5) & 0x1);

    // Set if 12V voltage is too low
    voltage12low = ((_pg_data[_pg_byteindex + 4] >> 4) & 0x1);

    // Set if 12V voltage is too high
    voltage12high = ((_pg_data[_pg_byteindex + 4] >> 3) & 0x1);

    // Set if the input current is too low
    inputcurrentlow = ((_pg_data[_pg_byteindex + 4] >> 2) & 0x1);

    // Set if the input current is too high
    inputcurrenthigh = ((_pg_data[_pg_byteindex + 4] >> 1) & 0x1);

    // Set if the current of the 12 volt rail is too low
    current12low = ((_pg_data[_pg_byteindex + 4]) & 0x1);

    // Set if the current of the 12 volt rail too high
    current12high = (_pg_data[_pg_byteindex + 5] >> 7);

    // Set if the 6 volt power supply is faulted
    power6fault = ((_pg_data[_pg_byteindex + 5] >> 6) & 0x1);

    // Set if the first injector has a fault
    injector1fault = ((_pg_data[_pg_byteindex + 5] >> 5) & 0x1);

    // Set if the second injector has a fault
    injector2fault = ((_pg_data[_pg_byteindex + 5] >> 4) & 0x1);

    // Set if there is a user storage error
    userStorageError = ((_pg_data[_pg_byteindex + 5] >> 3) & 0x1);

    // Set if the analog barometric air pressure sensor is out of range low
    analogbarosensorunderrng = ((_pg_data[_pg_byteindex + 5] >> 2) & 0x1);

    // Set if the analog barometric air pressure sensor is out of range high
    analogbarosensoroverrng = ((_pg_data[_pg_byteindex + 5] >> 1) & 0x1);

    // Set if barometric air pressure sensor is out of range low
    oatsensorunderrng = ((_pg_data[_pg_byteindex + 5]) & 0x1);

    // Set if barometric air pressure sensor is out of range high
    oatsensoroverrng = (_pg_data[_pg_byteindex + 6] >> 7);

    // Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canThrottleMissing = ((_pg_data[_pg_byteindex + 6] >> 6) & 0x1);

    // Set if the CAN throttle servo has an error bit set
    canThrottleError = ((_pg_data[_pg_byteindex + 6] >> 5) & 0x1);

    // Set if the cooling output 1 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canCooling1Missing = ((_pg_data[_pg_byteindex + 6] >> 4) & 0x1);

    // Set if the CAN cooling 1 servo has an error bit set
    canCooling1Error = ((_pg_data[_pg_byteindex + 6] >> 3) & 0x1);

    // Set if throttle was greater than the maximum start throttle while the engine was cranking for start. In that case spark and injector outputs are suspended.
    maxstartthrottle = ((_pg_data[_pg_byteindex + 6] >> 2) & 0x1);

    // Set if manifold air pressure sensor is low compared to the estimate
    maplow = ((_pg_data[_pg_byteindex + 6] >> 1) & 0x1);

    // Set if manifold air pressure sensor is high compared to the estimate
    maphigh = ((_pg_data[_pg_byteindex + 6]) & 0x1);

    // Set if there is no throttle position source, but the system is configured for one.
    tpsmissing = (_pg_data[_pg_byteindex + 7] >> 7);

    // Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle).
    tpserror = ((_pg_data[_pg_byteindex + 7] >> 6) & 0x1);

    // Set if an error occurred with the SD card recording. This error will only assert after the SD card has been successfully detected.
    sdcarderror = ((_pg_data[_pg_byteindex + 7] >> 5) & 0x1);

    // Reserved for future expansion
    reserved1 = ((_pg_data[_pg_byteindex + 7] >> 4) & 0x1);

    // Set if the cooling output 2 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canCooling2Missing = ((_pg_data[_pg_byteindex + 7] >> 3) & 0x1);

    // Set if the CAN cooling 2 servo has an error bit set
    canCooling2Error = ((_pg_data[_pg_byteindex + 7] >> 2) & 0x1);

    // If set a maintenance item has been triggered, see the maintenance packet for details.
    maintenanceNeeded = ((_pg_data[_pg_byteindex + 7] >> 1) & 0x1);

    // If set the EFI is in test mode or is autocalibrating the throttle servo, refer to packet EFI_PKT_TESTMODE
    testModeActive = ((_pg_data[_pg_byteindex + 7]) & 0x1);
    _pg_byteindex += 8; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiErrors_t::decode

/*!
 * \brief Decode the efiErrorsapi4 packet
 *
 * Error information, output at the slow telemetry rate. There are two types of
 * error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`)
 * and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors
 * indicate the current error condition, and will automatically clear when the
 * error condition is resolved. Sticky errors are only cleared by sending
 * `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiErrorsapi4_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier, multiple options exist
    uint32_t _pg_packetid = geteficommsPacketID(_pg_pkt);
    if( _pg_packetid != EFI_PKT_STICKY_ERRORS &&
        _pg_packetid != EFI_PKT_TELEMETRYERRORS )
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Set if input voltage is too low
    inputvoltagelow = (_pg_data[_pg_byteindex] >> 7);

    // Set if input voltage is too high
    inputvoltagehigh = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if manifold air temperature sensor is out of range low
    matsensorunderrng = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if manifold air temperature sensor is out of range high
    matsensoroverrng = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set if first cylinder head temperature sensor is out of range low
    cht1sensorunderrng = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set if first cylinder head temperature sensor is out of range high
    cht1sensoroverrng = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set if second cylinder head temperature sensor is out of range low
    cht2sensorunderrng = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set if second cylinder head temperature sensor is out of range high
    cht2sensoroverrng = ((_pg_data[_pg_byteindex]) & 0x1);

    // Set if manifold air pressure sensor is out of range low
    mapsensorunderrng = (_pg_data[_pg_byteindex + 1] >> 7);

    // Set if manifold air pressure sensor is out of range high
    mapsensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // Set if fuel pressure sensor is out of range low
    fuelpsensorunderrng = ((_pg_data[_pg_byteindex + 1] >> 5) & 0x1);

    // Set if fuel pressure sensor is out of range high
    fuelpsensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 4) & 0x1);

    // Set if analog TPS sensor is out of range low
    analogtpssensorunderrng = ((_pg_data[_pg_byteindex + 1] >> 3) & 0x1);

    // Set if analog TPS is out of range high
    analogtpssensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 2) & 0x1);

    // Set if CPU temperature is too low
    cputemplow = ((_pg_data[_pg_byteindex + 1] >> 1) & 0x1);

    // Set if CPU temperature is too high
    cputemphigh = ((_pg_data[_pg_byteindex + 1]) & 0x1);

    // Set if spare temperature sensor is out of range low
    sparetempsensorunderrng = (_pg_data[_pg_byteindex + 2] >> 7);

    // Set if spare temperature sensor is out of range high
    sparetempsensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 6) & 0x1);

    // Set if barometric air pressure sensor is out of range low
    barosensorunderrng = ((_pg_data[_pg_byteindex + 2] >> 5) & 0x1);

    // Set if barometric air pressure sensor is out of range high
    barosensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x1);

    // Set if barometric air pressure sensor is out of range low
    oatsensorunderrng = ((_pg_data[_pg_byteindex + 2] >> 3) & 0x1);

    // Set if barometric air pressure sensor is out of range high
    oatsensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 2) & 0x1);

    // Set if the first crank sensor detected a signal bounce (crank sense event too fast)
    crank1bounce = ((_pg_data[_pg_byteindex + 2] >> 1) & 0x1);

    // Set if the second crank sensor detected a signal bounce (crank sense event too fast)
    crank2bounce = ((_pg_data[_pg_byteindex + 2]) & 0x1);

    // Set if the first crank sensor is late in firing relative to the second crank sensor.
    crank1late = (_pg_data[_pg_byteindex + 3] >> 7);

    // Set if the second crank sensor is late in firing relative to the first crank sensor.
    crank2late = ((_pg_data[_pg_byteindex + 3] >> 6) & 0x1);

    // Set if the first cylinder head temperature is too low, the head is overcooled
    cht1low = ((_pg_data[_pg_byteindex + 3] >> 5) & 0x1);

    // Set if the first cylinder head temperature is too high, the head is overheating
    cht1high = ((_pg_data[_pg_byteindex + 3] >> 4) & 0x1);

    // Set if the second cylinder head temperature is too low, the head is overcooled
    cht2low = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // Set if the second cylinder head temperature is too high, the head is overheating
    cht2high = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);

    // Set if the fuel pressure is too low
    fuelplow = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // Set if the fuel pressure is too high
    fuelphigh = ((_pg_data[_pg_byteindex + 3]) & 0x1);

    // Set if the engine RPM exceeded the hard rev limit
    hardoverspeed = (_pg_data[_pg_byteindex + 4] >> 7);

    // Set if the engine RPM exceeded the soft rev limit
    softoverspeed = ((_pg_data[_pg_byteindex + 4] >> 6) & 0x1);

    // Set if the nonvolatile parameters did not hash to the expected value
    parameterhash = ((_pg_data[_pg_byteindex + 4] >> 5) & 0x1);

    // Set if 12V voltage is too low
    voltage12low = ((_pg_data[_pg_byteindex + 4] >> 4) & 0x1);

    // Set if 12V voltage is too high
    voltage12high = ((_pg_data[_pg_byteindex + 4] >> 3) & 0x1);

    // Set if the input current is too low
    inputcurrentlow = ((_pg_data[_pg_byteindex + 4] >> 2) & 0x1);

    // Set if the input current is too high
    inputcurrenthigh = ((_pg_data[_pg_byteindex + 4] >> 1) & 0x1);

    // Set if the current of the 12 volt rail is too low
    current12low = ((_pg_data[_pg_byteindex + 4]) & 0x1);

    // Set if the current of the 12 volt rail too high
    current12high = (_pg_data[_pg_byteindex + 5] >> 7);

    // Set if the 6 volt power supply is faulted
    power6fault = ((_pg_data[_pg_byteindex + 5] >> 6) & 0x1);

    // Set if the first injector has a fault
    injector1fault = ((_pg_data[_pg_byteindex + 5] >> 5) & 0x1);

    // Set if the second injector has a fault
    injector2fault = ((_pg_data[_pg_byteindex + 5] >> 4) & 0x1);

    // Set if the analog barometric air pressure sensor is out of range low
    analogbarosensorunderrng = ((_pg_data[_pg_byteindex + 5] >> 2) & 0x1);

    // Set if the analog barometric air pressure sensor is out of range high
    analogbarosensoroverrng = ((_pg_data[_pg_byteindex + 5] >> 1) & 0x1);

    // Set if the first crank sensor missed an edge of the crank sense signal (i.e. two edges of the same type (rising or falling) in a row)
    crank1missededge = ((_pg_data[_pg_byteindex + 5]) & 0x1);

    // Set if the second crank sensor missed an edge of the crank sense signal (i.e. two edges of the same type (rising or falling) in a row)
    crank2missededge = (_pg_data[_pg_byteindex + 6] >> 7);

    // Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canThrottleMissing = ((_pg_data[_pg_byteindex + 6] >> 6) & 0x1);

    // Set if the CAN throttle servo has an error bit set
    canThrottleError = ((_pg_data[_pg_byteindex + 6] >> 5) & 0x1);

    // Set if the cooling output is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canCoolingMissing = ((_pg_data[_pg_byteindex + 6] >> 4) & 0x1);

    // Set if the CAN cooling servo has an error bit set
    canCoolingError = ((_pg_data[_pg_byteindex + 6] >> 3) & 0x1);

    // Set if manifold air pressure sensor is low compared to the estimate
    maplow = ((_pg_data[_pg_byteindex + 6] >> 1) & 0x1);

    // Set if manifold air pressure sensor is high compared to the estimate
    maphigh = ((_pg_data[_pg_byteindex + 6]) & 0x1);

    // Set if there is no throttle position source, but the system is configured for one.
    tpsmissing = (_pg_data[_pg_byteindex + 7] >> 7);

    // Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle).
    tpserror = ((_pg_data[_pg_byteindex + 7] >> 6) & 0x1);

    // If set a maintenance item has been triggered, see the maintenance packet for details.
    maintenanceNeeded = ((_pg_data[_pg_byteindex + 7] >> 1) & 0x1);

    // If set the EFI is in test mode, refer to packet EFI_PKT_TESTMODE
    testModeActive = ((_pg_data[_pg_byteindex + 7]) & 0x1);
    _pg_byteindex += 8; // close bit field

    return true;

}// efiErrorsapi4_t::decode

/*!
 * \brief Decode a efiErrorsapi4_t from a byte array
 *
 * Error information, output at the slow telemetry rate. There are two types of
 * error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`)
 * and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors
 * indicate the current error condition, and will automatically clear when the
 * error condition is resolved. Sticky errors are only cleared by sending
 * `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiErrorsapi4_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // Set if input voltage is too low
    inputvoltagelow = (_pg_data[_pg_byteindex] >> 7);

    // Set if input voltage is too high
    inputvoltagehigh = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if manifold air temperature sensor is out of range low
    matsensorunderrng = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if manifold air temperature sensor is out of range high
    matsensoroverrng = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set if first cylinder head temperature sensor is out of range low
    cht1sensorunderrng = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set if first cylinder head temperature sensor is out of range high
    cht1sensoroverrng = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set if second cylinder head temperature sensor is out of range low
    cht2sensorunderrng = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set if second cylinder head temperature sensor is out of range high
    cht2sensoroverrng = ((_pg_data[_pg_byteindex]) & 0x1);

    // Set if manifold air pressure sensor is out of range low
    mapsensorunderrng = (_pg_data[_pg_byteindex + 1] >> 7);

    // Set if manifold air pressure sensor is out of range high
    mapsensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // Set if fuel pressure sensor is out of range low
    fuelpsensorunderrng = ((_pg_data[_pg_byteindex + 1] >> 5) & 0x1);

    // Set if fuel pressure sensor is out of range high
    fuelpsensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 4) & 0x1);

    // Set if analog TPS sensor is out of range low
    analogtpssensorunderrng = ((_pg_data[_pg_byteindex + 1] >> 3) & 0x1);

    // Set if analog TPS is out of range high
    analogtpssensoroverrng = ((_pg_data[_pg_byteindex + 1] >> 2) & 0x1);

    // Set if CPU temperature is too low
    cputemplow = ((_pg_data[_pg_byteindex + 1] >> 1) & 0x1);

    // Set if CPU temperature is too high
    cputemphigh = ((_pg_data[_pg_byteindex + 1]) & 0x1);

    // Set if spare temperature sensor is out of range low
    sparetempsensorunderrng = (_pg_data[_pg_byteindex + 2] >> 7);

    // Set if spare temperature sensor is out of range high
    sparetempsensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 6) & 0x1);

    // Set if barometric air pressure sensor is out of range low
    barosensorunderrng = ((_pg_data[_pg_byteindex + 2] >> 5) & 0x1);

    // Set if barometric air pressure sensor is out of range high
    barosensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x1);

    // Set if barometric air pressure sensor is out of range low
    oatsensorunderrng = ((_pg_data[_pg_byteindex + 2] >> 3) & 0x1);

    // Set if barometric air pressure sensor is out of range high
    oatsensoroverrng = ((_pg_data[_pg_byteindex + 2] >> 2) & 0x1);

    // Set if the first crank sensor detected a signal bounce (crank sense event too fast)
    crank1bounce = ((_pg_data[_pg_byteindex + 2] >> 1) & 0x1);

    // Set if the second crank sensor detected a signal bounce (crank sense event too fast)
    crank2bounce = ((_pg_data[_pg_byteindex + 2]) & 0x1);

    // Set if the first crank sensor is late in firing relative to the second crank sensor.
    crank1late = (_pg_data[_pg_byteindex + 3] >> 7);

    // Set if the second crank sensor is late in firing relative to the first crank sensor.
    crank2late = ((_pg_data[_pg_byteindex + 3] >> 6) & 0x1);

    // Set if the first cylinder head temperature is too low, the head is overcooled
    cht1low = ((_pg_data[_pg_byteindex + 3] >> 5) & 0x1);

    // Set if the first cylinder head temperature is too high, the head is overheating
    cht1high = ((_pg_data[_pg_byteindex + 3] >> 4) & 0x1);

    // Set if the second cylinder head temperature is too low, the head is overcooled
    cht2low = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // Set if the second cylinder head temperature is too high, the head is overheating
    cht2high = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);

    // Set if the fuel pressure is too low
    fuelplow = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // Set if the fuel pressure is too high
    fuelphigh = ((_pg_data[_pg_byteindex + 3]) & 0x1);

    // Set if the engine RPM exceeded the hard rev limit
    hardoverspeed = (_pg_data[_pg_byteindex + 4] >> 7);

    // Set if the engine RPM exceeded the soft rev limit
    softoverspeed = ((_pg_data[_pg_byteindex + 4] >> 6) & 0x1);

    // Set if the nonvolatile parameters did not hash to the expected value
    parameterhash = ((_pg_data[_pg_byteindex + 4] >> 5) & 0x1);

    // Set if 12V voltage is too low
    voltage12low = ((_pg_data[_pg_byteindex + 4] >> 4) & 0x1);

    // Set if 12V voltage is too high
    voltage12high = ((_pg_data[_pg_byteindex + 4] >> 3) & 0x1);

    // Set if the input current is too low
    inputcurrentlow = ((_pg_data[_pg_byteindex + 4] >> 2) & 0x1);

    // Set if the input current is too high
    inputcurrenthigh = ((_pg_data[_pg_byteindex + 4] >> 1) & 0x1);

    // Set if the current of the 12 volt rail is too low
    current12low = ((_pg_data[_pg_byteindex + 4]) & 0x1);

    // Set if the current of the 12 volt rail too high
    current12high = (_pg_data[_pg_byteindex + 5] >> 7);

    // Set if the 6 volt power supply is faulted
    power6fault = ((_pg_data[_pg_byteindex + 5] >> 6) & 0x1);

    // Set if the first injector has a fault
    injector1fault = ((_pg_data[_pg_byteindex + 5] >> 5) & 0x1);

    // Set if the second injector has a fault
    injector2fault = ((_pg_data[_pg_byteindex + 5] >> 4) & 0x1);

    // Set if the analog barometric air pressure sensor is out of range low
    analogbarosensorunderrng = ((_pg_data[_pg_byteindex + 5] >> 2) & 0x1);

    // Set if the analog barometric air pressure sensor is out of range high
    analogbarosensoroverrng = ((_pg_data[_pg_byteindex + 5] >> 1) & 0x1);

    // Set if the first crank sensor missed an edge of the crank sense signal (i.e. two edges of the same type (rising or falling) in a row)
    crank1missededge = ((_pg_data[_pg_byteindex + 5]) & 0x1);

    // Set if the second crank sensor missed an edge of the crank sense signal (i.e. two edges of the same type (rising or falling) in a row)
    crank2missededge = (_pg_data[_pg_byteindex + 6] >> 7);

    // Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canThrottleMissing = ((_pg_data[_pg_byteindex + 6] >> 6) & 0x1);

    // Set if the CAN throttle servo has an error bit set
    canThrottleError = ((_pg_data[_pg_byteindex + 6] >> 5) & 0x1);

    // Set if the cooling output is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    canCoolingMissing = ((_pg_data[_pg_byteindex + 6] >> 4) & 0x1);

    // Set if the CAN cooling servo has an error bit set
    canCoolingError = ((_pg_data[_pg_byteindex + 6] >> 3) & 0x1);

    // Set if manifold air pressure sensor is low compared to the estimate
    maplow = ((_pg_data[_pg_byteindex + 6] >> 1) & 0x1);

    // Set if manifold air pressure sensor is high compared to the estimate
    maphigh = ((_pg_data[_pg_byteindex + 6]) & 0x1);

    // Set if there is no throttle position source, but the system is configured for one.
    tpsmissing = (_pg_data[_pg_byteindex + 7] >> 7);

    // Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle).
    tpserror = ((_pg_data[_pg_byteindex + 7] >> 6) & 0x1);

    // If set a maintenance item has been triggered, see the maintenance packet for details.
    maintenanceNeeded = ((_pg_data[_pg_byteindex + 7] >> 1) & 0x1);

    // If set the EFI is in test mode, refer to packet EFI_PKT_TESTMODE
    testModeActive = ((_pg_data[_pg_byteindex + 7]) & 0x1);
    _pg_byteindex += 8; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiErrorsapi4_t::decode

/*!
 * \brief Create the efiEngineWear packet
 *
 * Information about engine wear, output at the slow telemetry rate.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiEngineWear_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Total engine run time in seconds
    // Range of hobbs is 0 to -2147483648.
    uint32ToBeBytes(hobbs, _pg_data, &_pg_byteindex);

    // Total number of revolutions the engine has made
    // Range of revcount is 0 to -2147483648.
    uint32ToBeBytes(revcount, _pg_data, &_pg_byteindex);

    // Seconds the engine has spent running above the CHT limit
    // Range of hotTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)hotTime, 0.0f, 0.1f, 20);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;


    // Seconds the engine has spent running at high load (throttle greater than 80%).
    // Range of highLoadTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)highLoadTime, 0.0f, 0.1f, 20);
    _pg_data[_pg_byteindex + 4] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 5; // close bit field


    // Highest head temperature observed while the engine was running
    // Range of peakCHT is 0.0 to 510.0.
    float32ScaledTo1UnsignedBytes(peakCHT, _pg_data, &_pg_byteindex, 0.0f, 0.5f);

    _pg_data[_pg_byteindex] = 0;

    // Number of times the engine has started
    // Range of numStarts is 0 to 4095.
    _pg_tempbitfield = (unsigned int)limitMax(numStarts, 4095);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiEngineWear_t::encode

/*!
 * \brief Decode the efiEngineWear packet
 *
 * Information about engine wear, output at the slow telemetry rate.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiEngineWear_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Total engine run time in seconds
    // Range of hobbs is 0 to -2147483648.
    hobbs = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Total number of revolutions the engine has made
    // Range of revcount is 0 to -2147483648.
    revcount = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Seconds the engine has spent running above the CHT limit
    // Range of hotTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    hotTime = (uint32_t)float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/0.1f);

    // Seconds the engine has spent running at high load (throttle greater than 80%).
    // Range of highLoadTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 4];

    highLoadTime = (uint32_t)float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/0.1f);
    _pg_byteindex += 5; // close bit field

    // Highest head temperature observed while the engine was running
    // Range of peakCHT is 0.0 to 510.0.
    peakCHT = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.5f);

    // Number of times the engine has started
    // Range of numStarts is 0 to 4095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    numStarts = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    return true;

}// efiEngineWear_t::decode

/*!
 * \brief Encode a efiEngineWear_t into a byte array
 *
 * Information about engine wear, output at the slow telemetry rate.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiEngineWear_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Total engine run time in seconds
    // Range of hobbs is 0 to -2147483648.
    uint32ToBeBytes(hobbs, _pg_data, &_pg_byteindex);

    // Total number of revolutions the engine has made
    // Range of revcount is 0 to -2147483648.
    uint32ToBeBytes(revcount, _pg_data, &_pg_byteindex);

    // Seconds the engine has spent running above the CHT limit
    // Range of hotTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)hotTime, 0.0f, 0.1f, 20);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // Seconds the engine has spent running at high load (throttle greater than 80%).
    // Range of highLoadTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)highLoadTime, 0.0f, 0.1f, 20);
    _pg_data[_pg_byteindex + 4] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 5; // close bit field

    // Highest head temperature observed while the engine was running
    // Range of peakCHT is 0.0 to 510.0.
    float32ScaledTo1UnsignedBytes(peakCHT, _pg_data, &_pg_byteindex, 0.0f, 0.5f);

    _pg_data[_pg_byteindex] = 0;

    // Number of times the engine has started
    // Range of numStarts is 0 to 4095.
    _pg_tempbitfield = (unsigned int)limitMax(numStarts, 4095);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// efiEngineWear_t::encode

/*!
 * \brief Decode a efiEngineWear_t from a byte array
 *
 * Information about engine wear, output at the slow telemetry rate.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiEngineWear_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Total engine run time in seconds
    // Range of hobbs is 0 to -2147483648.
    hobbs = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Total number of revolutions the engine has made
    // Range of revcount is 0 to -2147483648.
    revcount = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Seconds the engine has spent running above the CHT limit
    // Range of hotTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    hotTime = (uint32_t)float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/0.1f);

    // Seconds the engine has spent running at high load (throttle greater than 80%).
    // Range of highLoadTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 4];

    highLoadTime = (uint32_t)float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/0.1f);
    _pg_byteindex += 5; // close bit field

    // Highest head temperature observed while the engine was running
    // Range of peakCHT is 0.0 to 510.0.
    peakCHT = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.5f);

    // Number of times the engine has started
    // Range of numStarts is 0 to 4095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    numStarts = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiEngineWear_t::decode

/*!
 * \brief Create the efiEngineWearShort packet
 *
 * Short information about engine wear, output at the slow telemetry rate over
 * the CAN bus.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param hobbs is Total engine run time in seconds
 * \param revcount is Total number of revolutions the engine has made
 */
void efiEngineWearShort_t::encode(efiPacket_t* _pg_pkt, uint32_t hobbs, uint32_t revcount)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Total engine run time in seconds
    // Range of hobbs is 0 to -2147483648.
    uint32ToBeBytes(hobbs, _pg_data, &_pg_byteindex);

    // Total number of revolutions the engine has made
    // Range of revcount is 0 to -2147483648.
    uint32ToBeBytes(revcount, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiEngineWearShort_t::encode

/*!
 * \brief Decode the efiEngineWearShort packet
 *
 * Short information about engine wear, output at the slow telemetry rate over
 * the CAN bus.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param hobbs receives Total engine run time in seconds
 * \param revcount receives Total number of revolutions the engine has made
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiEngineWearShort_t::decode(const efiPacket_t* _pg_pkt, uint32_t* hobbs, uint32_t* revcount)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Total engine run time in seconds
    // Range of hobbs is 0 to -2147483648.
    (*hobbs) = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Total number of revolutions the engine has made
    // Range of revcount is 0 to -2147483648.
    (*revcount) = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// efiEngineWearShort_t::decode

/*!
 * \brief Encode a efiEngineWearShort_t into a byte array
 *
 * Short information about engine wear, output at the slow telemetry rate over
 * the CAN bus.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiEngineWearShort_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    // Total engine run time in seconds
    // Range of hobbs is 0 to -2147483648.
    uint32ToBeBytes(hobbs, _pg_data, &_pg_byteindex);

    // Total number of revolutions the engine has made
    // Range of revcount is 0 to -2147483648.
    uint32ToBeBytes(revcount, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efiEngineWearShort_t::encode

/*!
 * \brief Decode a efiEngineWearShort_t from a byte array
 *
 * Short information about engine wear, output at the slow telemetry rate over
 * the CAN bus.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiEngineWearShort_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // Total engine run time in seconds
    // Range of hobbs is 0 to -2147483648.
    hobbs = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Total number of revolutions the engine has made
    // Range of revcount is 0 to -2147483648.
    revcount = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiEngineWearShort_t::decode


/*!
 * \brief Lookup title for 'efiCANerr' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string title of the given entry (comment if no title given)
 */
const char* efiCANerr_EnumTitle(int value)
{
    switch (value)
    {
    default:
        return "";
    case EFI_CANERR_NONE:
        return translateeficomms("No error");
    case EFI_CANERR_STUFF:
        return translateeficomms("Stuff");
    case EFI_CANERR_FORM:
        return translateeficomms("Form");
    case EFI_CANERR_ACK:
        return translateeficomms("Acknowledgement");
    case EFI_CANERR_BITREC:
        return translateeficomms("Bit recessive");
    case EFI_CANERR_BITDOM:
        return translateeficomms("Bit dominant");
    case EFI_CANERR_CRC:
        return translateeficomms("CRC");
    case EFI_CANERR_SOFT:
        return translateeficomms("Software");
    }
}

/*!
 * \brief Create the efiTelemetryComms packet
 *
 * Information about communications performance and configuration, output at
 * the slow telemetry rate.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryComms_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // The receive error counter from the CAN bus hardware
    // Range of canREC is 0 to 255.
    uint8ToBytes(canREC, _pg_data, &_pg_byteindex);

    // The least significant 8 bits of the transmit error counter from the CAN bus hardware
    // Range of canTEC is 0 to 255.
    uint8ToBytes(canTEC, _pg_data, &_pg_byteindex);

    // Cause of the last CAN error
    _pg_data[_pg_byteindex] = (uint8_t)lastCANerr << 5;

    // This bit is set when the CAN hardware enters the bus-off state. The bus-off state is entered on canTEC overflow, greater than 255
    _pg_data[_pg_byteindex] |= (uint8_t)canBOF << 4;

    // This bit is set when the CAN error passive limit has been reached (canREC or canTEC greater than 127).
    _pg_data[_pg_byteindex] |= (uint8_t)canEPVF << 3;

    // This bit is set when the CAN warning limit has been reached (canREC or canTEC greater than 95).
    _pg_data[_pg_byteindex] |= (uint8_t)canEWGF << 2;

    // This bit echos the CAN configuration bit `disableNativeInput`. If set then native CAN packets cannot be sent to this EFI (except possibly using the broadcast ID).
    _pg_data[_pg_byteindex] |= (uint8_t)canDisableNativeInput << 1;


    // This bit echos the CAN configuration bit `disableNativeOutput`. If set then native CAN packets will not be sent by this EFI.
    _pg_data[_pg_byteindex + 1] = (uint8_t)canDisableNativeOutput << 7;

    // This bit echos the CAN configuration bit `disableNativeBroadcast`. If set then native CAN packets cannot be sent to this EFI using the broadcast ID.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)canDisableNativeBroadcast << 6;

    // This bit echos the CAN configuration bit `forcePacketOverCAN`. If set any CAN packets sent to this EFI must use the packet-over-CAN schema, otherwise they will be ignored.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)canForcePacketOverCAN << 5;

    // This bit echos the CAN configuration bit `cmdAndTmOnly`. If set then only commands and telemetry are supported on the CAN bus (configuration request or change will be ignored).
    _pg_data[_pg_byteindex + 1] |= (uint8_t)canCmdAndTmOnly << 4;

    // Set if the transmit buffer of the CAN interface is full.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)canTxFull << 3;

    // Number of packets received over the CAN bus which were invalid (bad CRC) since the last time this packet was output
    // Range of canPacketFailureCnt is 0 to 7.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)limitMax(canPacketFailureCnt, 7);

    // Set if the transmit buffer of the UART interface is full.
    _pg_data[_pg_byteindex + 2] = (uint8_t)uartTxFull << 7;

    // Number of packets received over the UART which were invalid (bad CRC) since the last time this packet was output
    // Range of uartPacketFailureCnt is 0 to 7.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(uartPacketFailureCnt, 7) << 4;

    // Set if the transmit buffer of the USB interface is full.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)usbTxFull << 3;

    // Number of packets received over the USB which were invalid (bad CRC) since the last time this packet was output
    // Range of usbPacketFailureCnt is 0 to 7.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(usbPacketFailureCnt, 7);
    _pg_byteindex += 3; // close bit field


    // Free running counter of packets transmitted over CAN (not counting this packet).
    // Range of txCANPacketCounter is 0 to 255.
    uint8ToBytes(txCANPacketCounter, _pg_data, &_pg_byteindex);

    // Free running counter of packets transmitted over the UART or USB (not counting this packet).
    // Range of txPacketCounter is 0 to 255.
    uint8ToBytes(txPacketCounter, _pg_data, &_pg_byteindex);

    // Free running counter for received packets (from any source).
    // Range of rxPacketCounter is 0 to 255.
    uint8ToBytes(rxPacketCounter, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryComms_t::encode

/*!
 * \brief Decode the efiTelemetryComms packet
 *
 * Information about communications performance and configuration, output at
 * the slow telemetry rate.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryComms_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // The receive error counter from the CAN bus hardware
    // Range of canREC is 0 to 255.
    canREC = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The least significant 8 bits of the transmit error counter from the CAN bus hardware
    // Range of canTEC is 0 to 255.
    canTEC = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Cause of the last CAN error
    lastCANerr = (efiCANerr)(_pg_data[_pg_byteindex] >> 5);

    // This bit is set when the CAN hardware enters the bus-off state. The bus-off state is entered on canTEC overflow, greater than 255
    canBOF = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // This bit is set when the CAN error passive limit has been reached (canREC or canTEC greater than 127).
    canEPVF = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // This bit is set when the CAN warning limit has been reached (canREC or canTEC greater than 95).
    canEWGF = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // This bit echos the CAN configuration bit `disableNativeInput`. If set then native CAN packets cannot be sent to this EFI (except possibly using the broadcast ID).
    canDisableNativeInput = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // This bit echos the CAN configuration bit `disableNativeOutput`. If set then native CAN packets will not be sent by this EFI.
    canDisableNativeOutput = (_pg_data[_pg_byteindex + 1] >> 7);

    // This bit echos the CAN configuration bit `disableNativeBroadcast`. If set then native CAN packets cannot be sent to this EFI using the broadcast ID.
    canDisableNativeBroadcast = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // This bit echos the CAN configuration bit `forcePacketOverCAN`. If set any CAN packets sent to this EFI must use the packet-over-CAN schema, otherwise they will be ignored.
    canForcePacketOverCAN = ((_pg_data[_pg_byteindex + 1] >> 5) & 0x1);

    // This bit echos the CAN configuration bit `cmdAndTmOnly`. If set then only commands and telemetry are supported on the CAN bus (configuration request or change will be ignored).
    canCmdAndTmOnly = ((_pg_data[_pg_byteindex + 1] >> 4) & 0x1);

    // Set if the transmit buffer of the CAN interface is full.
    canTxFull = ((_pg_data[_pg_byteindex + 1] >> 3) & 0x1);

    // Number of packets received over the CAN bus which were invalid (bad CRC) since the last time this packet was output
    // Range of canPacketFailureCnt is 0 to 7.
    canPacketFailureCnt = ((_pg_data[_pg_byteindex + 1]) & 0x7);

    // Set if the transmit buffer of the UART interface is full.
    uartTxFull = (_pg_data[_pg_byteindex + 2] >> 7);

    // Number of packets received over the UART which were invalid (bad CRC) since the last time this packet was output
    // Range of uartPacketFailureCnt is 0 to 7.
    uartPacketFailureCnt = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x7);

    // Set if the transmit buffer of the USB interface is full.
    usbTxFull = ((_pg_data[_pg_byteindex + 2] >> 3) & 0x1);

    // Number of packets received over the USB which were invalid (bad CRC) since the last time this packet was output
    // Range of usbPacketFailureCnt is 0 to 7.
    usbPacketFailureCnt = ((_pg_data[_pg_byteindex + 2]) & 0x7);
    _pg_byteindex += 3; // close bit field

    // Free running counter of packets transmitted over CAN (not counting this packet).
    // Range of txCANPacketCounter is 0 to 255.
    txCANPacketCounter = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Free running counter of packets transmitted over the UART or USB (not counting this packet).
    // Range of txPacketCounter is 0 to 255.
    txPacketCounter = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Free running counter for received packets (from any source).
    // Range of rxPacketCounter is 0 to 255.
    rxPacketCounter = uint8FromBytes(_pg_data, &_pg_byteindex);

    return true;

}// efiTelemetryComms_t::decode

/*!
 * \brief Encode a efiTelemetryComms_t into a byte array
 *
 * Information about communications performance and configuration, output at
 * the slow telemetry rate.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetryComms_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    // The receive error counter from the CAN bus hardware
    // Range of canREC is 0 to 255.
    uint8ToBytes(canREC, _pg_data, &_pg_byteindex);

    // The least significant 8 bits of the transmit error counter from the CAN bus hardware
    // Range of canTEC is 0 to 255.
    uint8ToBytes(canTEC, _pg_data, &_pg_byteindex);

    // Cause of the last CAN error
    _pg_data[_pg_byteindex] = (uint8_t)lastCANerr << 5;

    // This bit is set when the CAN hardware enters the bus-off state. The bus-off state is entered on canTEC overflow, greater than 255
    _pg_data[_pg_byteindex] |= (uint8_t)canBOF << 4;

    // This bit is set when the CAN error passive limit has been reached (canREC or canTEC greater than 127).
    _pg_data[_pg_byteindex] |= (uint8_t)canEPVF << 3;

    // This bit is set when the CAN warning limit has been reached (canREC or canTEC greater than 95).
    _pg_data[_pg_byteindex] |= (uint8_t)canEWGF << 2;

    // This bit echos the CAN configuration bit `disableNativeInput`. If set then native CAN packets cannot be sent to this EFI (except possibly using the broadcast ID).
    _pg_data[_pg_byteindex] |= (uint8_t)canDisableNativeInput << 1;

    // This bit echos the CAN configuration bit `disableNativeOutput`. If set then native CAN packets will not be sent by this EFI.
    _pg_data[_pg_byteindex + 1] = (uint8_t)canDisableNativeOutput << 7;

    // This bit echos the CAN configuration bit `disableNativeBroadcast`. If set then native CAN packets cannot be sent to this EFI using the broadcast ID.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)canDisableNativeBroadcast << 6;

    // This bit echos the CAN configuration bit `forcePacketOverCAN`. If set any CAN packets sent to this EFI must use the packet-over-CAN schema, otherwise they will be ignored.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)canForcePacketOverCAN << 5;

    // This bit echos the CAN configuration bit `cmdAndTmOnly`. If set then only commands and telemetry are supported on the CAN bus (configuration request or change will be ignored).
    _pg_data[_pg_byteindex + 1] |= (uint8_t)canCmdAndTmOnly << 4;

    // Set if the transmit buffer of the CAN interface is full.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)canTxFull << 3;

    // Number of packets received over the CAN bus which were invalid (bad CRC) since the last time this packet was output
    // Range of canPacketFailureCnt is 0 to 7.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)limitMax(canPacketFailureCnt, 7);

    // Set if the transmit buffer of the UART interface is full.
    _pg_data[_pg_byteindex + 2] = (uint8_t)uartTxFull << 7;

    // Number of packets received over the UART which were invalid (bad CRC) since the last time this packet was output
    // Range of uartPacketFailureCnt is 0 to 7.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(uartPacketFailureCnt, 7) << 4;

    // Set if the transmit buffer of the USB interface is full.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)usbTxFull << 3;

    // Number of packets received over the USB which were invalid (bad CRC) since the last time this packet was output
    // Range of usbPacketFailureCnt is 0 to 7.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(usbPacketFailureCnt, 7);
    _pg_byteindex += 3; // close bit field

    // Free running counter of packets transmitted over CAN (not counting this packet).
    // Range of txCANPacketCounter is 0 to 255.
    uint8ToBytes(txCANPacketCounter, _pg_data, &_pg_byteindex);

    // Free running counter of packets transmitted over the UART or USB (not counting this packet).
    // Range of txPacketCounter is 0 to 255.
    uint8ToBytes(txPacketCounter, _pg_data, &_pg_byteindex);

    // Free running counter for received packets (from any source).
    // Range of rxPacketCounter is 0 to 255.
    uint8ToBytes(rxPacketCounter, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetryComms_t::encode

/*!
 * \brief Decode a efiTelemetryComms_t from a byte array
 *
 * Information about communications performance and configuration, output at
 * the slow telemetry rate.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetryComms_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // The receive error counter from the CAN bus hardware
    // Range of canREC is 0 to 255.
    canREC = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The least significant 8 bits of the transmit error counter from the CAN bus hardware
    // Range of canTEC is 0 to 255.
    canTEC = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Cause of the last CAN error
    lastCANerr = (efiCANerr)(_pg_data[_pg_byteindex] >> 5);

    // This bit is set when the CAN hardware enters the bus-off state. The bus-off state is entered on canTEC overflow, greater than 255
    canBOF = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // This bit is set when the CAN error passive limit has been reached (canREC or canTEC greater than 127).
    canEPVF = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // This bit is set when the CAN warning limit has been reached (canREC or canTEC greater than 95).
    canEWGF = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // This bit echos the CAN configuration bit `disableNativeInput`. If set then native CAN packets cannot be sent to this EFI (except possibly using the broadcast ID).
    canDisableNativeInput = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // This bit echos the CAN configuration bit `disableNativeOutput`. If set then native CAN packets will not be sent by this EFI.
    canDisableNativeOutput = (_pg_data[_pg_byteindex + 1] >> 7);

    // This bit echos the CAN configuration bit `disableNativeBroadcast`. If set then native CAN packets cannot be sent to this EFI using the broadcast ID.
    canDisableNativeBroadcast = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // This bit echos the CAN configuration bit `forcePacketOverCAN`. If set any CAN packets sent to this EFI must use the packet-over-CAN schema, otherwise they will be ignored.
    canForcePacketOverCAN = ((_pg_data[_pg_byteindex + 1] >> 5) & 0x1);

    // This bit echos the CAN configuration bit `cmdAndTmOnly`. If set then only commands and telemetry are supported on the CAN bus (configuration request or change will be ignored).
    canCmdAndTmOnly = ((_pg_data[_pg_byteindex + 1] >> 4) & 0x1);

    // Set if the transmit buffer of the CAN interface is full.
    canTxFull = ((_pg_data[_pg_byteindex + 1] >> 3) & 0x1);

    // Number of packets received over the CAN bus which were invalid (bad CRC) since the last time this packet was output
    // Range of canPacketFailureCnt is 0 to 7.
    canPacketFailureCnt = ((_pg_data[_pg_byteindex + 1]) & 0x7);

    // Set if the transmit buffer of the UART interface is full.
    uartTxFull = (_pg_data[_pg_byteindex + 2] >> 7);

    // Number of packets received over the UART which were invalid (bad CRC) since the last time this packet was output
    // Range of uartPacketFailureCnt is 0 to 7.
    uartPacketFailureCnt = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x7);

    // Set if the transmit buffer of the USB interface is full.
    usbTxFull = ((_pg_data[_pg_byteindex + 2] >> 3) & 0x1);

    // Number of packets received over the USB which were invalid (bad CRC) since the last time this packet was output
    // Range of usbPacketFailureCnt is 0 to 7.
    usbPacketFailureCnt = ((_pg_data[_pg_byteindex + 2]) & 0x7);
    _pg_byteindex += 3; // close bit field

    // Free running counter of packets transmitted over CAN (not counting this packet).
    // Range of txCANPacketCounter is 0 to 255.
    txCANPacketCounter = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Free running counter of packets transmitted over the UART or USB (not counting this packet).
    // Range of txPacketCounter is 0 to 255.
    txPacketCounter = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Free running counter for received packets (from any source).
    // Range of rxPacketCounter is 0 to 255.
    rxPacketCounter = uint8FromBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetryComms_t::decode

/*!
 * \brief Create the efiTelemetrySDCard packet
 *
 * Telemetry about the SD card. This packet is only sent if the SD card is
 * present. Presence of the SD card is always visible in the [CPU
 * telemetry](#EFI_PKT_TELEMETRYCPU) packet.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetrySDCard_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Status of the SD card
    _pg_data[_pg_byteindex] = (uint8_t)sdstatus << 5;

    // The number of SD card errors experienced since bootup.
    // Range of errorCount is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(errorCount, 31);
    _pg_byteindex += 1; // close bit field


    // If `sdstatus` is `EFI_SD_READY` this is the number of 512-byte blocks that have been written to the card since the system booted up. If `sdstatus` is `EFI_SD_SETTINGUP` this gives the progress of the directory setup in tenths of a percent. If `sdstatus` is `EFI_SD_TRANSFER` this gives the progress of the transfer in tenths of a percent. In all other states this value is zero.
    // Range of sequence is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(sequence, 16777215)), _pg_data, &_pg_byteindex);

    // The total number of data blocks that have been written to the card, this does not include the journal blocks.
    // Range of numDataBlocks is 0 to -2147483648.
    uint32ToBeBytes(numDataBlocks, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetrySDCard_t::encode

/*!
 * \brief Decode the efiTelemetrySDCard packet
 *
 * Telemetry about the SD card. This packet is only sent if the SD card is
 * present. Presence of the SD card is always visible in the [CPU
 * telemetry](#EFI_PKT_TELEMETRYCPU) packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySDCard_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Status of the SD card
    sdstatus = (efiSDStatus)(_pg_data[_pg_byteindex] >> 5);

    // The number of SD card errors experienced since bootup.
    // Range of errorCount is 0 to 31.
    errorCount = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    // If `sdstatus` is `EFI_SD_READY` this is the number of 512-byte blocks that have been written to the card since the system booted up. If `sdstatus` is `EFI_SD_SETTINGUP` this gives the progress of the directory setup in tenths of a percent. If `sdstatus` is `EFI_SD_TRANSFER` this gives the progress of the transfer in tenths of a percent. In all other states this value is zero.
    // Range of sequence is 0 to 16777215.
    sequence = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // The total number of data blocks that have been written to the card, this does not include the journal blocks.
    // Range of numDataBlocks is 0 to -2147483648.
    numDataBlocks = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return true;

}// efiTelemetrySDCard_t::decode

/*!
 * \brief Encode a efiTelemetrySDCard_t into a byte array
 *
 * Telemetry about the SD card. This packet is only sent if the SD card is
 * present. Presence of the SD card is always visible in the [CPU
 * telemetry](#EFI_PKT_TELEMETRYCPU) packet.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiTelemetrySDCard_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    // Status of the SD card
    _pg_data[_pg_byteindex] = (uint8_t)sdstatus << 5;

    // The number of SD card errors experienced since bootup.
    // Range of errorCount is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(errorCount, 31);
    _pg_byteindex += 1; // close bit field

    // If `sdstatus` is `EFI_SD_READY` this is the number of 512-byte blocks that have been written to the card since the system booted up. If `sdstatus` is `EFI_SD_SETTINGUP` this gives the progress of the directory setup in tenths of a percent. If `sdstatus` is `EFI_SD_TRANSFER` this gives the progress of the transfer in tenths of a percent. In all other states this value is zero.
    // Range of sequence is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(sequence, 16777215)), _pg_data, &_pg_byteindex);

    // The total number of data blocks that have been written to the card, this does not include the journal blocks.
    // Range of numDataBlocks is 0 to -2147483648.
    uint32ToBeBytes(numDataBlocks, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efiTelemetrySDCard_t::encode

/*!
 * \brief Decode a efiTelemetrySDCard_t from a byte array
 *
 * Telemetry about the SD card. This packet is only sent if the SD card is
 * present. Presence of the SD card is always visible in the [CPU
 * telemetry](#EFI_PKT_TELEMETRYCPU) packet.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiTelemetrySDCard_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // Status of the SD card
    sdstatus = (efiSDStatus)(_pg_data[_pg_byteindex] >> 5);

    // The number of SD card errors experienced since bootup.
    // Range of errorCount is 0 to 31.
    errorCount = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    // If `sdstatus` is `EFI_SD_READY` this is the number of 512-byte blocks that have been written to the card since the system booted up. If `sdstatus` is `EFI_SD_SETTINGUP` this gives the progress of the directory setup in tenths of a percent. If `sdstatus` is `EFI_SD_TRANSFER` this gives the progress of the transfer in tenths of a percent. In all other states this value is zero.
    // Range of sequence is 0 to 16777215.
    sequence = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // The total number of data blocks that have been written to the card, this does not include the journal blocks.
    // Range of numDataBlocks is 0 to -2147483648.
    numDataBlocks = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiTelemetrySDCard_t::decode

/*!
 * \brief Create the efiEnable packet
 *
 * Enable/disable command. Use this packet to shut down the engine by clearing
 * `userEnable` or to selectively disable the first or second spark output by
 * clearing `spark1Enable` or `spark2Enable`. The EFI will boot up with all the
 * enables set. The current enable status is visible in the [fast
 * telemetry](#EFI_PKT_TELEMETRYFAST) packet.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiEnable_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Global enable based on physical input. This enable cannot be changed by this packet.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(ioEnable, 1) << 7;

    // User global enable. Set to zero to disable the engine.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(userEnable, 1) << 6;

    // User enable for spark1. Set to zero to disable spark 1.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark1Enable, 1) << 5;

    // User enable for spark2. Set to zero to disable spark 2.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark2Enable, 1) << 4;

    // User enable for spark3. Set to zero to disable spark 3.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark3Enable, 1) << 3;


    // If set command the GCU system to crank for start, if clear command the GCU system to stop cranking. Cranking status will be visible in the GCU telemetry packet.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(crankEnable, 1);
    _pg_byteindex += 1; // close bit field


    // Number of oil injection pulses to deliver to prime the system. This only applies if an injector is configured for oil injection. Use zero to stop the priming operation. Priming will be ignored if the system is not enabled. Priming will be stopped if the engine starts running.
    // Range of oilInjPrime is 0.0 to 5100.0.
    float32ScaledTo1UnsignedBytes((float)oilInjPrime, _pg_data, &_pg_byteindex, 0.0f, 0.05f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiEnable_t::encode

/*!
 * \brief Decode the efiEnable packet
 *
 * Enable/disable command. Use this packet to shut down the engine by clearing
 * `userEnable` or to selectively disable the first or second spark output by
 * clearing `spark1Enable` or `spark2Enable`. The EFI will boot up with all the
 * enables set. The current enable status is visible in the [fast
 * telemetry](#EFI_PKT_TELEMETRYFAST) packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiEnable_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    oilInjPrime = 0;

    // Global enable based on physical input. This enable cannot be changed by this packet.
    ioEnable = (_pg_data[_pg_byteindex] >> 7);

    // User global enable. Set to zero to disable the engine.
    userEnable = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // User enable for spark1. Set to zero to disable spark 1.
    spark1Enable = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // User enable for spark2. Set to zero to disable spark 2.
    spark2Enable = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // User enable for spark3. Set to zero to disable spark 3.
    spark3Enable = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // If set command the GCU system to crank for start, if clear command the GCU system to stop cranking. Cranking status will be visible in the GCU telemetry packet.
    crankEnable = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    if(_pg_byteindex + 1 > _pg_numbytes)
        return true;

    // Number of oil injection pulses to deliver to prime the system. This only applies if an injector is configured for oil injection. Use zero to stop the priming operation. Priming will be ignored if the system is not enabled. Priming will be stopped if the engine starts running.
    // Range of oilInjPrime is 0.0 to 5100.0.
    oilInjPrime = (uint16_t)float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.05f);

    return true;

}// efiEnable_t::decode

/*!
 * \brief Create the efiUserThrottle packet
 *
 * Send a user throttle command. The actual throttle used by the EFI will
 * depend upon its configuration and the status of the throttle input sensors.
 * This command will be ignored if the throttle configuration does not have
 * `efiDrivesThrottle` set. The current throttle status (input, output, source)
 * are visible in the [fast telemetry](#EFI_PKT_TELEMETRYFAST) packet.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param throttle is The user commanded throttle in percent
 */
void efiUserThrottle_t::encode(efiPacket_t* _pg_pkt, float throttle)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // The user commanded throttle in percent
    // Range of throttle is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(throttle, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiUserThrottle_t::encode

/*!
 * \brief Decode the efiUserThrottle packet
 *
 * Send a user throttle command. The actual throttle used by the EFI will
 * depend upon its configuration and the status of the throttle input sensors.
 * This command will be ignored if the throttle configuration does not have
 * `efiDrivesThrottle` set. The current throttle status (input, output, source)
 * are visible in the [fast telemetry](#EFI_PKT_TELEMETRYFAST) packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param throttle receives The user commanded throttle in percent
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiUserThrottle_t::decode(const efiPacket_t* _pg_pkt, float* throttle)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // The user commanded throttle in percent
    // Range of throttle is 0.0 to 127.5.
    (*throttle) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    return 1;

}// efiUserThrottle_t::decode

/*!
 * \brief Create the efiRPMCommand packet
 *
 * Send a RPM command; which will engage the RPM controller. The RPM command
 * will be ignored if the throttle configuration does not have
 * `efiDrivesThrottle` set. The RPM controller can be disengaged by sending a
 * [user throttle](#EFI_PKT_USERTHROTTLE) command. The current RPM command
 * value and command source is visible in the [slow
 * telemetry](#EFI_PKT_TELEMETRYSLOW) packet.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param rpmcmd is Engine speed command in revolutions per minute
 */
void efiRPMCommand_t::encode(efiPacket_t* _pg_pkt, float rpmcmd)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Engine speed command in revolutions per minute
    // Range of rpmcmd is 0.0 to 32767.5.
    float32ScaledTo2UnsignedBeBytes(rpmcmd, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiRPMCommand_t::encode

/*!
 * \brief Decode the efiRPMCommand packet
 *
 * Send a RPM command; which will engage the RPM controller. The RPM command
 * will be ignored if the throttle configuration does not have
 * `efiDrivesThrottle` set. The RPM controller can be disengaged by sending a
 * [user throttle](#EFI_PKT_USERTHROTTLE) command. The current RPM command
 * value and command source is visible in the [slow
 * telemetry](#EFI_PKT_TELEMETRYSLOW) packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param rpmcmd receives Engine speed command in revolutions per minute
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiRPMCommand_t::decode(const efiPacket_t* _pg_pkt, float* rpmcmd)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Engine speed command in revolutions per minute
    // Range of rpmcmd is 0.0 to 32767.5.
    (*rpmcmd) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    return 1;

}// efiRPMCommand_t::decode

/*!
 * \brief Create the efiConfigRequest packet
 *
 * Use this packet to request one or more configuration and status packets from
 * the EFI. After receiving this packet the EFI will transmit a response packet
 * for every bit which is set. If the EFI is configured to hide configuration
 * data the response packet(s) may be a [nack](#EFI_PKT_NACK) rather than the
 * desired packet(s).
 * \param _pg_pkt points to the packet which will be created by this function
 * \param bits is One bit for every configuration packet
 */
void efiConfigRequest_t::encode(efiPacket_t* _pg_pkt, const efiConfigBits_t* bits)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // One bit for every configuration packet
    bits->encode(_pg_data, &_pg_byteindex);

    // More bits for future expansion
    _pg_data[_pg_byteindex] = 0;

    // Application programming interface number of the protocol doing the requesting. Changes to the ICD will increment this number.
    _pg_data[_pg_byteindex] |= (uint8_t)geteficommsApi();
    _pg_byteindex += 1; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiConfigRequest_t::encode

/*!
 * \brief Decode the efiConfigRequest packet
 *
 * Use this packet to request one or more configuration and status packets from
 * the EFI. After receiving this packet the EFI will transmit a response packet
 * for every bit which is set. If the EFI is configured to hide configuration
 * data the response packet(s) may be a [nack](#EFI_PKT_NACK) rather than the
 * desired packet(s).
 * \param _pg_pkt points to the packet being decoded by this function
 * \param bits receives One bit for every configuration packet
 * \param api receives Application programming interface number of the protocol doing the requesting. Changes to the ICD will increment this number.
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiConfigRequest_t::decode(const efiPacket_t* _pg_pkt, efiConfigBits_t* bits, uint8_t* api)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // One bit for every configuration packet
    if(bits->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // More bits for future expansion

    // Application programming interface number of the protocol doing the requesting. Changes to the ICD will increment this number.
    // Range of api is 0 to 31.
    (*api) = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    return 1;

}// efiConfigRequest_t::decode

/*!
 * \brief Decode the efismallConfigRequest packet
 *
 * Use this packet to request one or more configuration and status packets from
 * the EFI. If the EFI receives this packet it will assume the requesting
 * system is using version 1.x software and will convert tables.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efismallConfigRequest_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    reservedbits2 = 0;
    tables2 = 0;

    // One bit for each of the sensors. The least significant bit is the first sensor.
    // Range of sensors is 0 to 65535.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    sensors = _pg_tempbitfield;

    // Remaining bits for future expansion
    // Range of reservedbits is 0 to 7.
    reservedbits = (_pg_data[_pg_byteindex + 2] >> 5);

    // The cooling configuration
    cooling = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x1);

    // The new engine configuration
    newengine = ((_pg_data[_pg_byteindex + 2] >> 3) & 0x1);

    // The SD Card journal data
    sdjournal = ((_pg_data[_pg_byteindex + 2] >> 2) & 0x1);

    // The engine wear data
    wear = ((_pg_data[_pg_byteindex + 2] >> 1) & 0x1);

    // The logbook data
    logbook = ((_pg_data[_pg_byteindex + 2]) & 0x1);

    // The maintenance status data
    maintenancestatus = (_pg_data[_pg_byteindex + 3] >> 7);

    // The maintenance configuration data
    maintenanceconfig = ((_pg_data[_pg_byteindex + 3] >> 6) & 0x1);

    // The oscilloscope setup data
    scopesetup = ((_pg_data[_pg_byteindex + 3] >> 5) & 0x1);

    // The configuration hash data
    confighash = ((_pg_data[_pg_byteindex + 3] >> 4) & 0x1);

    // The fuel pump configuration
    pump = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // The communications configuration
    comms = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);

    // The throttle configuration
    throttle = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // A reserved bit for future expansion
    reservedbit = ((_pg_data[_pg_byteindex + 3]) & 0x1);

    // The injector configuration
    injector = (_pg_data[_pg_byteindex + 4] >> 7);

    // The rpm controller configuration
    rpmcontroller = ((_pg_data[_pg_byteindex + 4] >> 6) & 0x1);

    // The lock control information
    lockcontrol = ((_pg_data[_pg_byteindex + 4] >> 5) & 0x1);

    // The software information data
    softwareinfo = ((_pg_data[_pg_byteindex + 4] >> 4) & 0x1);

    // The reset report data
    resetinfo = ((_pg_data[_pg_byteindex + 4] >> 3) & 0x1);

    // The file data
    file = ((_pg_data[_pg_byteindex + 4] >> 2) & 0x1);

    // The comment data
    comment = ((_pg_data[_pg_byteindex + 4] >> 1) & 0x1);

    // The hardware information data
    hardwareinfo = ((_pg_data[_pg_byteindex + 4]) & 0x1);

    // One bit for each of the tables. The least significant bit is the first table.
    // Range of tables is 0 to 16777215.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 5] & 0xFF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 6];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 7];

    tables = _pg_tempbitfield;

    if(_pg_byteindex + 11 > _pg_numbytes)
        return 1;

    // More bits for future expansion
    // Range of reservedbits2 is 0 to 1048575.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 8] & 0xFF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 9];

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 10] >> 4);

    reservedbits2 = _pg_tempbitfield;

    if(_pg_byteindex + 12 > _pg_numbytes)
        return 1;

    // One bit for each of the tables above table 23. The least significant bit is table 24.
    // Range of tables2 is 0 to 4095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 10] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 11];

    tables2 = _pg_tempbitfield;
    _pg_byteindex += 12; // close bit field

    return true;

}// efismallConfigRequest_t::decode

/*!
 * \brief Create the efiUnlock packet
 *
 * Send this packet to unlock the EFI so configuration data can be changed (or
 * viewed if hidden). For password locked configurations, if the password is
 * lost you can use the string 'CLEAR ALL DATA'. This will allow the EFI to be
 * password unlocked, but will also reset the EFI to defaults, clearing all
 * existing configuration data from both user and factory storage. Note that
 * the 'CLEAR ALL DATA' password cannot be used if the engine is running, in
 * which case a [nack](#EFI_PKT_NACK) will be generated. After receiving this
 * packet the EFI will send this packet back to the user, to report the current
 * lock status. Anytime the EFI sends this packet the password field will be
 * empty. The lock status is always visible in the [cpu
 * telemetry](#EFI_PKT_TELEMETRYCPU) packet. The cpu telemetry packet also
 * indicates if unlocking will require a password.
 * 
 * This packet can be used to lock the EFI by requesting an unlock level which
 * is lower than the current level. In that case the password is not needed.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiUnlock_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    _pg_data[_pg_byteindex] = 0;

    // For packets going to the EFI this is the desired unlock level. For packets coming from the EFI this the current unlock level.
    // Range of unlockLevel is 0 to 3.
    _pg_data[_pg_byteindex] |= (uint8_t)unlockLevel;
    _pg_byteindex += 1; // close bit field


    // Password used to unlock. This password must match the password used in the lock configuration. If the password is incorrect the EFI will respond with nack. When the EFI sends this packet the password field will be empty.
    stringToBytes(password, _pg_data, &_pg_byteindex, 32, 0);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiUnlock_t::encode

/*!
 * \brief Decode the efiUnlock packet
 *
 * Send this packet to unlock the EFI so configuration data can be changed (or
 * viewed if hidden). For password locked configurations, if the password is
 * lost you can use the string 'CLEAR ALL DATA'. This will allow the EFI to be
 * password unlocked, but will also reset the EFI to defaults, clearing all
 * existing configuration data from both user and factory storage. Note that
 * the 'CLEAR ALL DATA' password cannot be used if the engine is running, in
 * which case a [nack](#EFI_PKT_NACK) will be generated. After receiving this
 * packet the EFI will send this packet back to the user, to report the current
 * lock status. Anytime the EFI sends this packet the password field will be
 * empty. The lock status is always visible in the [cpu
 * telemetry](#EFI_PKT_TELEMETRYCPU) packet. The cpu telemetry packet also
 * indicates if unlocking will require a password.
 * 
 * This packet can be used to lock the EFI by requesting an unlock level which
 * is lower than the current level. In that case the password is not needed.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiUnlock_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // For packets going to the EFI this is the desired unlock level. For packets coming from the EFI this the current unlock level.
    // Range of unlockLevel is 0 to 3.
    unlockLevel = ((_pg_data[_pg_byteindex]) & 0x3);
    _pg_byteindex += 1; // close bit field

    // Password used to unlock. This password must match the password used in the lock configuration. If the password is incorrect the EFI will respond with nack. When the EFI sends this packet the password field will be empty.
    stringFromBytes(password, _pg_data, &_pg_byteindex, 32, 0);

    return true;

}// efiUnlock_t::decode

/*!
 * \brief Create the efiResetCmd packet
 *
 * Packet used to command an EFI reset. This is primarily used to reset the EFI
 * into bootloader mode for firmware update. This packet is also used for
 * software development testing and to test the behavior of the engine during
 * EFI reset. This packet will not be obeyed unless the unlock level is
 * [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels), *or* the engine is not
 * running and the reset requested is `bootloaderReset`.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiResetCmd_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // If set perform a reset by entering an infinite loop so that the watchdog triggers a reset.
    _pg_data[_pg_byteindex] = (uint8_t)watchdogReset << 7;

    // If set perform a software reset
    _pg_data[_pg_byteindex] |= (uint8_t)softwareReset << 6;

    // If set perform a memory write to an invalid address in order to trigger a memory exception reset
    _pg_data[_pg_byteindex] |= (uint8_t)invalidAddressReset << 5;

    // If set perform a memory write to an unaligned address in order to trigger a unaligned exception reset
    _pg_data[_pg_byteindex] |= (uint8_t)unalignedAddressReset << 4;

    // If set perform a integer divide by zero in order to trigger an exception reset
    _pg_data[_pg_byteindex] |= (uint8_t)divideByZeroReset << 3;

    // If set perform a floating point divide by zero in order to trigger an floating point interrupt reset
    _pg_data[_pg_byteindex] |= (uint8_t)floatDivideByZeroReset << 2;

    // If set perform a reset to enter into bootloader mode for firmware update.
    _pg_data[_pg_byteindex] |= (uint8_t)bootloaderReset << 1;

    // If set perform a reset that results in safe mode
    _pg_data[_pg_byteindex] |= (uint8_t)safemodereset;
    _pg_byteindex += 1; // close bit field


    // This field must be set to `0xABCD8765` or the packet will be ignored
    uint32ToBeBytes((uint32_t)(0xABCD8765), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiResetCmd_t::encode

/*!
 * \brief Decode the efiResetCmd packet
 *
 * Packet used to command an EFI reset. This is primarily used to reset the EFI
 * into bootloader mode for firmware update. This packet is also used for
 * software development testing and to test the behavior of the engine during
 * EFI reset. This packet will not be obeyed unless the unlock level is
 * [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels), *or* the engine is not
 * running and the reset requested is `bootloaderReset`.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiResetCmd_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // If set perform a reset by entering an infinite loop so that the watchdog triggers a reset.
    watchdogReset = (_pg_data[_pg_byteindex] >> 7);

    // If set perform a software reset
    softwareReset = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // If set perform a memory write to an invalid address in order to trigger a memory exception reset
    invalidAddressReset = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // If set perform a memory write to an unaligned address in order to trigger a unaligned exception reset
    unalignedAddressReset = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // If set perform a integer divide by zero in order to trigger an exception reset
    divideByZeroReset = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // If set perform a floating point divide by zero in order to trigger an floating point interrupt reset
    floatDivideByZeroReset = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // If set perform a reset to enter into bootloader mode for firmware update.
    bootloaderReset = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // If set perform a reset that results in safe mode
    safemodereset = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    // This field must be set to `0xABCD8765` or the packet will be ignored
    // Range of extraVerification is 0 to -2147483648.
    // Decoded value must be 0xABCD8765
    extraVerification = uint32FromBeBytes(_pg_data, &_pg_byteindex);
    if (extraVerification != 0xABCD8765)
        return false;

    return true;

}// efiResetCmd_t::decode

/*!
 * \brief Create the efiStorageLong packet
 *
 * Commands for manipulating storage. The EFI maintains two storage locations
 * for non-volatile configuration data. The user storage data is always updated
 * whenever the configuration is changed. Any configuration data which is not
 * present in the user storage will be supplied by the factory storage when the
 * EFI starts up. Factory storage is intended to hold the configuration as it
 * left the factory, providing a way for users to revert to the original
 * configuration. Factory configuration data is stored in on-chip flash, and
 * will take several seconds to change, therefore factory storage cannot be
 * changed while the engine is running.
 * 
 * Storage commands that affect the EEPROM or flash (i.e. non-sdcard commands)
 * will not be obeyed unless the unlock level is
 * [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels). In addition any command
 * which changes the factory storage will not be obeyed if the engine is
 * running. Note that clearing the storage will not clear the engine wear
 * information. If this command alters configuration data the EFI will send the
 * configuration packets.
 * 
 * The storage command is also used with the SD card. SD card storage commands
 * can be sent when the engine is running, and do not require the system to be
 * unlocked. To read a record from the SD card send the command
 * `efiStorageTransferSD` with the record number to be read. The progress of
 * the SD transfer can be monitored with the SD card telemetry packet. When the
 * transfer is complete this packet will be sent from the EFI with the command
 * `efiStorageStopTransferSD` to indicate the transfer is complete. You can
 * also stop the transfer by sending the command `efiStorageStopTransferSD`.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param command is The storage command to execute
 * \param aborted is If the command is `efiStorageStopTransferSD` this flag will be set if the transfer was stopped because of a problem with the SD card.
 * \param sdrecord is The record identifier for the `efiStorageTransferSD` command. This must be a valid record in the SD card journal.
 */
void efiStorageLong_t::encode(efiPacket_t* _pg_pkt, efiStorageCmds command, uint8_t aborted, uint16_t sdrecord)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // The storage command to execute
    // Range of command is 0 to 255.
    uint8ToBytes(command, _pg_data, &_pg_byteindex);

    // If the command is `efiStorageStopTransferSD` this flag will be set if the transfer was stopped because of a problem with the SD card.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(aborted, 1) << 7;

    _pg_byteindex += 1; // close bit field

    // The record identifier for the `efiStorageTransferSD` command. This must be a valid record in the SD card journal.
    // Range of sdrecord is 0 to 65535.
    uint16ToBeBytes(sdrecord, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiStorageLong_t::encode

/*!
 * \brief Decode the efiStorageLong packet
 *
 * Commands for manipulating storage. The EFI maintains two storage locations
 * for non-volatile configuration data. The user storage data is always updated
 * whenever the configuration is changed. Any configuration data which is not
 * present in the user storage will be supplied by the factory storage when the
 * EFI starts up. Factory storage is intended to hold the configuration as it
 * left the factory, providing a way for users to revert to the original
 * configuration. Factory configuration data is stored in on-chip flash, and
 * will take several seconds to change, therefore factory storage cannot be
 * changed while the engine is running.
 * 
 * Storage commands that affect the EEPROM or flash (i.e. non-sdcard commands)
 * will not be obeyed unless the unlock level is
 * [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels). In addition any command
 * which changes the factory storage will not be obeyed if the engine is
 * running. Note that clearing the storage will not clear the engine wear
 * information. If this command alters configuration data the EFI will send the
 * configuration packets.
 * 
 * The storage command is also used with the SD card. SD card storage commands
 * can be sent when the engine is running, and do not require the system to be
 * unlocked. To read a record from the SD card send the command
 * `efiStorageTransferSD` with the record number to be read. The progress of
 * the SD transfer can be monitored with the SD card telemetry packet. When the
 * transfer is complete this packet will be sent from the EFI with the command
 * `efiStorageStopTransferSD` to indicate the transfer is complete. You can
 * also stop the transfer by sending the command `efiStorageStopTransferSD`.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param command receives The storage command to execute
 * \param aborted receives If the command is `efiStorageStopTransferSD` this flag will be set if the transfer was stopped because of a problem with the SD card.
 * \param sdrecord receives The record identifier for the `efiStorageTransferSD` command. This must be a valid record in the SD card journal.
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiStorageLong_t::decode(const efiPacket_t* _pg_pkt, efiStorageCmds* command, uint8_t* aborted, uint16_t* sdrecord)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // The storage command to execute
    // Range of command is 0 to 255.
    (*command) = (efiStorageCmds)uint8FromBytes(_pg_data, &_pg_byteindex);

    // If the command is `efiStorageStopTransferSD` this flag will be set if the transfer was stopped because of a problem with the SD card.
    (*aborted) = (_pg_data[_pg_byteindex] >> 7);

    _pg_byteindex += 1; // close bit field

    // The record identifier for the `efiStorageTransferSD` command. This must be a valid record in the SD card journal.
    // Range of sdrecord is 0 to 65535.
    (*sdrecord) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// efiStorageLong_t::decode

/*!
 * \brief Create the efiStorage packet
 *
 * Short version of the storage command. This version can be used for all
 * commands except the `efiStorageTransferSD`
 * \param _pg_pkt points to the packet which will be created by this function
 * \param command is The storage command to execute
 */
void efiStorage_t::encode(efiPacket_t* _pg_pkt, efiStorageCmds command)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // The storage command to execute
    // Range of command is 0 to 255.
    uint8ToBytes(command, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiStorage_t::encode

/*!
 * \brief Decode the efiStorage packet
 *
 * Short version of the storage command. This version can be used for all
 * commands except the `efiStorageTransferSD`
 * \param _pg_pkt points to the packet being decoded by this function
 * \param command receives The storage command to execute
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiStorage_t::decode(const efiPacket_t* _pg_pkt, efiStorageCmds* command)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // The storage command to execute
    // Range of command is 0 to 255.
    (*command) = (efiStorageCmds)uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// efiStorage_t::decode

/*!
 * \brief Create the efiFuelUsed packet
 *
 * Use this packet to set or request the total fuel and oil used. The fuel and
 * oil totalizers start at zero when the EFI boots up and increases as the
 * engine runs. The fuel used is also reported in the fuel telemetry packet.
 * The oil used is also reported in the oil injection telemetry packet. Send
 * this packet with zero length to request the fuel and oil used.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param fuelConsumption is Fuel consumption in grams since the system turned on.
 * \param oilConsumption is Oil consumption in grams since the system turned on.
 */
void efiFuelUsed_t::encode(efiPacket_t* _pg_pkt, float fuelConsumption, float oilConsumption)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Fuel consumption in grams since the system turned on.
    // Range of fuelConsumption is -65504.0 to 65504.0.
    float16ToBeBytes((float)fuelConsumption, _pg_data, &_pg_byteindex, 10);

    // Oil consumption in grams since the system turned on.
    // Range of oilConsumption is -65504.0 to 65504.0.
    float16ToBeBytes((float)oilConsumption, _pg_data, &_pg_byteindex, 10);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiFuelUsed_t::encode

/*!
 * \brief Decode the efiFuelUsed packet
 *
 * Use this packet to set or request the total fuel and oil used. The fuel and
 * oil totalizers start at zero when the EFI boots up and increases as the
 * engine runs. The fuel used is also reported in the fuel telemetry packet.
 * The oil used is also reported in the oil injection telemetry packet. Send
 * this packet with zero length to request the fuel and oil used.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param fuelConsumption receives Fuel consumption in grams since the system turned on.
 * \param oilConsumption receives Oil consumption in grams since the system turned on.
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiFuelUsed_t::decode(const efiPacket_t* _pg_pkt, float* fuelConsumption, float* oilConsumption)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // this packet has default fields, make sure they are set
    (*oilConsumption) = 0;

    // Fuel consumption in grams since the system turned on.
    // Range of fuelConsumption is -65504.0 to 65504.0.
    (*fuelConsumption) = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return true;

    // Oil consumption in grams since the system turned on.
    // Range of oilConsumption is -65504.0 to 65504.0.
    (*oilConsumption) = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    return 1;

}// efiFuelUsed_t::decode

/*!
 * \brief Encode a efiMaintenanceItemStatus_t into a byte array
 *
 * List of maintenance item status
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiMaintenanceItemStatus_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    // This bit is set if the maintenance item has elapsed.
    _pg_data[_pg_byteindex] = (uint8_t)triggered << 7;

    // The index number of this maintenance item status. the index number matches the index from the maintenance schedule configuration.
    // Range of index is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(index, 31);
    _pg_byteindex += 1; // close bit field

    // The date and time when this maintenance item was last serviced. This field can only be changed with the `DoMaintenance` command
    servicetime.encode(_pg_data, &_pg_byteindex);

    // The last time this maintenance item was done, zero if never.
    // Range of lastdone is 0 to -2147483648.
    uint32ToBeBytes(lastdone, _pg_data, &_pg_byteindex);

    // Name of the person who did the most recent maintenance.
    stringToBytes(name, _pg_data, &_pg_byteindex, maxNameCharacters, 0);

    *_pg_bytecount = _pg_byteindex;

}// efiMaintenanceItemStatus_t::encode

/*!
 * \brief Decode a efiMaintenanceItemStatus_t from a byte array
 *
 * List of maintenance item status
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiMaintenanceItemStatus_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // This bit is set if the maintenance item has elapsed.
    triggered = (_pg_data[_pg_byteindex] >> 7);

    // The index number of this maintenance item status. the index number matches the index from the maintenance schedule configuration.
    // Range of index is 0 to 31.
    index = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    // The date and time when this maintenance item was last serviced. This field can only be changed with the `DoMaintenance` command
    if(servicetime.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // The last time this maintenance item was done, zero if never.
    // Range of lastdone is 0 to -2147483648.
    lastdone = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Name of the person who did the most recent maintenance.
    stringFromBytes(name, _pg_data, &_pg_byteindex, maxNameCharacters, 0);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiMaintenanceItemStatus_t::decode

/*!
 * \brief Create the efiMaintenanceStatus packet
 *
 * Set or request the maintenance status. To request the status send this
 * packet with zero length. If unlocked you can send this packet to overwrite
 * the maintenance status (except for `engineSerial`). To change the
 * `engineSerial` `setEngineSerial` must be set and IntelliJect must be
 * unlocked. Typically you do not send this packet to change the maintenance
 * status, instead you use the PerformMaintenance packet for that purpose.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiMaintenanceStatus_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // This bit must be clear, if not clear than this packet is interpreted as a PerformMaintenance packet. This bit will never be set when this packet comes from IntelliJect.
    _pg_data[_pg_byteindex] = 0;

    // Set this bit when sending to IntelliJect to change the engine serial number. This change can only be performed if IntelliJect is unlocked. This bit will never be set when this packet comes from IntelliJect.
    _pg_data[_pg_byteindex] |= (uint8_t)setEngineSerial << 6;


    // The number of maintenance status items in this packet
    // Range of numItems is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(numItems, 31);
    _pg_byteindex += 1; // close bit field


    // The engine serial number. This can only be changed if IntelliJect is unlocked and `setEngineSerial` is set.
    // Range of engineSerial is 0 to -2147483648.
    uint32ToBeBytes(engineSerial, _pg_data, &_pg_byteindex);

    // List of maintenance item status
    for(_pg_i = 0; _pg_i < (unsigned)numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        MaintenanceItemStatus[_pg_i].encode(_pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiMaintenanceStatus_t::encode

/*!
 * \brief Decode the efiMaintenanceStatus packet
 *
 * Set or request the maintenance status. To request the status send this
 * packet with zero length. If unlocked you can send this packet to overwrite
 * the maintenance status (except for `engineSerial`). To change the
 * `engineSerial` `setEngineSerial` must be set and IntelliJect must be
 * unlocked. Typically you do not send this packet to change the maintenance
 * status, instead you use the PerformMaintenance packet for that purpose.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiMaintenanceStatus_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // This bit must be clear, if not clear than this packet is interpreted as a PerformMaintenance packet. This bit will never be set when this packet comes from IntelliJect.
    domaintenance = (_pg_data[_pg_byteindex] >> 7);
    // Decoded value must be 0
    if(domaintenance != 0)
        return false;

    // Set this bit when sending to IntelliJect to change the engine serial number. This change can only be performed if IntelliJect is unlocked. This bit will never be set when this packet comes from IntelliJect.
    setEngineSerial = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // The number of maintenance status items in this packet
    // Range of numItems is 0 to 31.
    numItems = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    // The engine serial number. This can only be changed if IntelliJect is unlocked and `setEngineSerial` is set.
    // Range of engineSerial is 0 to -2147483648.
    engineSerial = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // List of maintenance item status
    for(_pg_i = 0; _pg_i < (unsigned)numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        if(MaintenanceItemStatus[_pg_i].decode(_pg_data, &_pg_byteindex) == false)
            return false;

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    return true;

}// efiMaintenanceStatus_t::decode

/*!
 * \brief Create the efiPerformMaintenance packet
 *
 * Send this packet to IntelliJect to perform a single maintenance item.
 * Performing maintenance means clearing the triggered status, updating the
 * `lastdone` and `name` fields on the maintenance status, and adding a log
 * entry. This packet is never sent by IntelliJect, the response will always be
 * the MaintenanceStatus packet, followed by a LogEntry packet.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiPerformMaintenance_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Set this bit when sending to IntelliJect to indicate that this maintenance item has been performed. This bit will never be set when this packet comes from IntelliJect.
    _pg_data[_pg_byteindex] = (uint8_t)1 << 7;


    // The index number of the maintenance item that is being performed. the index number matches the index from the maintenance schedule configuration.
    // Range of index is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(index, 31);
    _pg_byteindex += 1; // close bit field


    // The date and time when this maintenance item was serviced.
    servicetime.encode(_pg_data, &_pg_byteindex);

    // Name of the person who did the maintenance.
    stringToBytes(name, _pg_data, &_pg_byteindex, maxNameCharacters, 0);

    // The text that goes into the log as part of performing this maintenance.
    stringToBytes(description, _pg_data, &_pg_byteindex, EFI_PACKET_SIZE - maxNameCharacters - 7, 0);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiPerformMaintenance_t::encode

/*!
 * \brief Decode the efiPerformMaintenance packet
 *
 * Send this packet to IntelliJect to perform a single maintenance item.
 * Performing maintenance means clearing the triggered status, updating the
 * `lastdone` and `name` fields on the maintenance status, and adding a log
 * entry. This packet is never sent by IntelliJect, the response will always be
 * the MaintenanceStatus packet, followed by a LogEntry packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiPerformMaintenance_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Set this bit when sending to IntelliJect to indicate that this maintenance item has been performed. This bit will never be set when this packet comes from IntelliJect.
    domaintenance = (_pg_data[_pg_byteindex] >> 7);
    // Decoded value must be 1
    if(domaintenance != 1)
        return false;

    // The index number of the maintenance item that is being performed. the index number matches the index from the maintenance schedule configuration.
    // Range of index is 0 to 31.
    index = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    // The date and time when this maintenance item was serviced.
    if(servicetime.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Name of the person who did the maintenance.
    stringFromBytes(name, _pg_data, &_pg_byteindex, maxNameCharacters, 0);

    // The text that goes into the log as part of performing this maintenance.
    stringFromBytes(description, _pg_data, &_pg_byteindex, EFI_PACKET_SIZE - maxNameCharacters - 7, 0);

    return true;

}// efiPerformMaintenance_t::decode

/*!
 * \brief Create the efiLogEntry packet
 *
 * Log entry packet used to request, add, or change entries in the digital
 * engine logbook. The logbook consists of a series of entries, each contained
 * in a single packet. Each log entry contains a, `date`, `name`, and
 * `description` text. In addition each log entry has an `index` that simply
 * identifies the location of the entry in the logbook.
 * 
 * The interpretation of the log entry packet depends on the value of the `cmd`
 * field, and on whether the packet was sent to, or received from, the EFI.
 * When requesting a specific log entry, requesting the number of log entries,
 * or deleting a log entry; you only need to send the first two bytes,
 * identifying the log entry by its index. Note that if a log entry is deleted
 * the indices of the log entries above the deleted entry will be changed so
 * that the list of indices alays starts at zero and ends at 1 less than the
 * number of entries.
 * 
 * When requesting the number of log entries the EFI will respond with the two
 * byte form of this packet, with `cmd` set to `numLogEntries` and `index`
 * giving the number of log entries. When requesting a log entry the EFI will
 * respond with the requested entry and the `cmd` value set to `logEntry`. When
 * deleting a log entry the EFI will respond with the two byte form of this
 * packet, with the `cmd` set to `deleteLogEntry` and the `index` set to the
 * deleted entry's index.
 * 
 * To add a new log entry send this packet with `cmd` set to `logEntry` and
 * `index` greater than the or equal to the `numLogEntries`. The EFI will
 * respond by echoing the new log entry. To change an existing log entry set
 * `index` equal to the entry to change. The EFI will first delete the `index`
 * entry (resetting all the indices of later entries) and then append the
 * updated entry to the logbook. In this case the EFI will respond as through
 * two separate commands were sent: a delete command followed by a new log
 * entry.
 * 
 * The logbook is stored onboard IntelliJect in 128Kbytes of flash. If each
 * entry uses the maximum amount of text there is space for at least 127
 * entries. Most entries will have less than the maximum text so it should be
 * possible to have many more than 127 entries. Because the logbook is stored
 * in flash deleting or changing an entry requires zero-ing that flash location
 * and re-writing the entry further on. Enough log entries, deletions, or
 * edits, will use up or fragment the log storage space until no more entries
 * can be made. In that case log additions will result in a nack. Use the
 * command `eraseLogBook` to completely erase the log; at which point you can
 * reload it without framentation, and/or remove older log entries to make room
 * for new ones. The log cannot be changed while the engine is running,
 * attempting to do so will result in a nack.
 * 
 * Adding a new log entry does not require IntelliJect to be unlocked. However
 * deleting or changing a log entry does require IntelliJect to be unlocked.
 * The log follows the same access restrictions as the maintenance schedule.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiLogEntry_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Command for the log entry packet. The interpretation of the command depends . Use `logEntry` or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`.
    _pg_data[_pg_byteindex] = (uint8_t)cmd << 5;


    // The index number for this log.
    // Range of index is 0 to 1023.
    _pg_tempbitfield = (unsigned int)limitMax(index, 1023);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field


    // The date and time of the log entry.
    time.encode(_pg_data, &_pg_byteindex);

    // Name of the person who entered the log entry.
    stringToBytes(name, _pg_data, &_pg_byteindex, maxNameCharacters, 0);

    // The log entry text.
    stringToBytes(description, _pg_data, &_pg_byteindex, EFI_PACKET_SIZE - maxNameCharacters - 7, 0);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiLogEntry_t::encode

/*!
 * \brief Decode the efiLogEntry packet
 *
 * Log entry packet used to request, add, or change entries in the digital
 * engine logbook. The logbook consists of a series of entries, each contained
 * in a single packet. Each log entry contains a, `date`, `name`, and
 * `description` text. In addition each log entry has an `index` that simply
 * identifies the location of the entry in the logbook.
 * 
 * The interpretation of the log entry packet depends on the value of the `cmd`
 * field, and on whether the packet was sent to, or received from, the EFI.
 * When requesting a specific log entry, requesting the number of log entries,
 * or deleting a log entry; you only need to send the first two bytes,
 * identifying the log entry by its index. Note that if a log entry is deleted
 * the indices of the log entries above the deleted entry will be changed so
 * that the list of indices alays starts at zero and ends at 1 less than the
 * number of entries.
 * 
 * When requesting the number of log entries the EFI will respond with the two
 * byte form of this packet, with `cmd` set to `numLogEntries` and `index`
 * giving the number of log entries. When requesting a log entry the EFI will
 * respond with the requested entry and the `cmd` value set to `logEntry`. When
 * deleting a log entry the EFI will respond with the two byte form of this
 * packet, with the `cmd` set to `deleteLogEntry` and the `index` set to the
 * deleted entry's index.
 * 
 * To add a new log entry send this packet with `cmd` set to `logEntry` and
 * `index` greater than the or equal to the `numLogEntries`. The EFI will
 * respond by echoing the new log entry. To change an existing log entry set
 * `index` equal to the entry to change. The EFI will first delete the `index`
 * entry (resetting all the indices of later entries) and then append the
 * updated entry to the logbook. In this case the EFI will respond as through
 * two separate commands were sent: a delete command followed by a new log
 * entry.
 * 
 * The logbook is stored onboard IntelliJect in 128Kbytes of flash. If each
 * entry uses the maximum amount of text there is space for at least 127
 * entries. Most entries will have less than the maximum text so it should be
 * possible to have many more than 127 entries. Because the logbook is stored
 * in flash deleting or changing an entry requires zero-ing that flash location
 * and re-writing the entry further on. Enough log entries, deletions, or
 * edits, will use up or fragment the log storage space until no more entries
 * can be made. In that case log additions will result in a nack. Use the
 * command `eraseLogBook` to completely erase the log; at which point you can
 * reload it without framentation, and/or remove older log entries to make room
 * for new ones. The log cannot be changed while the engine is running,
 * attempting to do so will result in a nack.
 * 
 * Adding a new log entry does not require IntelliJect to be unlocked. However
 * deleting or changing a log entry does require IntelliJect to be unlocked.
 * The log follows the same access restrictions as the maintenance schedule.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiLogEntry_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Command for the log entry packet. The interpretation of the command depends . Use `logEntry` or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`.
    cmd = (LogEntryCommands)(_pg_data[_pg_byteindex] >> 5);

    // The index number for this log.
    // Range of index is 0 to 1023.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    index = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // The date and time of the log entry.
    if(time.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Name of the person who entered the log entry.
    stringFromBytes(name, _pg_data, &_pg_byteindex, maxNameCharacters, 0);

    // The log entry text.
    stringFromBytes(description, _pg_data, &_pg_byteindex, EFI_PACKET_SIZE - maxNameCharacters - 7, 0);

    return true;

}// efiLogEntry_t::decode

/*!
 * \brief Create the efiLogEntryCommand packet
 *
 * Command packet for a log entry.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param cmd is Command for the log entry packet. Use 'logEntry' or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`.
 * \param index is The index number that goes with the command.
 */
void efiLogEntryCommand_t::encode(efiPacket_t* _pg_pkt, LogEntryCommands cmd, uint16_t index)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Command for the log entry packet. Use 'logEntry' or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`.
    _pg_data[_pg_byteindex] = (uint8_t)cmd << 5;

    // The index number that goes with the command.
    // Range of index is 0 to 8191.
    _pg_tempbitfield = (unsigned int)limitMax(index, 8191);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiLogEntryCommand_t::encode

/*!
 * \brief Decode the efiLogEntryCommand packet
 *
 * Command packet for a log entry.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param cmd receives Command for the log entry packet. Use 'logEntry' or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`.
 * \param index receives The index number that goes with the command.
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiLogEntryCommand_t::decode(const efiPacket_t* _pg_pkt, LogEntryCommands* cmd, uint16_t* index)
{
    unsigned int _pg_tempbitfield = 0;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Command for the log entry packet. Use 'logEntry' or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`.
    (*cmd) = (LogEntryCommands)(_pg_data[_pg_byteindex] >> 5);

    // The index number that goes with the command.
    // Range of index is 0 to 8191.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x1F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    (*index) = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    return 1;

}// efiLogEntryCommand_t::decode

/*!
 * \brief Encode a efijournal_t into a byte array
 *
 * Journal information for records of data on the SD card
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efijournal_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    // The record identifier.
    // Range of record is 0 to 65535.
    uint16ToBeBytes(record, _pg_data, &_pg_byteindex);

    // The last 512 byte block written for this record, relative to the start of the card volume. The first and last blocks on the card contains the journal.
    // Range of lastBlock is 0 to -2147483648.
    uint32ToBeBytes(lastBlock, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efijournal_t::encode

/*!
 * \brief Decode a efijournal_t from a byte array
 *
 * Journal information for records of data on the SD card
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efijournal_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // The record identifier.
    // Range of record is 0 to 65535.
    record = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // The last 512 byte block written for this record, relative to the start of the card volume. The first and last blocks on the card contains the journal.
    // Range of lastBlock is 0 to -2147483648.
    lastBlock = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efijournal_t::decode

/*!
 * \brief Create the efiSDCardJournal packet
 *
 * This packet reports the SD card journal, which is used to track information
 * written to the SD card. The journal is stored on the card and cannot be
 * changed with this packet. The journal can be requested from the EFI by
 * sending this packet with zero length. If no card is installed, or the card
 * has a problem, the journal will contain no records.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiSDCardJournal_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // SD card telemetry information. The only field from this telemetry that is used for journaling is `numDataBlocks`.
    sdcardtm.encode(_pg_data, &_pg_byteindex);

    // The number of data blocks the card volume can hold, including the journal blocks.
    // Range of numBlocksInVolume is 0 to -2147483648.
    uint32ToBeBytes(numBlocksInVolume, _pg_data, &_pg_byteindex);

    _pg_data[_pg_byteindex + 1] = 0;

    _pg_data[_pg_byteindex] = 0;


    // Number of records in the journal. This may be less than the number of records on the card.
    // Range of numRecords is 0 to 127.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)limitMax(numRecords, 127);
    _pg_byteindex += 2; // close bit field


    // Journal information for records of data on the SD card
    for(_pg_i = 0; _pg_i < (unsigned)numRecords && _pg_i < maxJournalEntries; _pg_i++)
        journal[_pg_i].encode(_pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiSDCardJournal_t::encode

/*!
 * \brief Decode the efiSDCardJournal packet
 *
 * This packet reports the SD card journal, which is used to track information
 * written to the SD card. The journal is stored on the card and cannot be
 * changed with this packet. The journal can be requested from the EFI by
 * sending this packet with zero length. If no card is installed, or the card
 * has a problem, the journal will contain no records.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiSDCardJournal_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // SD card telemetry information. The only field from this telemetry that is used for journaling is `numDataBlocks`.
    if(sdcardtm.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // The number of data blocks the card volume can hold, including the journal blocks.
    // Range of numBlocksInVolume is 0 to -2147483648.
    numBlocksInVolume = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Number of records in the journal. This may be less than the number of records on the card.
    // Range of numRecords is 0 to 127.
    numRecords = ((_pg_data[_pg_byteindex + 1]) & 0x7F);
    _pg_byteindex += 2; // close bit field

    // Journal information for records of data on the SD card
    for(_pg_i = 0; _pg_i < (unsigned)numRecords && _pg_i < maxJournalEntries; _pg_i++)
        if(journal[_pg_i].decode(_pg_data, &_pg_byteindex) == false)
            return false;

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    return true;

}// efiSDCardJournal_t::decode

/*!
 * \brief Create the efiFile packet
 *
 * The file packet gives the name of a file. This is typically used to store
 * the name of the file that was used to configure this EFI. The file name is
 * not used by the EFI, it is provided as a convenient means of configuration
 * management.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiFile_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // The date when the file configuration was sent
    date.encode(_pg_data, &_pg_byteindex);

    // The name of the file used to load configuration.
    stringToBytes(filename, _pg_data, &_pg_byteindex, 128, 0);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiFile_t::encode

/*!
 * \brief Decode the efiFile packet
 *
 * The file packet gives the name of a file. This is typically used to store
 * the name of the file that was used to configure this EFI. The file name is
 * not used by the EFI, it is provided as a convenient means of configuration
 * management.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiFile_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Skip over reserved space
    _pg_byteindex += 1*8;

    // The date when the file configuration was sent
    if(date.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // The name of the file used to load configuration.
    stringFromBytes(filename, _pg_data, &_pg_byteindex, 128, 0);

    return true;

}// efiFile_t::decode

/*!
 * \brief Create the efiComment packet
 *
 * This packet gives a user comment to describe the configuration. The comment
 * is not used by the EFI, it is provided as a means of configuration
 * management.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiComment_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // 8 bytes of user writable and readable nonvolatile data
    // Range of userdata is 0 to 255.
    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        uint8ToBytes(userdata[_pg_i], _pg_data, &_pg_byteindex);

    // User comment string
    stringToBytes(comment, _pg_data, &_pg_byteindex, 512, 0);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiComment_t::encode

/*!
 * \brief Decode the efiComment packet
 *
 * This packet gives a user comment to describe the configuration. The comment
 * is not used by the EFI, it is provided as a means of configuration
 * management.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiComment_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // 8 bytes of user writable and readable nonvolatile data
    // Range of userdata is 0 to 255.
    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        userdata[_pg_i] = uint8FromBytes(_pg_data, &_pg_byteindex);

    // User comment string
    stringFromBytes(comment, _pg_data, &_pg_byteindex, 512, 0);

    return true;

}// efiComment_t::decode

/*!
 * \brief Create the efiLockControl packet
 *
 * This packet is used to lock the configuration and set the unlock password.
 * Each time the EFI starts the configuration is automaticaly locked and cannot
 * be changed unless the [unlock](#EFI_PKT_UNLOCK) command is given. EFI
 * locking has three levels: [`EFI_LCK_LOCKED`](#efiunlocklevels),
 * [`EFI_LCK_PARTIAL_UNLOCKED`](#efiunlocklevels), and
 * [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels).
 * 
 * For each set of configuration data (tables, governor, throttle, engine,
 * pump, sensors, comms) this packet specifies the behavior of the protections
 * when the password *has not yet been supplied*. There are three options:
 * read/write, read only, and hidden. When configuration data are read/write
 * the data can be requested when the efi is locked, and can be changed when
 * the efi unlock level is [`EFI_LCK_PARTIAL_UNLOCKED`](#efiunlocklevels). When
 * configuration data are read only the data can be requested when the efi is
 * locked, but changing the data requires unlocking with the password. When
 * configuration data are hidden the data cannot be requested or changed
 * without unlocking using the password.
 * 
 * Upon receipt of this packet, if the EFI is currently unlocked, the
 * configuration will be locked. The lock control configuration data are always
 * protected at the read only level: therefore you can always request the lock
 * control configuration but you cannot change it without doing a password
 * unlock. Note that when sent from the EFI this packet will never include the
 * password.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiLockControl_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Protection level for all the table configuration data
    _pg_data[_pg_byteindex] = (uint8_t)tablesProtection << 6;

    // Protection level for the RPM controller configuration data
    _pg_data[_pg_byteindex] |= (uint8_t)governorProtection << 4;

    // Protection level for the throttle configuration data
    _pg_data[_pg_byteindex] |= (uint8_t)throttleProtection << 2;

    // Protection level for the engine configuration data
    _pg_data[_pg_byteindex] |= (uint8_t)engineProtection;

    // Protection level for the injector configuration data
    _pg_data[_pg_byteindex + 1] = (uint8_t)injectorProtection << 6;

    // Protection level for the pump configuration data
    _pg_data[_pg_byteindex + 1] |= (uint8_t)pumpProtection << 4;

    // Protection level for all sensor configuration data
    _pg_data[_pg_byteindex + 1] |= (uint8_t)sensorsProtection << 2;

    // Protection level for the communications configuration data
    _pg_data[_pg_byteindex + 1] |= (uint8_t)commsProtection;

    // Protection level for the maintenance and logbook data
    _pg_data[_pg_byteindex + 2] = (uint8_t)maintenanceProtection << 6;

    // Protection level for the cooling configuration data
    _pg_data[_pg_byteindex + 2] |= (uint8_t)coolingProtection << 4;

    // Reserved bits in the packet
    _pg_data[_pg_byteindex + 3] = 0;

    _pg_byteindex += 4; // close bit field


    uint32ToBeBytes((uint32_t)(0), _pg_data, &_pg_byteindex);

    uint32ToBeBytes((uint32_t)(0), _pg_data, &_pg_byteindex);

    // Password for unlocking. This can be an empty string in which case no password is needed for unlocking. Requesting this packet will always return an empty string for the password.
    stringToBytes(password, _pg_data, &_pg_byteindex, 32, 0);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiLockControl_t::encode

/*!
 * \brief Decode the efiLockControl packet
 *
 * This packet is used to lock the configuration and set the unlock password.
 * Each time the EFI starts the configuration is automaticaly locked and cannot
 * be changed unless the [unlock](#EFI_PKT_UNLOCK) command is given. EFI
 * locking has three levels: [`EFI_LCK_LOCKED`](#efiunlocklevels),
 * [`EFI_LCK_PARTIAL_UNLOCKED`](#efiunlocklevels), and
 * [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels).
 * 
 * For each set of configuration data (tables, governor, throttle, engine,
 * pump, sensors, comms) this packet specifies the behavior of the protections
 * when the password *has not yet been supplied*. There are three options:
 * read/write, read only, and hidden. When configuration data are read/write
 * the data can be requested when the efi is locked, and can be changed when
 * the efi unlock level is [`EFI_LCK_PARTIAL_UNLOCKED`](#efiunlocklevels). When
 * configuration data are read only the data can be requested when the efi is
 * locked, but changing the data requires unlocking with the password. When
 * configuration data are hidden the data cannot be requested or changed
 * without unlocking using the password.
 * 
 * Upon receipt of this packet, if the EFI is currently unlocked, the
 * configuration will be locked. The lock control configuration data are always
 * protected at the read only level: therefore you can always request the lock
 * control configuration but you cannot change it without doing a password
 * unlock. Note that when sent from the EFI this packet will never include the
 * password.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiLockControl_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Protection level for all the table configuration data
    tablesProtection = (efiprotectionlevels)(_pg_data[_pg_byteindex] >> 6);

    // Protection level for the RPM controller configuration data
    governorProtection = (efiprotectionlevels)((_pg_data[_pg_byteindex] >> 4) & 0x3);

    // Protection level for the throttle configuration data
    throttleProtection = (efiprotectionlevels)((_pg_data[_pg_byteindex] >> 2) & 0x3);

    // Protection level for the engine configuration data
    engineProtection = (efiprotectionlevels)((_pg_data[_pg_byteindex]) & 0x3);

    // Protection level for the injector configuration data
    injectorProtection = (efiprotectionlevels)(_pg_data[_pg_byteindex + 1] >> 6);

    // Protection level for the pump configuration data
    pumpProtection = (efiprotectionlevels)((_pg_data[_pg_byteindex + 1] >> 4) & 0x3);

    // Protection level for all sensor configuration data
    sensorsProtection = (efiprotectionlevels)((_pg_data[_pg_byteindex + 1] >> 2) & 0x3);

    // Protection level for the communications configuration data
    commsProtection = (efiprotectionlevels)((_pg_data[_pg_byteindex + 1]) & 0x3);

    // Protection level for the maintenance and logbook data
    maintenanceProtection = (efiprotectionlevels)(_pg_data[_pg_byteindex + 2] >> 6);

    // Protection level for the cooling configuration data
    coolingProtection = (efiprotectionlevels)((_pg_data[_pg_byteindex + 2] >> 4) & 0x3);

    // Reserved bits in the packet
    _pg_byteindex += 4; // close bit field

    // Skip over reserved space
    _pg_byteindex += 4;

    // Skip over reserved space
    _pg_byteindex += 4;

    // Password for unlocking. This can be an empty string in which case no password is needed for unlocking. Requesting this packet will always return an empty string for the password.
    stringFromBytes(password, _pg_data, &_pg_byteindex, 32, 0);

    return true;

}// efiLockControl_t::decode

/*!
 * \brief Create the efiConfigHash packet
 *
 * Send this packet to mark the current configuration as valid. Upon receipt of
 * this packet, if the EFI is unlocked, a parameter hash of the configuration
 * will be computed and stored. The EFI maintains a hash of the actual
 * configuration which is compared with the stored value, generating a
 * parameter mismatch error if the two values are different. In addition, if a
 * hash is computed and stored, the EFI will be locked.
 * 
 * When sending this packet to the EFI the values `storedParameterHash` and
 * `actualParameterHash` are used as a command flag. Setting these to
 * `0x00000000` and `0xFFFFFFFF` respectively will cause the EFI to disable the
 * parameter mismatch check (and the EFI will not be locked). Any other value
 * results in the computation and storage of the parameter hash, triggering the
 * parameter mismatch check.
 * 
 * When this packet comes from the EFI `storedParameterHash` will be
 * `0x00000000` if the parameter mismatch check is disabled. If you change the
 * EFI configuration (by sending a configuration packet) the EFI will recompute
 * and resend the new configuration hash the next time it outputs slow
 * telemetry. Alternatively you can request the configuration hash packet to
 * get the updated `actualParameterHash`.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiConfigHash_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Parameter hash that was stored the last time this packet was sent to the EFI, for packets coming from the EFI. If this value is zero the parameter mismatch check is not being performed.
    // Range of storedParameterHash is 0 to -2147483648.
    uint32ToBeBytes(storedParameterHash, _pg_data, &_pg_byteindex);

    // The parameter hash that was computed from the stored configuration. This value is ignored for packets going to the EFI, it is available only on request.
    // Range of actualParameterHash is 0 to -2147483648.
    uint32ToBeBytes(actualParameterHash, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiConfigHash_t::encode

/*!
 * \brief Decode the efiConfigHash packet
 *
 * Send this packet to mark the current configuration as valid. Upon receipt of
 * this packet, if the EFI is unlocked, a parameter hash of the configuration
 * will be computed and stored. The EFI maintains a hash of the actual
 * configuration which is compared with the stored value, generating a
 * parameter mismatch error if the two values are different. In addition, if a
 * hash is computed and stored, the EFI will be locked.
 * 
 * When sending this packet to the EFI the values `storedParameterHash` and
 * `actualParameterHash` are used as a command flag. Setting these to
 * `0x00000000` and `0xFFFFFFFF` respectively will cause the EFI to disable the
 * parameter mismatch check (and the EFI will not be locked). Any other value
 * results in the computation and storage of the parameter hash, triggering the
 * parameter mismatch check.
 * 
 * When this packet comes from the EFI `storedParameterHash` will be
 * `0x00000000` if the parameter mismatch check is disabled. If you change the
 * EFI configuration (by sending a configuration packet) the EFI will recompute
 * and resend the new configuration hash the next time it outputs slow
 * telemetry. Alternatively you can request the configuration hash packet to
 * get the updated `actualParameterHash`.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiConfigHash_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Parameter hash that was stored the last time this packet was sent to the EFI, for packets coming from the EFI. If this value is zero the parameter mismatch check is not being performed.
    // Range of storedParameterHash is 0 to -2147483648.
    storedParameterHash = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // The parameter hash that was computed from the stored configuration. This value is ignored for packets going to the EFI, it is available only on request.
    // Range of actualParameterHash is 0 to -2147483648.
    actualParameterHash = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return true;

}// efiConfigHash_t::decode

/*!
 * \brief Create the efiPumpConfiguration packet
 *
 * Configuration information for the fuel pump control. The fuel pump can be
 * controlled using bang-bang feedback, or proportional-integral (PI) feedback.
 * Bang-bang feedback simply toggles between minimum and maximum pump duty
 * cycle based on comparing the fuel pressure error with the
 * `fuelPressureBangBangThreshold`. In PI feedback the pump duty cycle is
 * controlled using proportional and integral feedback of fuel pressure error
 * combined with feedforward of fuel flow rate. The current fuel pump duty
 * cycle is visible in the [slow telemetry](#EFI_PKT_TELEMETRYSLOW) packet.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiPumpConfiguration_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;
    unsigned _pg_i = 0;

    // Desired fuel pressure in kilo-Pascals.
    // Range of fuelPressureCmd is 0.0 to 1310.7.
    float32ScaledTo2UnsignedBeBytes(fuelPressureCmd, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    // Fuel pressures in kilo-Pascals relative to the fuelPressureCmd which is used to define a fuel pressure error (too low or too high)
    // Range of fuelPressureErrorThreshold is 0.0 to 262.14.
    float32ScaledTo2UnsignedBeBytes(fuelPressureErrorThreshold, _pg_data, &_pg_byteindex, 0.0f, 250.0f);

    // Minimum pump output duty cycle in percent.
    // Range of minDutyCycle is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(minDutyCycle, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Maximum pump output duty cycle in percent.
    // Range of maxDutyCycle is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(maxDutyCycle, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Fuel pressure error threshold in kilo-Pascals for bang-bang pump control. If this is non-zero the fuel pump is controlled by bang-bang feedback.
    // Range of fuelPressureBangBangThreshold is 0.0 to 262.14.
    float32ScaledTo2UnsignedBeBytes(fuelPressureBangBangThreshold, _pg_data, &_pg_byteindex, 0.0f, 250.0f);

    // Feedback gain from fuel pressure error (in kilo-Pascals) to fuel pump duty cycle in percent. Must be positive.
    // Range of proGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)proGain, _pg_data, &_pg_byteindex, 10);

    // Feedback gain from fuel pressure error integral (in kilo-Pascals-seconds) to fuel pump duty cycle in percent. Must be positive.
    // Range of intGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)intGain, _pg_data, &_pg_byteindex, 10);

    // Feedforward gain from fuel flow rate in grams per minute to fuel pump duty cycle in percent. Must be positive.
    // Range of forGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)forGain, _pg_data, &_pg_byteindex, 10);

    // If set the fuel pump output will remain at 0% until a non-zero engine speed is detected. If clear the pump is allowed to run even if the engine is not running.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(rpmEnablesPump, 1) << 7;

    // The amount of time, in seconds, the pump is allowed to run to prime the fuel system. If `rpmEnablesPump` is set, and if the RPM is zero, the pump will be allowed to run until 'primeTime' seconds have elapsed. If `rpmEnablesPump` is clear `primeTime` will do nothing.
    // Range of primeTime is 0 to 127.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(primeTime, 127);

    // If set the fuel pump output will be `maxDutyCycle` if the fuel pressure sensor is failed. Otherwise the pump output will be set according to the feedforward gain.
    _pg_data[_pg_byteindex + 1] = (uint8_t)limitMax(maxIfFailure, 1) << 7;

    _pg_byteindex += 2; // close bit field


    for(_pg_i = 0; _pg_i < 3; _pg_i++)
        uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // Rate limit on pump output, if the output is increasing, in units of % duty cycle per second. 0 will disable the positive rate limiter.
    // Range of positiveRateLimit is 0.0 to 12750.0.
    float32ScaledTo1UnsignedBytes(positiveRateLimit, _pg_data, &_pg_byteindex, 0.0f, 0.02f);

    // Rate limit on pump output, if the output is decreasing, in units of % duty cycle per second. 0 will disable the negative rate limiter.
    // Range of negativeRateLimit is 0.0 to 12750.0.
    float32ScaledTo1UnsignedBytes(negativeRateLimit, _pg_data, &_pg_byteindex, 0.0f, 0.02f);

    // Deprecated rate limit on pump output in units of % duty cycle per second. 0 will disable the positive rate limiter. This field will only be used if it is positive and `positiveRateLimit` and `negativeRateLimit` are zero.
    float32ScaledTo1UnsignedBytes(0, _pg_data, &_pg_byteindex, 0.0f, 0.2f);


    _pg_data[_pg_byteindex] = 0;

    // Fuel pump PWM period in microseconds.
    // Range of pwmPeriod is 20 to 16403.
    _pg_tempbitfield = (unsigned int)uint16ScaledToBitfield(pwmPeriod, 20, 1, 14);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiPumpConfiguration_t::encode

/*!
 * \brief Decode the efiPumpConfiguration packet
 *
 * Configuration information for the fuel pump control. The fuel pump can be
 * controlled using bang-bang feedback, or proportional-integral (PI) feedback.
 * Bang-bang feedback simply toggles between minimum and maximum pump duty
 * cycle based on comparing the fuel pressure error with the
 * `fuelPressureBangBangThreshold`. In PI feedback the pump duty cycle is
 * controlled using proportional and integral feedback of fuel pressure error
 * combined with feedforward of fuel flow rate. The current fuel pump duty
 * cycle is visible in the [slow telemetry](#EFI_PKT_TELEMETRYSLOW) packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiPumpConfiguration_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    pwmPeriod = 1000;

    // Desired fuel pressure in kilo-Pascals.
    // Range of fuelPressureCmd is 0.0 to 1310.7.
    fuelPressureCmd = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Fuel pressures in kilo-Pascals relative to the fuelPressureCmd which is used to define a fuel pressure error (too low or too high)
    // Range of fuelPressureErrorThreshold is 0.0 to 262.14.
    fuelPressureErrorThreshold = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/250.0f);

    // Minimum pump output duty cycle in percent.
    // Range of minDutyCycle is 0.0 to 127.5.
    minDutyCycle = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Maximum pump output duty cycle in percent.
    // Range of maxDutyCycle is 0.0 to 127.5.
    maxDutyCycle = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Fuel pressure error threshold in kilo-Pascals for bang-bang pump control. If this is non-zero the fuel pump is controlled by bang-bang feedback.
    // Range of fuelPressureBangBangThreshold is 0.0 to 262.14.
    fuelPressureBangBangThreshold = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/250.0f);

    // Feedback gain from fuel pressure error (in kilo-Pascals) to fuel pump duty cycle in percent. Must be positive.
    // Range of proGain is -65504.0 to 65504.0.
    proGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedback gain from fuel pressure error integral (in kilo-Pascals-seconds) to fuel pump duty cycle in percent. Must be positive.
    // Range of intGain is -65504.0 to 65504.0.
    intGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedforward gain from fuel flow rate in grams per minute to fuel pump duty cycle in percent. Must be positive.
    // Range of forGain is -65504.0 to 65504.0.
    forGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // If set the fuel pump output will remain at 0% until a non-zero engine speed is detected. If clear the pump is allowed to run even if the engine is not running.
    rpmEnablesPump = (_pg_data[_pg_byteindex] >> 7);

    // The amount of time, in seconds, the pump is allowed to run to prime the fuel system. If `rpmEnablesPump` is set, and if the RPM is zero, the pump will be allowed to run until 'primeTime' seconds have elapsed. If `rpmEnablesPump` is clear `primeTime` will do nothing.
    // Range of primeTime is 0 to 127.
    primeTime = ((_pg_data[_pg_byteindex]) & 0x7F);

    // If set the fuel pump output will be `maxDutyCycle` if the fuel pressure sensor is failed. Otherwise the pump output will be set according to the feedforward gain.
    maxIfFailure = (_pg_data[_pg_byteindex + 1] >> 7);

    _pg_byteindex += 2; // close bit field

    // Skip over reserved space
    _pg_byteindex += 1*3;

    // Rate limit on pump output, if the output is increasing, in units of % duty cycle per second. 0 will disable the positive rate limiter.
    // Range of positiveRateLimit is 0.0 to 12750.0.
    positiveRateLimit = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.02f);

    // Rate limit on pump output, if the output is decreasing, in units of % duty cycle per second. 0 will disable the negative rate limiter.
    // Range of negativeRateLimit is 0.0 to 12750.0.
    negativeRateLimit = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.02f);

    // Deprecated rate limit on pump output in units of % duty cycle per second. 0 will disable the positive rate limiter. This field will only be used if it is positive and `positiveRateLimit` and `negativeRateLimit` are zero.
    // Range of _outputRateLimit is 0.0 to 1275.0.
    _outputRateLimit = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.2f);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return 1;

    // Fuel pump PWM period in microseconds.
    // Range of pwmPeriod is 20 to 16403.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    pwmPeriod = (20 + _pg_tempbitfield);
    _pg_byteindex += 2; // close bit field

    return true;

}// efiPumpConfiguration_t::decode

/*!
 * \brief Encode a efiCANconfig_t into a byte array
 *
 * Configuration data for CAN communciations
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiCANconfig_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Baud rate enumeration for the CAN bus
    _pg_data[_pg_byteindex] = (uint8_t)baud << 5;

    // The bit number of the least significant bit of the packet type ([efiPacketIds](#efiPacketIds)) in the native protocol CAN ID. This is the number of bits that the packet type will be left shifted to place it into the CAN ID.
    // Range of typeShift is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(typeShift, 31);

    // Set this bit to use 29-bit identifiers in the native protocol, else the CAN bus will use 11-bit identifiers.
    _pg_data[_pg_byteindex + 1] = (uint8_t)limitMax(longid, 1) << 7;

    // Set this bit to disable receipt of native protocol CAN communications (inputBaseId is don't care).
    _pg_data[_pg_byteindex + 1] |= (uint8_t)disableNativeInput << 5;

    // The base value used to form the CAN identifier for input CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value.
    // Range of inputBaseId is 0 to 536870911.
    _pg_tempbitfield = (unsigned int)limitMax(inputBaseId, 536870911);
    _pg_data[_pg_byteindex + 4] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;

    _pg_data[_pg_byteindex + 5] = 0;

    // Set this bit to disable transmission of native protocol CAN communications.
    _pg_data[_pg_byteindex + 5] |= (uint8_t)disableNativeOutput << 5;

    // The base value used to form the CAN identifier for outputput CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value.
    // Range of outputBaseId is 0 to 536870911.
    _pg_tempbitfield = (unsigned int)limitMax(outputBaseId, 536870911);
    _pg_data[_pg_byteindex + 8] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 7] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 6] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 5] |= (uint8_t)_pg_tempbitfield;

    _pg_data[_pg_byteindex + 9] = 0;

    // Set this bit to disable receipt of native protocol broadcast CAN communications (broadcastBaseId is don't care).
    _pg_data[_pg_byteindex + 9] |= (uint8_t)disableNativeBroadcast << 5;

    // The base value used to form the CAN identifier for broadcast input CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value.
    // Range of broadcastBaseId is 0 to 536870911.
    _pg_tempbitfield = (unsigned int)limitMax(broadcastBaseId, 536870911);
    _pg_data[_pg_byteindex + 12] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 11] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 10] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 9] |= (uint8_t)_pg_tempbitfield;

    // Set this bit to force the system to use *only* the Packet-over-CAN schema, even for packets that have 8 or less bytes of data. This option is not recommended unless the EFI must be limited to a single identifier on the CAN bus. When this option is set the EFI will only output CAN frames that match exactly the `outputBaseId`, and will only accept CAN frames that exactly match the `inputBaseId` or the `broadcastBaseId`.
    _pg_data[_pg_byteindex + 13] = (uint8_t)forcePacketOverCAN << 7;

    // Set this bit to limit the CAN bus to command and telemetry messages only. Attempts to request or change configuration using the CAN bus will be ignored. Packet-over-CAN will not be used since all remaining packets have 8 or less bytes of data (unless `forcePacketOverCAN` is set).
    _pg_data[_pg_byteindex + 13] |= (uint8_t)cmdAndTmOnly << 6;

    // Set this bit to enable receive of the Generator Control Unit telemetry (Northwest or Millswood). This can be enabled simultaneously with the other alternative protocols.
    _pg_data[_pg_byteindex + 13] |= (uint8_t)enableGCU << 2;

    // Set this bit to emulate the Performance Electronics PE3 ECU CAN interface. This can be set at the same time as `enablePiccoloECU`
    _pg_data[_pg_byteindex + 13] |= (uint8_t)enablePE3ECU << 1;

    // Set this bit to emulate the Currawong ECU CAN interface.
    _pg_data[_pg_byteindex + 13] |= (uint8_t)enableCurrawongECU;

    // Set this bit to enable support for the Piccolo ECU CAN interface.
    _pg_data[_pg_byteindex + 14] = (uint8_t)enablePiccoloECU << 7;

    _pg_byteindex += 15; // close bit field

    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // The 16-bit address to use with either the Currawong ECU or Piccolo ECU protocols. This address applies to Currawong ECU over serial as well as CAN
    // Range of alternativeProtocolAddress is 0 to 65535.
    uint16ToBeBytes(alternativeProtocolAddress, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// efiCANconfig_t::encode

/*!
 * \brief Decode a efiCANconfig_t from a byte array
 *
 * Configuration data for CAN communciations
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiCANconfig_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Baud rate enumeration for the CAN bus
    baud = (CANBaudEnums)(_pg_data[_pg_byteindex] >> 5);

    // The bit number of the least significant bit of the packet type ([efiPacketIds](#efiPacketIds)) in the native protocol CAN ID. This is the number of bits that the packet type will be left shifted to place it into the CAN ID.
    // Range of typeShift is 0 to 31.
    typeShift = ((_pg_data[_pg_byteindex]) & 0x1F);

    // Set this bit to use 29-bit identifiers in the native protocol, else the CAN bus will use 11-bit identifiers.
    longid = (_pg_data[_pg_byteindex + 1] >> 7);

    // Set this bit to disable receipt of native protocol CAN communications (inputBaseId is don't care).
    disableNativeInput = ((_pg_data[_pg_byteindex + 1] >> 5) & 0x1);

    // The base value used to form the CAN identifier for input CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value.
    // Range of inputBaseId is 0 to 536870911.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0x1F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 4];

    inputBaseId = _pg_tempbitfield;

    // Set this bit to disable transmission of native protocol CAN communications.
    disableNativeOutput = ((_pg_data[_pg_byteindex + 5] >> 5) & 0x1);

    // The base value used to form the CAN identifier for outputput CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value.
    // Range of outputBaseId is 0 to 536870911.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 5] & 0x1F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 6];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 7];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 8];

    outputBaseId = _pg_tempbitfield;

    // Set this bit to disable receipt of native protocol broadcast CAN communications (broadcastBaseId is don't care).
    disableNativeBroadcast = ((_pg_data[_pg_byteindex + 9] >> 5) & 0x1);

    // The base value used to form the CAN identifier for broadcast input CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value.
    // Range of broadcastBaseId is 0 to 536870911.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 9] & 0x1F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 10];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 11];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 12];

    broadcastBaseId = _pg_tempbitfield;

    // Set this bit to force the system to use *only* the Packet-over-CAN schema, even for packets that have 8 or less bytes of data. This option is not recommended unless the EFI must be limited to a single identifier on the CAN bus. When this option is set the EFI will only output CAN frames that match exactly the `outputBaseId`, and will only accept CAN frames that exactly match the `inputBaseId` or the `broadcastBaseId`.
    forcePacketOverCAN = (_pg_data[_pg_byteindex + 13] >> 7);

    // Set this bit to limit the CAN bus to command and telemetry messages only. Attempts to request or change configuration using the CAN bus will be ignored. Packet-over-CAN will not be used since all remaining packets have 8 or less bytes of data (unless `forcePacketOverCAN` is set).
    cmdAndTmOnly = ((_pg_data[_pg_byteindex + 13] >> 6) & 0x1);

    // Set this bit to enable receive of the Generator Control Unit telemetry (Northwest or Millswood). This can be enabled simultaneously with the other alternative protocols.
    enableGCU = ((_pg_data[_pg_byteindex + 13] >> 2) & 0x1);

    // Set this bit to emulate the Performance Electronics PE3 ECU CAN interface. This can be set at the same time as `enablePiccoloECU`
    enablePE3ECU = ((_pg_data[_pg_byteindex + 13] >> 1) & 0x1);

    // Set this bit to emulate the Currawong ECU CAN interface.
    enableCurrawongECU = ((_pg_data[_pg_byteindex + 13]) & 0x1);

    // Set this bit to enable support for the Piccolo ECU CAN interface.
    enablePiccoloECU = (_pg_data[_pg_byteindex + 14] >> 7);

    _pg_byteindex += 15; // close bit field

    // Skip over reserved space
    _pg_byteindex += 1;

    // The 16-bit address to use with either the Currawong ECU or Piccolo ECU protocols. This address applies to Currawong ECU over serial as well as CAN
    // Range of alternativeProtocolAddress is 0 to 65535.
    alternativeProtocolAddress = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiCANconfig_t::decode

/*!
 * \brief Create the efiCommConfiguration packet
 *
 * Configuration information for communications, including Controller Area
 * Network (CAN) setup, Universal Asynchronous Receiver Transmitter (UART) baud
 * rate, and telemetry output options. If you select a baud rate (UART or CAN)
 * which is too low to accommodate the telemetry output rates, the rates will
 * be adjusted down until the expected bandwidth fits the available data rate.
 * If you select the option `setToDefault` the UART baud rate will be set to
 * 57600 bits per second, the fast telemetry rate will be 20Hz, and the slow
 * telemetry rate will be 1Hz.
 * 
 * The CAN configuration supports multiple options and protocols. The primary
 * CAN protocol is the *native protocol*, which implements the packet-over-CAN
 * schema to move packets as documented in this ICD. The native protocol
 * includes input and output base identifiers, as well as a broadcast
 * identifier. The input and output identifier must be unique on the CAN bus;
 * but the broadcast identifier can be common with other EFIs on the bus. If
 * you select the option `setToDefault` the native protocol will be configured
 * to run at 1Mbit, with long identifiers, a type shift of 16 bits, an input
 * identifier of `0x1E00xxxx`, and an output identifier of `0x1F00xxxx` (where
 * `xxxx` are the lower 16 bits of the EFI serial number).
 * 
 * In addition to the native communications protocol three other protocols are
 * supported (Currawong, Piccolo, Performance Electronics). If you set
 * `enableCurrawongECU` the EFI will emulate the communications protocol used
 * by the [CE367
 * ECU](http://www.currawongeng.com/uav-engines/engine-control-unit/) from
 * Currawong Engineering. The emulation of this interface includes telemetry,
 * commands, and configuration packets, see the Currawong ECU ICD for details.
 * The `enableCurrawongECU` bit is an option for both the UART and the CAN
 * interface. On the UART interface the Currawong protocol runs at 57600 bits
 * per second, and runs simultaneously with the native protocol (the EFI
 * discriminates based on the packet format). The EFI will use the
 * `alternativeProtocolAddress` for the address field in the Currawong serial
 * packet. When using `enableCurrawongECU` with the CAN interface the EFI will
 * generate CAN frames from `0x0800xxxx` through `0x0818xxxx` (where `xxxx` are
 * the `alternativeProtocolAddress`), and will process CAN frames from
 * `0x0900xxxx` through `0x0918xxxx` (where `xxxx` are
 * `alternativeProtocolAddress`, or `0xFFFF`).
 * 
 * The second alternative protocol is enabled with the option
 * `enablePiccoloECU`. This protocol is only available on the CAN bus. You
 * cannot simultaneously set `enablePiccoloECU` and `enableCurrawongECU` on the
 * CAN bus, if you do the EFI will negate `enablePiccoloECU`. When using
 * `enablePiccoloECU` the EFI will generate CAN frames from `0x0880xxxx`
 * through `0x0884xxxx` (where `xxxx` are the `alternativeProtocolAddress`),
 * and will process CAN frames from `0x0990xxxx` through `0x0991xxxx` (where
 * `xxxx` are the `alternativeProtocolAddress`, or `0xFFFF`). Details of this
 * protocool can be had in the Piccolo communications ICD. The [Piccolo
 * autopilot](http://www.cloudcaptech.com/products/auto-pilots) CAN bus can
 * work with either the Piccolo ECU or the Currawong ECU protocol. When using
 * either protocol the CAN baud rate will be forced to 1Mbit, and the
 * `outputBaseID` and `inputBaseID` must *not* be `0x08xxxxxx` or `0x09xxxx`,
 * or the native output and input should be disabled.
 * 
 * The third alternative protocol is enabled with the option `enablePE3ECU`.
 * This is an output only protocol that emulates the CAN bus outputs of the
 * Performance Electronics PE3 ECU. You can use the `enablePE3ECU`
 * simultaneously with `enablePiccoloECU`, but not with `enableCurrawongECU` on
 * the CAN bus. The PE3 protocol option does not force the CAN baud rate, and
 * it does not follow the fast and slow telemetry rates; instead using the
 * telemetry rates specified by the Performance Electronics protocol (20Hz,
 * 10Hz, and 1Hz).
 * 
 * The fourth alternative protocol is enabled with the option `enableGCU`. This
 * is a CAN bus protocol which should be enabled if you want to decode
 * telemetry from the Northwest or Millswood generator control unit. This
 * protocol can be enabled with all other protocols and does not force the CAN
 * baud rate. If this protocol is enabled, and if a GCU is sending telemetry on
 * the CAN bus, IntelliJect will parse the telemetry data and forward it using
 * the [TelemetryGCU packet](#EFI_PKT_TELEMETRYGCU).
 * 
 * When using the Currawong, Piccolo, or PE3 alternative protocols the EFI will
 * suppress the native protocol telemetry output on the interface. However if a
 * native protocol packet is received on the interface the EFI will resume
 * output of the native protocol telemetry.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiCommConfiguration_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // If set SD card recording will be disabled all the time, even if the engine is running.
    _pg_data[_pg_byteindex] = (uint8_t)disableSDRecording << 7;

    // SD recording rate for fast telemetry.
    // Range of fastTelemetrySDRate is 0 to 127.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(fastTelemetrySDRate, 127);
    _pg_byteindex += 1; // close bit field


    // Output rate for fast telemetry.
    // Range of fastTelemetryRate is 0 to 255.
    uint8ToBytes(fastTelemetryRate, _pg_data, &_pg_byteindex);

    // If set SD card recording will be enabled all the time, even if the engine is not running.
    _pg_data[_pg_byteindex] = (uint8_t)recordSDAlways << 7;

    // SD recording rate for slow telemetry.
    // Range of slowTelemetrySDRate is 0 to 127.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(slowTelemetrySDRate, 127);
    _pg_byteindex += 1; // close bit field


    // Output rate for slow telemetry.
    // Range of slowTelemetryRate is 0 to 255.
    uint8ToBytes(slowTelemetryRate, _pg_data, &_pg_byteindex);

    // Set this bit to use summary packets for the telemetry on non-CAN interfaces.
    _pg_data[_pg_byteindex] = (uint8_t)useSummaryPackets << 7;


    // Set this bit to configure all communications for default settings. If this bit is set all other fields are ignored when this packet is sent to the EFI.
    _pg_data[_pg_byteindex] |= (uint8_t)setToDefault << 5;

    // Set this bit to emulate the Currawong ECU Serial interface. If this is set the regular telemetry output in native packet format is suppressed, and the `uartBaud` is forced to 57600.
    _pg_data[_pg_byteindex] |= (uint8_t)enableCurrawongECU << 4;


    // Baud rate for the UART in units of bits per second
    // Range of uartBaud is 0.0 to 1227600.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)uartBaud, 0.0f, 0.000833333333f, 10);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field


    // Configuration data for CAN communciations
    CANconfig.encode(_pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiCommConfiguration_t::encode

/*!
 * \brief Decode the efiCommConfiguration packet
 *
 * Configuration information for communications, including Controller Area
 * Network (CAN) setup, Universal Asynchronous Receiver Transmitter (UART) baud
 * rate, and telemetry output options. If you select a baud rate (UART or CAN)
 * which is too low to accommodate the telemetry output rates, the rates will
 * be adjusted down until the expected bandwidth fits the available data rate.
 * If you select the option `setToDefault` the UART baud rate will be set to
 * 57600 bits per second, the fast telemetry rate will be 20Hz, and the slow
 * telemetry rate will be 1Hz.
 * 
 * The CAN configuration supports multiple options and protocols. The primary
 * CAN protocol is the *native protocol*, which implements the packet-over-CAN
 * schema to move packets as documented in this ICD. The native protocol
 * includes input and output base identifiers, as well as a broadcast
 * identifier. The input and output identifier must be unique on the CAN bus;
 * but the broadcast identifier can be common with other EFIs on the bus. If
 * you select the option `setToDefault` the native protocol will be configured
 * to run at 1Mbit, with long identifiers, a type shift of 16 bits, an input
 * identifier of `0x1E00xxxx`, and an output identifier of `0x1F00xxxx` (where
 * `xxxx` are the lower 16 bits of the EFI serial number).
 * 
 * In addition to the native communications protocol three other protocols are
 * supported (Currawong, Piccolo, Performance Electronics). If you set
 * `enableCurrawongECU` the EFI will emulate the communications protocol used
 * by the [CE367
 * ECU](http://www.currawongeng.com/uav-engines/engine-control-unit/) from
 * Currawong Engineering. The emulation of this interface includes telemetry,
 * commands, and configuration packets, see the Currawong ECU ICD for details.
 * The `enableCurrawongECU` bit is an option for both the UART and the CAN
 * interface. On the UART interface the Currawong protocol runs at 57600 bits
 * per second, and runs simultaneously with the native protocol (the EFI
 * discriminates based on the packet format). The EFI will use the
 * `alternativeProtocolAddress` for the address field in the Currawong serial
 * packet. When using `enableCurrawongECU` with the CAN interface the EFI will
 * generate CAN frames from `0x0800xxxx` through `0x0818xxxx` (where `xxxx` are
 * the `alternativeProtocolAddress`), and will process CAN frames from
 * `0x0900xxxx` through `0x0918xxxx` (where `xxxx` are
 * `alternativeProtocolAddress`, or `0xFFFF`).
 * 
 * The second alternative protocol is enabled with the option
 * `enablePiccoloECU`. This protocol is only available on the CAN bus. You
 * cannot simultaneously set `enablePiccoloECU` and `enableCurrawongECU` on the
 * CAN bus, if you do the EFI will negate `enablePiccoloECU`. When using
 * `enablePiccoloECU` the EFI will generate CAN frames from `0x0880xxxx`
 * through `0x0884xxxx` (where `xxxx` are the `alternativeProtocolAddress`),
 * and will process CAN frames from `0x0990xxxx` through `0x0991xxxx` (where
 * `xxxx` are the `alternativeProtocolAddress`, or `0xFFFF`). Details of this
 * protocool can be had in the Piccolo communications ICD. The [Piccolo
 * autopilot](http://www.cloudcaptech.com/products/auto-pilots) CAN bus can
 * work with either the Piccolo ECU or the Currawong ECU protocol. When using
 * either protocol the CAN baud rate will be forced to 1Mbit, and the
 * `outputBaseID` and `inputBaseID` must *not* be `0x08xxxxxx` or `0x09xxxx`,
 * or the native output and input should be disabled.
 * 
 * The third alternative protocol is enabled with the option `enablePE3ECU`.
 * This is an output only protocol that emulates the CAN bus outputs of the
 * Performance Electronics PE3 ECU. You can use the `enablePE3ECU`
 * simultaneously with `enablePiccoloECU`, but not with `enableCurrawongECU` on
 * the CAN bus. The PE3 protocol option does not force the CAN baud rate, and
 * it does not follow the fast and slow telemetry rates; instead using the
 * telemetry rates specified by the Performance Electronics protocol (20Hz,
 * 10Hz, and 1Hz).
 * 
 * The fourth alternative protocol is enabled with the option `enableGCU`. This
 * is a CAN bus protocol which should be enabled if you want to decode
 * telemetry from the Northwest or Millswood generator control unit. This
 * protocol can be enabled with all other protocols and does not force the CAN
 * baud rate. If this protocol is enabled, and if a GCU is sending telemetry on
 * the CAN bus, IntelliJect will parse the telemetry data and forward it using
 * the [TelemetryGCU packet](#EFI_PKT_TELEMETRYGCU).
 * 
 * When using the Currawong, Piccolo, or PE3 alternative protocols the EFI will
 * suppress the native protocol telemetry output on the interface. However if a
 * native protocol packet is received on the interface the EFI will resume
 * output of the native protocol telemetry.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiCommConfiguration_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // If set SD card recording will be disabled all the time, even if the engine is running.
    disableSDRecording = (_pg_data[_pg_byteindex] >> 7);

    // SD recording rate for fast telemetry.
    // Range of fastTelemetrySDRate is 0 to 127.
    fastTelemetrySDRate = ((_pg_data[_pg_byteindex]) & 0x7F);
    _pg_byteindex += 1; // close bit field

    // Output rate for fast telemetry.
    // Range of fastTelemetryRate is 0 to 255.
    fastTelemetryRate = uint8FromBytes(_pg_data, &_pg_byteindex);

    // If set SD card recording will be enabled all the time, even if the engine is not running.
    recordSDAlways = (_pg_data[_pg_byteindex] >> 7);

    // SD recording rate for slow telemetry.
    // Range of slowTelemetrySDRate is 0 to 127.
    slowTelemetrySDRate = ((_pg_data[_pg_byteindex]) & 0x7F);
    _pg_byteindex += 1; // close bit field

    // Output rate for slow telemetry.
    // Range of slowTelemetryRate is 0 to 255.
    slowTelemetryRate = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Set this bit to use summary packets for the telemetry on non-CAN interfaces.
    useSummaryPackets = (_pg_data[_pg_byteindex] >> 7);

    // Set this bit to configure all communications for default settings. If this bit is set all other fields are ignored when this packet is sent to the EFI.
    setToDefault = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set this bit to emulate the Currawong ECU Serial interface. If this is set the regular telemetry output in native packet format is suppressed, and the `uartBaud` is forced to 57600.
    enableCurrawongECU = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Baud rate for the UART in units of bits per second
    // Range of uartBaud is 0.0 to 1227600.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    uartBaud = (uint32_t)float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/0.000833333333f);
    _pg_byteindex += 2; // close bit field

    // Configuration data for CAN communciations
    if(CANconfig.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return true;

}// efiCommConfiguration_t::decode


/*!
 * \brief Lookup title for 'efiSensorEnum' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string title of the given entry (comment if no title given)
 */
const char* efiSensorEnum_EnumTitle(int value)
{
    switch (value)
    {
    default:
        return "";
    case EFI_SENSOR_VOLT:
        return translateeficomms("Input Voltage");
    case EFI_SENSOR_MAT:
        return translateeficomms("MAT");
    case EFI_SENSOR_CHT1:
        return translateeficomms("CHT1");
    case EFI_SENSOR_CHT2:
        return translateeficomms("CHT2");
    case EFI_SENSOR_MAP:
        return translateeficomms("MAP");
    case EFI_SENSOR_FUELP:
        return translateeficomms("Fuel pressure");
    case EFI_SENSOR_ANALOGTPS:
        return translateeficomms("Analog TPS");
    case EFI_SENSOR_CPUTEMP:
        return translateeficomms("CPU Temp");
    case EFI_SENSOR_SPARETEMP:
        return translateeficomms("Spare temp");
    case EFI_SENSOR_BARO:
        return translateeficomms("Digital Barometer");
    case EFI_SENSOR_OAT:
        return translateeficomms("Outside Air Temp");
    case EFI_SENSOR_CURRENT:
        return translateeficomms("Current");
    case EFI_SENSOR_12VOLT:
        return translateeficomms("12 Volts");
    case EFI_SENSOR_12CURRENT:
        return translateeficomms("12 Current");
    case EFI_SENSOR_ANALOGBARO:
        return translateeficomms("Analog Barometer");
    }
}

/*!
 * \brief Create the efiSensorConfiguration packet
 *
 * This packet gives configuration information for a single sensor. Send this
 * packet with just the first byte to request a specific sensor configuration.
 * Sensor configuration includes the sensor gain and offset, the minimum and
 * maximum sensor readings beyond which the sensor is considered bad, and the
 * default sensor value to use if the sensor is bad or disabled. If the sensor
 * is configured as a kty84 or kty83 temperature sensor the gain should be
 * nominally 1 and the offset nominally 0. If `enableAutocorrect` is set the
 * sensor's calibration will be automatically adjusted to correct errors (if
 * possible). The only automatically corrected sensor is the MAP sensor
 * (pressure offset is corrected against Baro when engine is off).
 * 
 * Sensor readings and error status are available in the [telemetry
 * packets](#telemetrypacketsoutputbyintelliject).
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiSensorConfiguration_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Set to 1 to enable this sensor, disabled sensors will use the `failedvalue` or be ignored
    _pg_data[_pg_byteindex] = (uint8_t)enabled << 7;

    // Set to 1 to indicate that this sensor is a KTY84 temperature sensor
    _pg_data[_pg_byteindex] |= (uint8_t)kty84 << 6;

    // Set to 1 to indicate this sensor is of the sealed gauge type. This only applies to the fuel pressure sensor. If clear the fuel pressure sensor is considered a normal gauge type.
    _pg_data[_pg_byteindex] |= (uint8_t)sealedGauge << 5;

    // The enumeration identifying the sensor to which this packet applies.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(sensor, EFI_SENSOR_MAXINDEX);
    _pg_byteindex += 1; // close bit field


    // Cutoff frequency for the low pass filter to apply to the sensor after conversion, 0 will disable the filter
    // Range of filterlpf is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(filterlpf, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Offset to be subtracted from the raw sensor reading, as a fraction of the sensor raw span
    // Range of offset is -1.0 to 1.0.
    float32ScaledTo2SignedBeBytes(offset, _pg_data, &_pg_byteindex, 32767.0f);

    // Gain of the sensor in output units per full scale range. Sensor output = gain(reading - offset).
    // Range of gain is -3.4028234663852886e+38 to 3.4028234663852886e+38.
    float32ToBeBytes((float)gain, _pg_data, &_pg_byteindex);

    // Sensor value to use if the sensor readings are out of range, or the sensor is disabled.
    // Range of failedvalue is -65504.0 to 65504.0.
    float16ToBeBytes((float)failedvalue, _pg_data, &_pg_byteindex, 10);

    // Minimum sensor value, values below this are out of range
    // Range of min is -65504.0 to 65504.0.
    float16ToBeBytes((float)min, _pg_data, &_pg_byteindex, 10);

    // Maximum sensor value, values above this are out of range
    // Range of max is -65504.0 to 65504.0.
    float16ToBeBytes((float)max, _pg_data, &_pg_byteindex, 10);

    // Set to 1 to indicate that this sensor is a KTY83 temperature sensor
    _pg_data[_pg_byteindex] = (uint8_t)kty83 << 7;

    // Set this bit to configure this sensor for default settings. All other settings in this packet will be ignored.
    _pg_data[_pg_byteindex] |= (uint8_t)setToDefault << 6;

    // Set this bit to perform a calibration for this sensor. This setting must be combined with `calibrateoffset` or `calibrategain` (but not both). This bit will never bet set when this packet comes from the EFI.
    _pg_data[_pg_byteindex] |= (uint8_t)calibrate << 5;

    // Set this bit to perform a zero calibration for this sensor. The offset of the sensor will be adjusted to make the sensor output match the calibration value. The `offset` field will be ignored in this case. This bit will never be set when this packet comes from the EFI.
    _pg_data[_pg_byteindex] |= (uint8_t)calibrateoffset << 4;

    // Set this bit to perform a gain calibration for this sensor. The gain of the sensor will be adjusted to make the sensor output match the calibration value. The `gain` field will be ignored in this case. This bit will never be set when this packet comes from the EFI.
    _pg_data[_pg_byteindex] |= (uint8_t)calibrategain << 3;

    // Set this bit to enable this sensor to be automatically corrected.
    _pg_data[_pg_byteindex] |= (uint8_t)enableAutocorrect << 2;

    // Set to 1 to indicate this sensor is a platinum RTD with a resistance of 1000 ohms at 0C. Offset should be set to 0, and the gain should be 1.0 if the TCR (Ohm/Ohm/C) of the sensor is 0.00385. Increase or decrease the gain to account for different TCR values.
    _pg_data[_pg_byteindex] |= (uint8_t)platinum1000rtd << 1;

    // Reserved space for future expansion
    _pg_data[_pg_byteindex + 1] = 0;

    _pg_byteindex += 2; // close bit field


    // The known sense value used with `calibrateoffset` or `calibrategain`.
    // Range of calibrationvalue is -3.4028234663852886e+38 to 3.4028234663852886e+38.
    if(calibrate)
    {
        float32ToBeBytes((float)calibrationvalue, _pg_data, &_pg_byteindex);
    }

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiSensorConfiguration_t::encode

/*!
 * \brief Decode the efiSensorConfiguration packet
 *
 * This packet gives configuration information for a single sensor. Send this
 * packet with just the first byte to request a specific sensor configuration.
 * Sensor configuration includes the sensor gain and offset, the minimum and
 * maximum sensor readings beyond which the sensor is considered bad, and the
 * default sensor value to use if the sensor is bad or disabled. If the sensor
 * is configured as a kty84 or kty83 temperature sensor the gain should be
 * nominally 1 and the offset nominally 0. If `enableAutocorrect` is set the
 * sensor's calibration will be automatically adjusted to correct errors (if
 * possible). The only automatically corrected sensor is the MAP sensor
 * (pressure offset is corrected against Baro when engine is off).
 * 
 * Sensor readings and error status are available in the [telemetry
 * packets](#telemetrypacketsoutputbyintelliject).
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiSensorConfiguration_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Set to 1 to enable this sensor, disabled sensors will use the `failedvalue` or be ignored
    enabled = (_pg_data[_pg_byteindex] >> 7);

    // Set to 1 to indicate that this sensor is a KTY84 temperature sensor
    kty84 = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set to 1 to indicate this sensor is of the sealed gauge type. This only applies to the fuel pressure sensor. If clear the fuel pressure sensor is considered a normal gauge type.
    sealedGauge = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // The enumeration identifying the sensor to which this packet applies.
    sensor = (efiSensorEnum)((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    // Cutoff frequency for the low pass filter to apply to the sensor after conversion, 0 will disable the filter
    // Range of filterlpf is 0.0 to 25.5.
    filterlpf = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Offset to be subtracted from the raw sensor reading, as a fraction of the sensor raw span
    // Range of offset is -1.0 to 1.0.
    offset = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/32767.0f);

    // Gain of the sensor in output units per full scale range. Sensor output = gain(reading - offset).
    // Range of gain is -3.4028234663852886e+38 to 3.4028234663852886e+38.
    gain = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Sensor value to use if the sensor readings are out of range, or the sensor is disabled.
    // Range of failedvalue is -65504.0 to 65504.0.
    failedvalue = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Minimum sensor value, values below this are out of range
    // Range of min is -65504.0 to 65504.0.
    min = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Maximum sensor value, values above this are out of range
    // Range of max is -65504.0 to 65504.0.
    max = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Set to 1 to indicate that this sensor is a KTY83 temperature sensor
    kty83 = (_pg_data[_pg_byteindex] >> 7);

    // Set this bit to configure this sensor for default settings. All other settings in this packet will be ignored.
    setToDefault = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set this bit to perform a calibration for this sensor. This setting must be combined with `calibrateoffset` or `calibrategain` (but not both). This bit will never bet set when this packet comes from the EFI.
    calibrate = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set this bit to perform a zero calibration for this sensor. The offset of the sensor will be adjusted to make the sensor output match the calibration value. The `offset` field will be ignored in this case. This bit will never be set when this packet comes from the EFI.
    calibrateoffset = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set this bit to perform a gain calibration for this sensor. The gain of the sensor will be adjusted to make the sensor output match the calibration value. The `gain` field will be ignored in this case. This bit will never be set when this packet comes from the EFI.
    calibrategain = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set this bit to enable this sensor to be automatically corrected.
    enableAutocorrect = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set to 1 to indicate this sensor is a platinum RTD with a resistance of 1000 ohms at 0C. Offset should be set to 0, and the gain should be 1.0 if the TCR (Ohm/Ohm/C) of the sensor is 0.00385. Increase or decrease the gain to account for different TCR values.
    platinum1000rtd = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Reserved space for future expansion
    _pg_byteindex += 2; // close bit field

    if(calibrate)
    {
        // The known sense value used with `calibrateoffset` or `calibrategain`.
        // Range of calibrationvalue is -3.4028234663852886e+38 to 3.4028234663852886e+38.
        calibrationvalue = float32FromBeBytes(_pg_data, &_pg_byteindex);
    }

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    return true;

}// efiSensorConfiguration_t::decode

/*!
 * \brief Verify a efiSensorConfiguration_t has acceptable values.
 *
 * Verify a efiSensorConfiguration_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \return true if all verifiable data where valid, else false if data had to be corrected
 */
bool efiSensorConfiguration_t::verify(void)
{
    bool _pg_good = true;

    // The enumeration identifying the sensor to which this packet applies.
    if(sensor > EFI_SENSOR_MAXINDEX)
    {
        sensor = EFI_SENSOR_MAXINDEX;
        _pg_good = false;
    }

    return _pg_good;

}// efiSensorConfiguration_t::verify

/*!
 * \brief Create the efiThrottleConfiguration packet
 *
 * Configuration information specific to the throttle. There are two possible
 * sources of throttle position sensing: The analog throttle sensor and the PWM
 * input. If the EFI is configured to drive the throttle (`efiDrivesThrottle`
 * is set) there are four possible sources of throttle command: The analog
 * throttle, the PWM input, the user command, or the RPM controller. In
 * addition, it is also possible to apply a throttle curve to convert the the
 * commanded throttle to the actual throttle. Finally, if the EFI is configured
 * to drive the throttle it is possible to *not* have a TPS sensor, in which
 * case the throttle position is assumed to be equal the throttle output by the
 * EFI.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiThrottleConfiguration_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // PWM in microseconds for 0% throttle output (for `efiDrivesThrottle`)
    // Range of closedPWMoutput is 0 to 65535.
    uint16ToBeBytes(closedPWMoutput, _pg_data, &_pg_byteindex);

    // PWM in microseconds for 100% throttle output (for `efiDrivesThrottle`)
    // Range of openPWMoutput is 0 to 65535.
    uint16ToBeBytes(openPWMoutput, _pg_data, &_pg_byteindex);

    // Cutoff frequency for the low pass filter to apply to the throttle input, 0 will disable the filter. This filter always applies to TPS as well as command inputs. This filter supercedes the filter on the analog throttle sensor configuration.
    // Range of inputfilterlpf is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(inputfilterlpf, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Rate limit on throttle output, in units of % throttle per second. 0 will disable the rate limiter.
    // Range of outputRateLimit is 0.0 to 1275.0.
    float32ScaledTo1UnsignedBytes(outputRateLimit, _pg_data, &_pg_byteindex, 0.0f, 0.2f);

    // Set to enable the use of the analog throttle input as a throttle command (only valid if `efiDrivesThrottle` is set).
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(enableAnalogCmd, 1) << 7;

    // Set to enable the use of the PWM input as a throttle command (only valid if `efiDrivesThrottle` is set).
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enablePWMCmd, 1) << 6;

    // Set if the EFI is driving the throttle (through PWM out or CAN).
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(efiDrivesThrottle, 1) << 5;

    // Set to enable the use of the analog throttle input as a throttle position sensor. This cannot be set simultaneously with `enableAnalogCmd`.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enableAnalogTPS, 1) << 4;

    // Set to enable the use of the PWM throttle input as a throttle position sensor. This cannot be set simultaneously with `enablePWMCmd`.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enablePWMTPS, 1) << 3;

    // Deprecated for api 7.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(_enableCECANServo, 1) << 2;

    // Set to enable the CAN servo position feedback as a throttle position sensor.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enableCECANTPS, 1) << 1;

    // Set to enable the manifold pressure (plus the MAP estimate table) as a throttle position sensor.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enableMAPTPS, 1);
    _pg_byteindex += 1; // close bit field


    // The throttle curve relating throttle inputs to outputs. This can be disabled using the curve.enabled bit. The curve.indices are percent throttle input, and the curve.data are percent throttle output.
    curve.encode(_pg_data, &_pg_byteindex);

    // Throttle percentage used to start the engine in percent. If there is no valid throttle command, this is used to set the throttle position.
    // Range of startThrottle is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(startThrottle, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Address, from 1 to 254, that identifies a Currawong Engineering CAN servo used for the throttle control if `efiDrivesThrottle` is set. Use 0 to disable the CAN servo output. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo.
    // Range of cecanAddress is 0 to 255.
    uint8ToBytes(cecanAddress, _pg_data, &_pg_byteindex);

    _pg_data[_pg_byteindex] = 0;

    // Throttle position sensor error threshold in percent, used to determine if the TPS sensor has an error (if `efiDrivesThrottle` is set). Zero to disable
    // Range of tpsErrorThreshold is 0.0 to 31.0.
    _pg_data[_pg_byteindex] |= (uint8_t)float32ScaledToBitfield((float)tpsErrorThreshold, 0.0f, 1.0f, 5);
    _pg_byteindex += 1; // close bit field


    // Maximum throttle percentage that can be used to start the engine. If the engine is cranked with throttle above this value spark and injector outputs will be suspended. Use 0% to disable the start prevention feature.
    // Range of maxStartThrottle is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(maxStartThrottle, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // PWM in microseconds for 0% throttle input (command or TPS), use zero to set `closedPWMinput` equal to `closedPWMoutput`
    // Range of closedPWMinput is 0 to 65535.
    uint16ToBeBytes(closedPWMinput, _pg_data, &_pg_byteindex);

    // PWM in microseconds for 100% throttle input (command or TPS), use zero to set `closedPWMinput` equal to `closedPWMoutput`
    // Range of openPWMinput is 0 to 65535.
    uint16ToBeBytes(openPWMinput, _pg_data, &_pg_byteindex);

    // Integral feedback gain (/s) used to adjust throttle output to make the TPS value match the output command. The adjustment is only performed if this gain is non-zero, and if a TPS is enabled, and if `efiDrivesThrottle` is set.
    // Range of tpsFeedbackIntGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)tpsFeedbackIntGain, _pg_data, &_pg_byteindex, 10);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiThrottleConfiguration_t::encode

/*!
 * \brief Decode the efiThrottleConfiguration packet
 *
 * Configuration information specific to the throttle. There are two possible
 * sources of throttle position sensing: The analog throttle sensor and the PWM
 * input. If the EFI is configured to drive the throttle (`efiDrivesThrottle`
 * is set) there are four possible sources of throttle command: The analog
 * throttle, the PWM input, the user command, or the RPM controller. In
 * addition, it is also possible to apply a throttle curve to convert the the
 * commanded throttle to the actual throttle. Finally, if the EFI is configured
 * to drive the throttle it is possible to *not* have a TPS sensor, in which
 * case the throttle position is assumed to be equal the throttle output by the
 * EFI.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiThrottleConfiguration_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    startThrottle = 15;
    cecanAddress = 0;
    tpsErrorThreshold = 0;
    maxStartThrottle = 0;
    closedPWMinput = 0;
    openPWMinput = 0;
    tpsFeedbackIntGain = 0;

    // PWM in microseconds for 0% throttle output (for `efiDrivesThrottle`)
    // Range of closedPWMoutput is 0 to 65535.
    closedPWMoutput = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // PWM in microseconds for 100% throttle output (for `efiDrivesThrottle`)
    // Range of openPWMoutput is 0 to 65535.
    openPWMoutput = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Cutoff frequency for the low pass filter to apply to the throttle input, 0 will disable the filter. This filter always applies to TPS as well as command inputs. This filter supercedes the filter on the analog throttle sensor configuration.
    // Range of inputfilterlpf is 0.0 to 25.5.
    inputfilterlpf = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Rate limit on throttle output, in units of % throttle per second. 0 will disable the rate limiter.
    // Range of outputRateLimit is 0.0 to 1275.0.
    outputRateLimit = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.2f);

    // Set to enable the use of the analog throttle input as a throttle command (only valid if `efiDrivesThrottle` is set).
    enableAnalogCmd = (_pg_data[_pg_byteindex] >> 7);

    // Set to enable the use of the PWM input as a throttle command (only valid if `efiDrivesThrottle` is set).
    enablePWMCmd = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if the EFI is driving the throttle (through PWM out or CAN).
    efiDrivesThrottle = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set to enable the use of the analog throttle input as a throttle position sensor. This cannot be set simultaneously with `enableAnalogCmd`.
    enableAnalogTPS = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set to enable the use of the PWM throttle input as a throttle position sensor. This cannot be set simultaneously with `enablePWMCmd`.
    enablePWMTPS = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Deprecated for api 7.
    _enableCECANServo = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set to enable the CAN servo position feedback as a throttle position sensor.
    enableCECANTPS = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set to enable the manifold pressure (plus the MAP estimate table) as a throttle position sensor.
    enableMAPTPS = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    // The throttle curve relating throttle inputs to outputs. This can be disabled using the curve.enabled bit. The curve.indices are percent throttle input, and the curve.data are percent throttle output.
    if(curve.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    if(_pg_byteindex + 1 > _pg_numbytes)
        return true;

    // Throttle percentage used to start the engine in percent. If there is no valid throttle command, this is used to set the throttle position.
    // Range of startThrottle is 0.0 to 127.5.
    startThrottle = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return true;

    // Address, from 1 to 254, that identifies a Currawong Engineering CAN servo used for the throttle control if `efiDrivesThrottle` is set. Use 0 to disable the CAN servo output. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo.
    // Range of cecanAddress is 0 to 255.
    cecanAddress = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Throttle position sensor error threshold in percent, used to determine if the TPS sensor has an error (if `efiDrivesThrottle` is set). Zero to disable
    // Range of tpsErrorThreshold is 0.0 to 31.0.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex]) & 0x1F);
    tpsErrorThreshold = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1.0f);
    _pg_byteindex += 1; // close bit field

    if(_pg_byteindex + 1 > _pg_numbytes)
        return true;

    // Maximum throttle percentage that can be used to start the engine. If the engine is cranked with throttle above this value spark and injector outputs will be suspended. Use 0% to disable the start prevention feature.
    // Range of maxStartThrottle is 0.0 to 127.5.
    maxStartThrottle = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return true;

    // PWM in microseconds for 0% throttle input (command or TPS), use zero to set `closedPWMinput` equal to `closedPWMoutput`
    // Range of closedPWMinput is 0 to 65535.
    closedPWMinput = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return true;

    // PWM in microseconds for 100% throttle input (command or TPS), use zero to set `closedPWMinput` equal to `closedPWMoutput`
    // Range of openPWMinput is 0 to 65535.
    openPWMinput = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return true;

    // Integral feedback gain (/s) used to adjust throttle output to make the TPS value match the output command. The adjustment is only performed if this gain is non-zero, and if a TPS is enabled, and if `efiDrivesThrottle` is set.
    // Range of tpsFeedbackIntGain is -65504.0 to 65504.0.
    tpsFeedbackIntGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    return true;

}// efiThrottleConfiguration_t::decode

/*!
 * \brief Create the efiCoolingConfiguration packet
 *
 * Configuration information for the cooling system.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiCoolingConfiguration_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes((uint16_t)(0), _pg_data, &_pg_byteindex);

    // Head temperatures, in C, lower than this are an error (if the engine is running).
    // Range of chtTooCold is 0.0 to 255.0.
    float32ScaledTo1UnsignedBytes(chtTooCold, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Head temperatures, in C, higher than this are an error.
    // Range of chtTooHot is 0.0 to 255.0.
    float32ScaledTo1UnsignedBytes(chtTooHot, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Desired operating head temperature, in C.
    // Range of chtDesired is 0.0 to 255.0.
    float32ScaledTo1UnsignedBytes(chtDesired, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Time in seconds used to compute the CHT rate. Longer times will have less noise but more lag.
    // Range of derTime is 0.0 to 2.55.
    float32ScaledTo1UnsignedBytes(derTime, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Feedback trajectory gain from CHT error to CHT rate command. Must be positive. Use zero to disable the trajectory controller in favor of the classical controller.
    // Range of trajGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)trajGain, _pg_data, &_pg_byteindex, 10);

    // Feedforward gain from engine load (in percent) to cooling output in percent. Must be positive.
    // Range of forGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)forGain, _pg_data, &_pg_byteindex, 10);

    // Feedback gain from error (in C or C/s) to cooling output in percent. Must be positive.
    // Range of proGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)proGain, _pg_data, &_pg_byteindex, 10);

    // Feedback gain from error (in C or C/s) integral to cooling output in percent. Must be positive.
    // Range of intGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)intGain, _pg_data, &_pg_byteindex, 10);

    // Feedback gain from error derivative to the cooling output. Must be positive.
    // Range of derGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)derGain, _pg_data, &_pg_byteindex, 10);

    // Set to enable split cooling in which CHT1 drives cooling output 1, CHT2 drives cooling output 2, and CHT3 drives cooling output 3.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(enableSplitCooling, 1) << 7;

    _pg_data[_pg_byteindex + 1] = 0;

    _pg_byteindex += 2; // close bit field


    // PWM in microseconds for 0% cooling or cowl flap position for cooling output 1
    // Range of closedPWM1 is 0 to 65535.
    uint16ToBeBytes(closedPWM1, _pg_data, &_pg_byteindex);

    // PWM in microseconds for 100% cooling or cowl flap position for cooling output 1
    // Range of openPWM1 is 0 to 65535.
    uint16ToBeBytes(openPWM1, _pg_data, &_pg_byteindex);

    // PWM in microseconds for 0% cooling or cowl flap position for cooling output 2
    // Range of closedPWM2 is 0 to 65535.
    uint16ToBeBytes(closedPWM2, _pg_data, &_pg_byteindex);

    // PWM in microseconds for 100% cooling or cowl flap position for cooling output 2
    // Range of openPWM2 is 0 to 65535.
    uint16ToBeBytes(openPWM2, _pg_data, &_pg_byteindex);

    // Address, from 1 to 254, that identifies the first cowl flap servo on the CAN bus. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo. Use address 0 to disable the first CAN servo output.
    // Range of cecanAddress1 is 0 to 255.
    uint8ToBytes(cecanAddress1, _pg_data, &_pg_byteindex);

    // Address, from 1 to 254, that identifies the second cowl flap servo on the CAN bus. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo. Use address 0 to disable the second CAN servo output.
    // Range of cecanAddress2 is 0 to 255.
    uint8ToBytes(cecanAddress2, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiCoolingConfiguration_t::encode

/*!
 * \brief Decode the efiCoolingConfiguration packet
 *
 * Configuration information for the cooling system.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiCoolingConfiguration_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Skip over reserved space
    _pg_byteindex += 2;

    // Head temperatures, in C, lower than this are an error (if the engine is running).
    // Range of chtTooCold is 0.0 to 255.0.
    chtTooCold = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Head temperatures, in C, higher than this are an error.
    // Range of chtTooHot is 0.0 to 255.0.
    chtTooHot = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Desired operating head temperature, in C.
    // Range of chtDesired is 0.0 to 255.0.
    chtDesired = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Time in seconds used to compute the CHT rate. Longer times will have less noise but more lag.
    // Range of derTime is 0.0 to 2.55.
    derTime = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    // Feedback trajectory gain from CHT error to CHT rate command. Must be positive. Use zero to disable the trajectory controller in favor of the classical controller.
    // Range of trajGain is -65504.0 to 65504.0.
    trajGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedforward gain from engine load (in percent) to cooling output in percent. Must be positive.
    // Range of forGain is -65504.0 to 65504.0.
    forGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedback gain from error (in C or C/s) to cooling output in percent. Must be positive.
    // Range of proGain is -65504.0 to 65504.0.
    proGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedback gain from error (in C or C/s) integral to cooling output in percent. Must be positive.
    // Range of intGain is -65504.0 to 65504.0.
    intGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedback gain from error derivative to the cooling output. Must be positive.
    // Range of derGain is -65504.0 to 65504.0.
    derGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Set to enable split cooling in which CHT1 drives cooling output 1, CHT2 drives cooling output 2, and CHT3 drives cooling output 3.
    enableSplitCooling = (_pg_data[_pg_byteindex] >> 7);

    _pg_byteindex += 2; // close bit field

    // PWM in microseconds for 0% cooling or cowl flap position for cooling output 1
    // Range of closedPWM1 is 0 to 65535.
    closedPWM1 = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // PWM in microseconds for 100% cooling or cowl flap position for cooling output 1
    // Range of openPWM1 is 0 to 65535.
    openPWM1 = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // PWM in microseconds for 0% cooling or cowl flap position for cooling output 2
    // Range of closedPWM2 is 0 to 65535.
    closedPWM2 = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // PWM in microseconds for 100% cooling or cowl flap position for cooling output 2
    // Range of openPWM2 is 0 to 65535.
    openPWM2 = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Address, from 1 to 254, that identifies the first cowl flap servo on the CAN bus. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo. Use address 0 to disable the first CAN servo output.
    // Range of cecanAddress1 is 0 to 255.
    cecanAddress1 = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Address, from 1 to 254, that identifies the second cowl flap servo on the CAN bus. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo. Use address 0 to disable the second CAN servo output.
    // Range of cecanAddress2 is 0 to 255.
    cecanAddress2 = uint8FromBytes(_pg_data, &_pg_byteindex);

    return true;

}// efiCoolingConfiguration_t::decode

/*!
 * \brief Create the efiEngineConfiguration packet
 *
 * Configuration information for the core engine. This packet is used to set a
 * number of options about how to sense the crank shaft position, and control
 * the spark.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiEngineConfiguration_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Engine displacement in cubic centimeters
    // Range of displacement is 0.0 to 6553.5.
    float32ScaledTo2UnsignedBeBytes(displacement, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Set to ignore the input line that enables/disabes the EFI. If set the input enable is always enabled. Note that the physical enable line must be high to trigger the CDI outputs. `ignoreInputEnable` is only useful for testing or if you are not using the CDI.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(ignoreInputEnable, 1) << 7;

    // Set to prevent normal direction engine running. This only applies if the crank sense system can determine direction.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(preventNormalRotation, 1) << 6;

    // Set to prevent reverse direction engine running. This only applies if the crank sense system can determine direction.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(preventReverseRotation, 1) << 5;

    // Deprecated setting for enabling crank sensor 2, this setting will only be obeyed if api8 is clear
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(_enableCrank2, 1) << 4;

    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enableSpark3, 1) << 3;

    // Set if the ignitions are triggered on a rising edge from the EFI, else ignition is triggered on the falling edge.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(ignActiveHigh, 1) << 2;

    // This bit will be set for api8 or later packets.
    _pg_data[_pg_byteindex] |= (uint8_t)1 << 1;

    // This bit will be set for api7 or later packets.
    _pg_data[_pg_byteindex] |= (uint8_t)1;
    _pg_byteindex += 1; // close bit field


    // Maximum ignition dwell time in milliseconds.
    // Range of maxIgnDwellTime is 0 to 255.
    uint8ToBytes(maxIgnDwellTime, _pg_data, &_pg_byteindex);

    // Minimum ignition active time in microseconds.
    // Range of minIgnActiveTime is 0 to 65535.
    uint16ToBeBytes(minIgnActiveTime, _pg_data, &_pg_byteindex);

    // Maximum engine speed, above which spark and injection are turned off. Zero to disable the rev limiter.
    // Range of hardRevLimit is 0.0 to 65535.0.
    float32ScaledTo2UnsignedBeBytes(hardRevLimit, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Engine speed above which spark and injection begin to turn off.
    // Range of softRevLimit is 0.0 to 65535.0.
    float32ScaledTo2UnsignedBeBytes(softRevLimit, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Cutoff frequency for the low pass filter to apply to the rpm, 0 will disable the filter
    // Range of rpmfilterlpf is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(rpmfilterlpf, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    _pg_data[_pg_byteindex] = 0;

    // Manifold pressure error threshold in kPa, used (along with the MAP estimate table) to determine if the manifold pressure has an error. Zero to disable.
    // Range of mapErrorThreshold is 0.0 to 63.5.
    _pg_data[_pg_byteindex] |= (uint8_t)float32ScaledToBitfield((float)mapErrorThreshold, 0.0f, 2.0f, 7);
    _pg_byteindex += 1; // close bit field


    // Details of the crank sense configuration for crank sensor 1
    crankSense1.encode(_pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // Details of the crank sense configuration for crank sensor 2
    crankSense2.encode(_pg_data, &_pg_byteindex);

    // Reference head temperature for fuel correction, in C.
    // Range of chtReference is 0.0 to 255.0.
    float32ScaledTo1UnsignedBytes(chtReference, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiEngineConfiguration_t::encode

/*!
 * \brief Decode the efiEngineConfiguration packet
 *
 * Configuration information for the core engine. This packet is used to set a
 * number of options about how to sense the crank shaft position, and control
 * the spark.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiEngineConfiguration_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Engine displacement in cubic centimeters
    // Range of displacement is 0.0 to 6553.5.
    displacement = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Set to ignore the input line that enables/disabes the EFI. If set the input enable is always enabled. Note that the physical enable line must be high to trigger the CDI outputs. `ignoreInputEnable` is only useful for testing or if you are not using the CDI.
    ignoreInputEnable = (_pg_data[_pg_byteindex] >> 7);

    // Set to prevent normal direction engine running. This only applies if the crank sense system can determine direction.
    preventNormalRotation = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set to prevent reverse direction engine running. This only applies if the crank sense system can determine direction.
    preventReverseRotation = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Deprecated setting for enabling crank sensor 2, this setting will only be obeyed if api8 is clear
    _enableCrank2 = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    enableSpark3 = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set if the ignitions are triggered on a rising edge from the EFI, else ignition is triggered on the falling edge.
    ignActiveHigh = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // This bit will be set for api8 or later packets.
    api8 = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // This bit will be set for api7 or later packets.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex]) & 0x1);
    // Decoded value must be 1
    if(_pg_tempbitfield != 1)
        return false;
    _pg_byteindex += 1; // close bit field

    // Maximum ignition dwell time in milliseconds.
    // Range of maxIgnDwellTime is 0 to 255.
    maxIgnDwellTime = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Minimum ignition active time in microseconds.
    // Range of minIgnActiveTime is 0 to 65535.
    minIgnActiveTime = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Maximum engine speed, above which spark and injection are turned off. Zero to disable the rev limiter.
    // Range of hardRevLimit is 0.0 to 65535.0.
    hardRevLimit = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Engine speed above which spark and injection begin to turn off.
    // Range of softRevLimit is 0.0 to 65535.0.
    softRevLimit = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Cutoff frequency for the low pass filter to apply to the rpm, 0 will disable the filter
    // Range of rpmfilterlpf is 0.0 to 25.5.
    rpmfilterlpf = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Manifold pressure error threshold in kPa, used (along with the MAP estimate table) to determine if the manifold pressure has an error. Zero to disable.
    // Range of mapErrorThreshold is 0.0 to 63.5.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex]) & 0x7F);
    mapErrorThreshold = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);
    _pg_byteindex += 1; // close bit field

    // Details of the crank sense configuration for crank sensor 1
    if(crankSense1.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Skip over reserved space
    _pg_byteindex += 1;

    // Details of the crank sense configuration for crank sensor 2
    if(crankSense2.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Reference head temperature for fuel correction, in C.
    // Range of chtReference is 0.0 to 255.0.
    chtReference = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    return true;

}// efiEngineConfiguration_t::decode

/*!
 * \brief Create the efiInjectorConfiguration packet
 *
 * Configuration information for the injector. The EFI supports three injector
 * outputs. The injectors are operated so that the sum of all injectors is
 * equal to the desired fuel output. The proportion of fuel that each injector
 * outputs is controlled through the injector ratio tables. The EFI also
 * supports injector skipping, in which short fuel injection pulses are
 * accumulated into longer pulses for more precise control of the fuel
 * delivery.
 * 
 * Injectors can be configured to operate independently, which means that the
 * fuel multiplier that comes from temperature is determined independently for
 * each injector. There are four temperature sensors: a dedicated MAT sensor,
 * two dedicated CHT sensors, and a spare sensor that can be configurable as a
 * second MAT or third CHT. If the spare temp sensor is configured as manifold
 * temp the fuel multiplier for injector1 is based on CHT1 and MAT, the fuel
 * multiplier for injector2 is based on CHT2 and spare temp, and the fuel
 * multiplier for injector3 is the average of injector1 and 2. If the spare
 * temp sensor is configured as cylinder temp the fuel multiplier for injector1
 * is based on CHT1 and MAT, the fule multiplier for injector2 is based on CHT2
 * and MAT, and the fuel multiplier for injector3 is based on spare temp and
 * MAT.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiInjectorConfiguration_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Set to enable the second injector.
    _pg_data[_pg_byteindex] = (uint8_t)enableInjector2 << 7;

    // Set to allow injectors to independently compute fuel multipliers for temperature.
    _pg_data[_pg_byteindex] |= (uint8_t)enableInjectorIndependence << 6;

    // Set to assign the role of cylinder temperature 3 to the spare temp sensor.
    _pg_data[_pg_byteindex] |= (uint8_t)spareTempIsCHT << 5;

    // Set to assign the role of manifold temperature 2 to the spare temp sensor.
    _pg_data[_pg_byteindex] |= (uint8_t)spareTempIsMAT << 4;

    // Set to enable the third injector.
    _pg_data[_pg_byteindex] |= (uint8_t)enableInjector3 << 3;

    // Set to allow injectors to operate redundantly, such that a fault on one injector causes the other injectors to pick up the fuel flow.
    _pg_data[_pg_byteindex] |= (uint8_t)injectorsAreRedundant << 2;

    // The injector phase edge specifies how to apply the injector phase table, and what injector angle is reported in telemetry
    _pg_data[_pg_byteindex] |= (uint8_t)phaseEdge;
    _pg_byteindex += 1; // close bit field


    // Percent fuel volume correction per degree C of MAT difference from 15C. Should be positive (volume goes up as temp goes up).
    // Range of fuelVolumePercentPerMAT is 0.0 to 1.275.
    float32ScaledTo1UnsignedBytes(fuelVolumePercentPerMAT, _pg_data, &_pg_byteindex, 0.0f, 200.0f);

    // Overall fuel multiplier to apply to the output of the fuel table.
    // Range of multiplier is -65504.0 to 65504.0.
    float16ToBeBytes((float)multiplier, _pg_data, &_pg_byteindex, 10);

    // Nominal injector pressure in kilo-Pascals.
    // Range of nominalFuelPressure is 0.0 to 1310.7.
    float32ScaledTo2UnsignedBeBytes(nominalFuelPressure, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    // First injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute.
    // Range of nominalFlowrate1 is 0.0 to 1200.0.
    float32ScaledTo2UnsignedBeBytes(nominalFlowrate1, _pg_data, &_pg_byteindex, 0.0f, 54.6125f);

    // Second injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute.
    // Range of nominalFlowrate2 is 0.0 to 1200.0.
    float32ScaledTo2UnsignedBeBytes(nominalFlowrate2, _pg_data, &_pg_byteindex, 0.0f, 54.6125f);

    // Minimum opening time in microseconds for the first injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value.
    // Range of minOpeningTime1 is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(minOpeningTime1, 65535)), _pg_data, &_pg_byteindex);

    // Minimum opening time in microseconds for the second injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value.
    // Range of minOpeningTime2 is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(minOpeningTime2, 65535)), _pg_data, &_pg_byteindex);

    // Multiplier to apply to the accumulated fuel injected to correct for any fuel consumption reporting error. This value does not affect the engine operation, just the fuel reporting.
    // Range of fuelUsedCorrector is -65504.0 to 65504.0.
    float16ToBeBytes((float)fuelUsedCorrector, _pg_data, &_pg_byteindex, 10);

    // Third injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute.
    // Range of nominalFlowrate3 is 0.0 to 1200.0.
    float32ScaledTo2UnsignedBeBytes(nominalFlowrate3, _pg_data, &_pg_byteindex, 0.0f, 54.6125f);

    // Minimum opening time in microseconds for the third injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value.
    // Range of minOpeningTime3 is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(minOpeningTime3, 65535)), _pg_data, &_pg_byteindex);

    // Frequency to run the oil injection pump for priming.
    // Range of oilPrimingFreq is 0.0 to 15.5.
    _pg_data[_pg_byteindex] = (uint8_t)float32ScaledToBitfield((float)oilPrimingFreq, 0.0f, 2.0f, 5) << 3;

    // Set to assign the role of oil temperature to the spare temp sensor.
    _pg_data[_pg_byteindex] |= (uint8_t)spareTempIsOilT << 2;

    // Set to enable the second injector output to be used for oil injection. This must not be set at the same time as enableInjector2.
    _pg_data[_pg_byteindex] |= (uint8_t)injector2IsOilInj << 1;

    // Set to enable the third injector output to be used for oil injection. This must not be set at the same time as enableInjector3.
    _pg_data[_pg_byteindex] |= (uint8_t)injector3IsOilInj;
    _pg_byteindex += 1; // close bit field


    // Oil to inject when the engine starts, in micrograms per cc of engine displacement
    // Range of oilForStarting is 0.0 to 65535.0.
    float32ScaledTo2UnsignedBeBytes(oilForStarting, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Multiplier to apply to the accumulated oil injected to correct for any oil consumption reporting error. This value does not affect the oil injection operation, just the reporting.
    // Range of oilUsedCorrector is -655.04 to 655.04.
    float16ToBeBytes((float)oilUsedCorrector*100.0f, _pg_data, &_pg_byteindex, 10);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiInjectorConfiguration_t::encode

/*!
 * \brief Decode the efiInjectorConfiguration packet
 *
 * Configuration information for the injector. The EFI supports three injector
 * outputs. The injectors are operated so that the sum of all injectors is
 * equal to the desired fuel output. The proportion of fuel that each injector
 * outputs is controlled through the injector ratio tables. The EFI also
 * supports injector skipping, in which short fuel injection pulses are
 * accumulated into longer pulses for more precise control of the fuel
 * delivery.
 * 
 * Injectors can be configured to operate independently, which means that the
 * fuel multiplier that comes from temperature is determined independently for
 * each injector. There are four temperature sensors: a dedicated MAT sensor,
 * two dedicated CHT sensors, and a spare sensor that can be configurable as a
 * second MAT or third CHT. If the spare temp sensor is configured as manifold
 * temp the fuel multiplier for injector1 is based on CHT1 and MAT, the fuel
 * multiplier for injector2 is based on CHT2 and spare temp, and the fuel
 * multiplier for injector3 is the average of injector1 and 2. If the spare
 * temp sensor is configured as cylinder temp the fuel multiplier for injector1
 * is based on CHT1 and MAT, the fule multiplier for injector2 is based on CHT2
 * and MAT, and the fuel multiplier for injector3 is based on spare temp and
 * MAT.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiInjectorConfiguration_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    nominalFlowrate3 = 0;
    minOpeningTime3 = 0;
    oilPrimingFreq = 10;
    spareTempIsOilT = 0;
    injector2IsOilInj = 0;
    injector3IsOilInj = 0;
    oilForStarting = (float)1000.0;
    oilUsedCorrector = (float)1.0;

    // Set to enable the second injector.
    enableInjector2 = (_pg_data[_pg_byteindex] >> 7);

    // Set to allow injectors to independently compute fuel multipliers for temperature.
    enableInjectorIndependence = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set to assign the role of cylinder temperature 3 to the spare temp sensor.
    spareTempIsCHT = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set to assign the role of manifold temperature 2 to the spare temp sensor.
    spareTempIsMAT = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set to enable the third injector.
    enableInjector3 = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set to allow injectors to operate redundantly, such that a fault on one injector causes the other injectors to pick up the fuel flow.
    injectorsAreRedundant = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // The injector phase edge specifies how to apply the injector phase table, and what injector angle is reported in telemetry
    phaseEdge = (InjectorPhaseEdge)((_pg_data[_pg_byteindex]) & 0x3);
    _pg_byteindex += 1; // close bit field

    // Percent fuel volume correction per degree C of MAT difference from 15C. Should be positive (volume goes up as temp goes up).
    // Range of fuelVolumePercentPerMAT is 0.0 to 1.275.
    fuelVolumePercentPerMAT = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/200.0f);

    // Overall fuel multiplier to apply to the output of the fuel table.
    // Range of multiplier is -65504.0 to 65504.0.
    multiplier = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Nominal injector pressure in kilo-Pascals.
    // Range of nominalFuelPressure is 0.0 to 1310.7.
    nominalFuelPressure = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // First injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute.
    // Range of nominalFlowrate1 is 0.0 to 1200.0.
    nominalFlowrate1 = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/54.6125f);

    // Second injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute.
    // Range of nominalFlowrate2 is 0.0 to 1200.0.
    nominalFlowrate2 = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/54.6125f);

    // Minimum opening time in microseconds for the first injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value.
    // Range of minOpeningTime1 is 0 to 65535.
    minOpeningTime1 = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Minimum opening time in microseconds for the second injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value.
    // Range of minOpeningTime2 is 0 to 65535.
    minOpeningTime2 = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Multiplier to apply to the accumulated fuel injected to correct for any fuel consumption reporting error. This value does not affect the engine operation, just the fuel reporting.
    // Range of fuelUsedCorrector is -65504.0 to 65504.0.
    fuelUsedCorrector = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return true;

    // Third injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute.
    // Range of nominalFlowrate3 is 0.0 to 1200.0.
    nominalFlowrate3 = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/54.6125f);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return true;

    // Minimum opening time in microseconds for the third injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value.
    // Range of minOpeningTime3 is 0 to 65535.
    minOpeningTime3 = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return 1;

    // Frequency to run the oil injection pump for priming.
    // Range of oilPrimingFreq is 0.0 to 15.5.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] >> 3);
    oilPrimingFreq = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/2.0f);

    // Set to assign the role of oil temperature to the spare temp sensor.
    spareTempIsOilT = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set to enable the second injector output to be used for oil injection. This must not be set at the same time as enableInjector2.
    injector2IsOilInj = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set to enable the third injector output to be used for oil injection. This must not be set at the same time as enableInjector3.
    injector3IsOilInj = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    if(_pg_byteindex + 2 > _pg_numbytes)
        return true;

    // Oil to inject when the engine starts, in micrograms per cc of engine displacement
    // Range of oilForStarting is 0.0 to 65535.0.
    oilForStarting = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return true;

    // Multiplier to apply to the accumulated oil injected to correct for any oil consumption reporting error. This value does not affect the oil injection operation, just the reporting.
    // Range of oilUsedCorrector is -655.04 to 655.04.
    oilUsedCorrector = (1.0f/100.0f)*float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    return true;

}// efiInjectorConfiguration_t::decode

/*!
 * \brief Create the efiRPMController packet
 *
 * Configuration information for the RPM controller. The RPM controller can
 * only be used if the throttle configuration has `efiDrivesThrottle` set. The
 * RPM controller functions by moving the throttle. This is not the same as the
 * rev limiter, which functions by interrupting spark and injection.
 * 
 * The RPM controller can be commanded two different ways: either by directly
 * commanding the controller with the [RPM command](#EFI_PKT_RPMCOMMAND)
 * packet; or the RPM controller can be driven by the throttle command in order
 * to achieve an RPM computed from the throttle command.
 * 
 * The RPM controller can run in two different feedback control modes. In the
 * first mode (used if `trajGain` is zero) the feedback is based on RPM error.
 * In the second mode the feedback is based on RPM rate error.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiRPMController_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Minimum commandable engine speed. The RPM command will be limited to greater than or equal to this value.
    // Range of minRPM is 0.0 to 65535.0.
    float32ScaledTo2UnsignedBeBytes(minRPM, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Maximum commandable engine speed. The RPM command will be limited to less than or equal to this value. If the `maxRPM` is less than the `minRPM` the RPM controller settings will be set to defaults.
    // Range of maxRPM is 0.0 to 65535.0.
    float32ScaledTo2UnsignedBeBytes(maxRPM, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Set to enable RPM command from throttle command. If this is clear the RPM governor is only enabled when receiving a direct RPM command.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(enableRPMfromThrottleCmd, 1) << 7;

    // Set to override the throttle command (when the governor is *not* running) to prevent RPM falling below the minRPM.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enableLowRPMLimiter, 1) << 6;

    // Set to override the throttle command (when the governor is *not* running) to prevent RPM exceeding the maxRPM.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enableHighRPMLimiter, 1) << 5;


    // Maximum frequency of the RPM control loop in Hertz. Slower reduces noise, faster improves responsiveness
    // Range of updateRate is 10.0 to 85.0.
    _pg_data[_pg_byteindex] |= (uint8_t)float32ScaledToBitfield((float)updateRate, 10.0f, 0.2f, 4);
    _pg_byteindex += 1; // close bit field


    // The throttle in percent which is expected to yield the minimum RPM. This term is used to compute the RPM command from the throttle command when running in throttle mode. It is also used to compute the feedforward throttle term when running in direct RPM mode, and the throttle output in direct RPM mode if the engine is not yet running.
    // Range of throttleAtMinRPM is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(throttleAtMinRPM, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Power relationship between rpm ratio (rpmcmd-minRPM)/(maxRPM-minRPM) and throttle. This term is used to compute the RPM command from the throttle command when running in throttle mode. It is also used to compute the feedforward throttle term when running in direct RPM mode, and the throttle output in direct RPM mode if the engine is not yet running.
    // Range of rpmToThrottlePower is -65504.0 to 65504.0.
    float16ToBeBytes((float)rpmToThrottlePower, _pg_data, &_pg_byteindex, 10);

    // Low pass filter cutoff frequency applied to the rpm command. Use zero to disable the filter.
    // Range of rpmCmdfilterlpf is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(rpmCmdfilterlpf, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum RPM rate command in RPM/s, zero to disable the rate limiter. Must be positive.
    // Range of maxRateCmd is -65504.0 to 65504.0.
    float16ToBeBytes((float)maxRateCmd, _pg_data, &_pg_byteindex, 10);

    // Feedback trajectory gain from RPM error to RPM rate command. Must be positive. User zero to disable the trajectory controller in favor of the classical controller.
    // Range of trajGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)trajGain, _pg_data, &_pg_byteindex, 10);

    // Power applied to the inner loop gains. Positive numbers cause gains to increase as RPM increases. Negative numbers cause gains to decrease as RPM increases. 0 will cause gains to be constant with RPM.
    // Range of gainScaler is -65504.0 to 65504.0.
    float16ToBeBytes((float)gainScaler, _pg_data, &_pg_byteindex, 10);

    // Feedforward gain from RPM command to the throttle. Must be positive.
    // Range of forGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)forGain, _pg_data, &_pg_byteindex, 10);

    // Feedback gain from error to the throttle. Must be positive.
    // Range of proGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)proGain, _pg_data, &_pg_byteindex, 10);

    // Feedback gain from error integral to the throttle. Must be positive.
    // Range of intGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)intGain, _pg_data, &_pg_byteindex, 10);

    // Feedback gain from error derivative to the throttle. Must be positive.
    // Range of derGain is -65504.0 to 65504.0.
    float16ToBeBytes((float)derGain, _pg_data, &_pg_byteindex, 10);

    // Time in seconds used to compute the RPM rate. Longer times will have less noise but more lag.
    // Range of derivativeTime is 0.0 to 1.0.
    float32ScaledTo1UnsignedBytes(derivativeTime, _pg_data, &_pg_byteindex, 0.0f, 255.0f);

    // Low pass filter cutoff frequency applied to the rpm controller output. Use zero to disable the filter.
    // Range of outputfilterlpf is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(outputfilterlpf, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Percent throttle motion that falls into the 'softband', which increases the low pass filter strength. Use zero to disable the softband.
    // Range of outputsoftband is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(outputsoftband, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiRPMController_t::encode

/*!
 * \brief Decode the efiRPMController packet
 *
 * Configuration information for the RPM controller. The RPM controller can
 * only be used if the throttle configuration has `efiDrivesThrottle` set. The
 * RPM controller functions by moving the throttle. This is not the same as the
 * rev limiter, which functions by interrupting spark and injection.
 * 
 * The RPM controller can be commanded two different ways: either by directly
 * commanding the controller with the [RPM command](#EFI_PKT_RPMCOMMAND)
 * packet; or the RPM controller can be driven by the throttle command in order
 * to achieve an RPM computed from the throttle command.
 * 
 * The RPM controller can run in two different feedback control modes. In the
 * first mode (used if `trajGain` is zero) the feedback is based on RPM error.
 * In the second mode the feedback is based on RPM rate error.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiRPMController_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Minimum commandable engine speed. The RPM command will be limited to greater than or equal to this value.
    // Range of minRPM is 0.0 to 65535.0.
    minRPM = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Maximum commandable engine speed. The RPM command will be limited to less than or equal to this value. If the `maxRPM` is less than the `minRPM` the RPM controller settings will be set to defaults.
    // Range of maxRPM is 0.0 to 65535.0.
    maxRPM = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Set to enable RPM command from throttle command. If this is clear the RPM governor is only enabled when receiving a direct RPM command.
    enableRPMfromThrottleCmd = (_pg_data[_pg_byteindex] >> 7);

    // Set to override the throttle command (when the governor is *not* running) to prevent RPM falling below the minRPM.
    enableLowRPMLimiter = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set to override the throttle command (when the governor is *not* running) to prevent RPM exceeding the maxRPM.
    enableHighRPMLimiter = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Maximum frequency of the RPM control loop in Hertz. Slower reduces noise, faster improves responsiveness
    // Range of updateRate is 10.0 to 85.0.
    _pg_tempbitfield = ((_pg_data[_pg_byteindex]) & 0xF);
    updateRate = float32ScaledFromBitfield(_pg_tempbitfield, 10.0f, 1.0f/0.2f);
    _pg_byteindex += 1; // close bit field

    // The throttle in percent which is expected to yield the minimum RPM. This term is used to compute the RPM command from the throttle command when running in throttle mode. It is also used to compute the feedforward throttle term when running in direct RPM mode, and the throttle output in direct RPM mode if the engine is not yet running.
    // Range of throttleAtMinRPM is 0.0 to 127.5.
    throttleAtMinRPM = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Power relationship between rpm ratio (rpmcmd-minRPM)/(maxRPM-minRPM) and throttle. This term is used to compute the RPM command from the throttle command when running in throttle mode. It is also used to compute the feedforward throttle term when running in direct RPM mode, and the throttle output in direct RPM mode if the engine is not yet running.
    // Range of rpmToThrottlePower is -65504.0 to 65504.0.
    rpmToThrottlePower = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Low pass filter cutoff frequency applied to the rpm command. Use zero to disable the filter.
    // Range of rpmCmdfilterlpf is 0.0 to 25.5.
    rpmCmdfilterlpf = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum RPM rate command in RPM/s, zero to disable the rate limiter. Must be positive.
    // Range of maxRateCmd is -65504.0 to 65504.0.
    maxRateCmd = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedback trajectory gain from RPM error to RPM rate command. Must be positive. User zero to disable the trajectory controller in favor of the classical controller.
    // Range of trajGain is -65504.0 to 65504.0.
    trajGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Power applied to the inner loop gains. Positive numbers cause gains to increase as RPM increases. Negative numbers cause gains to decrease as RPM increases. 0 will cause gains to be constant with RPM.
    // Range of gainScaler is -65504.0 to 65504.0.
    gainScaler = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedforward gain from RPM command to the throttle. Must be positive.
    // Range of forGain is -65504.0 to 65504.0.
    forGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedback gain from error to the throttle. Must be positive.
    // Range of proGain is -65504.0 to 65504.0.
    proGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedback gain from error integral to the throttle. Must be positive.
    // Range of intGain is -65504.0 to 65504.0.
    intGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Feedback gain from error derivative to the throttle. Must be positive.
    // Range of derGain is -65504.0 to 65504.0.
    derGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Time in seconds used to compute the RPM rate. Longer times will have less noise but more lag.
    // Range of derivativeTime is 0.0 to 1.0.
    derivativeTime = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/255.0f);

    // Low pass filter cutoff frequency applied to the rpm controller output. Use zero to disable the filter.
    // Range of outputfilterlpf is 0.0 to 25.5.
    outputfilterlpf = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Percent throttle motion that falls into the 'softband', which increases the low pass filter strength. Use zero to disable the softband.
    // Range of outputsoftband is 0.0 to 127.5.
    outputsoftband = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    return true;

}// efiRPMController_t::decode

/*!
 * \brief Encode a efiMaintenanceItemConfig_t into a byte array
 *
 * List of maintenance item
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 */
void efiMaintenanceItemConfig_t::encode(uint8_t* _pg_data, int* _pg_bytecount) const
{
    int _pg_byteindex = *_pg_bytecount;

    _pg_data[_pg_byteindex] = 0;

    // The trigger for this maintenance item
    _pg_data[_pg_byteindex] |= (uint8_t)trigger;
    _pg_byteindex += 1; // close bit field

    // The interval at which this maintenance should be done. For time triggers this is in seconds. Use zero to disable this maintenance item.
    // Range of interval is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(interval, 16777215)), _pg_data, &_pg_byteindex);

    // Brief description of the maintenance to be performed
    stringToBytes(description, _pg_data, &_pg_byteindex, 64, 0);

    *_pg_bytecount = _pg_byteindex;

}// efiMaintenanceItemConfig_t::encode

/*!
 * \brief Decode a efiMaintenanceItemConfig_t from a byte array
 *
 * List of maintenance item
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \return true if the data are decoded, else false.
 */
bool efiMaintenanceItemConfig_t::decode(const uint8_t* _pg_data, int* _pg_bytecount)
{
    int _pg_byteindex = *_pg_bytecount;

    // The trigger for this maintenance item
    trigger = (MaintenanceTriggers)((_pg_data[_pg_byteindex]) & 0x7);
    _pg_byteindex += 1; // close bit field

    // The interval at which this maintenance should be done. For time triggers this is in seconds. Use zero to disable this maintenance item.
    // Range of interval is 0 to 16777215.
    interval = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // Brief description of the maintenance to be performed
    stringFromBytes(description, _pg_data, &_pg_byteindex, 64, 0);

    *_pg_bytecount = _pg_byteindex;

    return true;

}// efiMaintenanceItemConfig_t::decode

/*!
 * \brief Create the efiMaintenanceConfiguration packet
 *
 * Set or request the maintenance schedule. The maintenance schedule is a list
 * of maintenance service actions. You can see if any maintenance item is
 * pending by checking the `maintenanceNeeded` bit of the [errors
 * packet](#EFI_PKT_TELEMETRYERRORS). Details of the maintenance status are
 * provided in the [maintenance status](#EFI_PKT_MAINTENANCESTATUS) packet. If
 * you use this packet to change the number of maintenance items, the
 * maintenance status will also be updated to keep the status items in sync
 * with the schedule.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiMaintenanceConfiguration_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    _pg_data[_pg_byteindex] = 0;

    // The number of maintenance items
    // Range of numItems is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(numItems, 31);
    _pg_byteindex += 1; // close bit field


    // Hot time multiplier gain in multiplier per degree overtemp.
    // Range of hotTimeGain is 0.0 to 2.55.
    float32ScaledTo1UnsignedBytes(hotTimeGain, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Throttle position above which high load time begins accumulating
    // Range of highLoadThreshold is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(highLoadThreshold, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // List of maintenance item
    for(_pg_i = 0; _pg_i < (unsigned)numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        MaintenanceItemConfig[_pg_i].encode(_pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiMaintenanceConfiguration_t::encode

/*!
 * \brief Decode the efiMaintenanceConfiguration packet
 *
 * Set or request the maintenance schedule. The maintenance schedule is a list
 * of maintenance service actions. You can see if any maintenance item is
 * pending by checking the `maintenanceNeeded` bit of the [errors
 * packet](#EFI_PKT_TELEMETRYERRORS). Details of the maintenance status are
 * provided in the [maintenance status](#EFI_PKT_MAINTENANCESTATUS) packet. If
 * you use this packet to change the number of maintenance items, the
 * maintenance status will also be updated to keep the status items in sync
 * with the schedule.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiMaintenanceConfiguration_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // The number of maintenance items
    // Range of numItems is 0 to 31.
    numItems = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    // Hot time multiplier gain in multiplier per degree overtemp.
    // Range of hotTimeGain is 0.0 to 2.55.
    hotTimeGain = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    // Throttle position above which high load time begins accumulating
    // Range of highLoadThreshold is 0.0 to 127.5.
    highLoadThreshold = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Skip over reserved space
    _pg_byteindex += 1;

    // List of maintenance item
    for(_pg_i = 0; _pg_i < (unsigned)numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        if(MaintenanceItemConfig[_pg_i].decode(_pg_data, &_pg_byteindex) == false)
            return false;

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    return true;

}// efiMaintenanceConfiguration_t::decode

/*!
 * \brief Create the efiHardwareInfo packet
 *
 * Hardware and manufacturing information. This data cannot be changed, only
 * requested from the EFI.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiHardwareInfo_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // 32-bit serial number
    // Range of serial is 0 to -2147483648.
    uint32ToBeBytes(serial, _pg_data, &_pg_byteindex);

    // Deviation from the nominal current in Amps generated by the driver of the MAT sensor.
    // Range of mattempcurrentdev is -0.000127 to 0.000127.
    float32ScaledTo1SignedBytes(mattempcurrentdev, _pg_data, &_pg_byteindex, 1000000.0f);

    // Deviation from the nominal current in Amps generated by the driver of the Spare sensor.
    // Range of sparetempcurrentdev is -0.000127 to 0.000127.
    float32ScaledTo1SignedBytes(sparetempcurrentdev, _pg_data, &_pg_byteindex, 1000000.0f);

    // Deviation from the nominal current in Amps generated by the driver of the CHT1 sensor.
    // Range of cht1tempcurrentdev is -0.000127 to 0.000127.
    float32ScaledTo1SignedBytes(cht1tempcurrentdev, _pg_data, &_pg_byteindex, 1000000.0f);

    // Deviation from the nominal current in Amps generated by the driver of the CHT2 sensor.
    // Range of cht2tempcurrentdev is -0.000127 to 0.000127.
    float32ScaledTo1SignedBytes(cht2tempcurrentdev, _pg_data, &_pg_byteindex, 1000000.0f);

    // Range of reserved is 0 to 15.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(reserved, 15) << 4;

    // Nominal current from the temp sensor drivers in Amps.
    // Range of nomtempcurrent is 0.0 to 0.004095.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)nomtempcurrent, 0.0f, 1000000.0f, 12);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field



    // Major hardware revision number
    // Range of revMajor is 0 to 255.
    uint8ToBytes(revMajor, _pg_data, &_pg_byteindex);

    // Minor hardware revision number
    // Range of revMinor is 0 to 255.
    uint8ToBytes(revMinor, _pg_data, &_pg_byteindex);

    // The manufacture date of the hardware
    date.encode(_pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiHardwareInfo_t::encode

/*!
 * \brief Decode the efiHardwareInfo packet
 *
 * Hardware and manufacturing information. This data cannot be changed, only
 * requested from the EFI.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiHardwareInfo_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // 32-bit serial number
    // Range of serial is 0 to -2147483648.
    serial = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Deviation from the nominal current in Amps generated by the driver of the MAT sensor.
    // Range of mattempcurrentdev is -0.000127 to 0.000127.
    mattempcurrentdev = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1000000.0f);

    // Deviation from the nominal current in Amps generated by the driver of the Spare sensor.
    // Range of sparetempcurrentdev is -0.000127 to 0.000127.
    sparetempcurrentdev = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1000000.0f);

    // Deviation from the nominal current in Amps generated by the driver of the CHT1 sensor.
    // Range of cht1tempcurrentdev is -0.000127 to 0.000127.
    cht1tempcurrentdev = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1000000.0f);

    // Deviation from the nominal current in Amps generated by the driver of the CHT2 sensor.
    // Range of cht2tempcurrentdev is -0.000127 to 0.000127.
    cht2tempcurrentdev = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1000000.0f);

    // Range of reserved is 0 to 15.
    reserved = (_pg_data[_pg_byteindex] >> 4);

    // Nominal current from the temp sensor drivers in Amps.
    // Range of nomtempcurrent is 0.0 to 0.004095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    nomtempcurrent = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/1000000.0f);
    _pg_byteindex += 2; // close bit field

    // Major hardware revision number
    // Range of revMajor is 0 to 255.
    revMajor = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Minor hardware revision number
    // Range of revMinor is 0 to 255.
    revMinor = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The manufacture date of the hardware
    if(date.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return true;

}// efiHardwareInfo_t::decode

/*!
 * \brief Create the efiSoftwareInfo packet
 *
 * Software version information. This data cannot be changed, only requested.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiSoftwareInfo_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Git hash number (short version) from the software repository for this build
    // Range of swHash is 0 to -2147483648.
    uint32ToBeBytes(swHash, _pg_data, &_pg_byteindex);

    // Set if software is released, otherwise this software is still being tested.
    _pg_data[_pg_byteindex] = (uint8_t)released << 7;

    // Major software revision number
    // Range of swMajorVersion is 0 to 127.
    _pg_data[_pg_byteindex] |= (uint8_t)swMajorVersion;
    _pg_byteindex += 1; // close bit field


    // Minor software revision number
    // Range of swMinorVersion is 0 to 255.
    uint8ToBytes(swMinorVersion, _pg_data, &_pg_byteindex);

    uint16ToBeBytes((uint16_t)(0), _pg_data, &_pg_byteindex);

    // Build number for this software. Larger build numbers are newer software
    // Range of swBuild is 0 to 65535.
    uint16ToBeBytes(swBuild, _pg_data, &_pg_byteindex);

    // The release date of the software
    date.encode(_pg_data, &_pg_byteindex);

    // The crc for the software load
    // Range of codecrc is 0 to -2147483648.
    uint32ToBeBytes(codecrc, _pg_data, &_pg_byteindex);

    // The size of the program load in bytes.
    // Range of size is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(size, 16777215)), _pg_data, &_pg_byteindex);

    // Human readable description of the software release
    stringToBytes(description, _pg_data, &_pg_byteindex, 256, 0);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiSoftwareInfo_t::encode

/*!
 * \brief Decode the efiSoftwareInfo packet
 *
 * Software version information. This data cannot be changed, only requested.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiSoftwareInfo_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Git hash number (short version) from the software repository for this build
    // Range of swHash is 0 to -2147483648.
    swHash = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Set if software is released, otherwise this software is still being tested.
    released = (_pg_data[_pg_byteindex] >> 7);

    // Major software revision number
    // Range of swMajorVersion is 0 to 127.
    swMajorVersion = ((_pg_data[_pg_byteindex]) & 0x7F);
    _pg_byteindex += 1; // close bit field

    // Minor software revision number
    // Range of swMinorVersion is 0 to 255.
    swMinorVersion = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Skip over reserved space
    _pg_byteindex += 2;

    // Build number for this software. Larger build numbers are newer software
    // Range of swBuild is 0 to 65535.
    swBuild = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // The release date of the software
    if(date.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // The crc for the software load
    // Range of codecrc is 0 to -2147483648.
    codecrc = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // The size of the program load in bytes.
    // Range of size is 0 to 16777215.
    size = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // Human readable description of the software release
    stringFromBytes(description, _pg_data, &_pg_byteindex, 256, 0);

    return true;

}// efiSoftwareInfo_t::decode

/*!
 * \brief Create the efiTable2D_1x packet
 *
 * This packet is used to change or request a 2D table, for software version
 * 1.x. It should not be used when communicating with 2.x IntelliJect. Send
 * this packet with just the first byte to request a specific table.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTable2D_1x_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    // Table enable. If clear this table is not used
    _pg_data[_pg_byteindex] = (uint8_t)enabled << 7;

    // Set to use the percent ratio of manifold to baro pressure as the row axis index, otherwise use the throttle. This only applies to tables that use throttle/load for the row index.
    _pg_data[_pg_byteindex] |= (uint8_t)loadfrommap << 6;

    // Enumeration specifying to which old table this packet applies.
    _pg_data[_pg_byteindex] |= (uint8_t)index;

    // This bit must be clear for a 1.x table.
    _pg_data[_pg_byteindex + 1] = 0;


    _pg_data[_pg_byteindex + 2] = 0;

    // Number of rows used in this table
    // Range of numrows is 0 to EFI_TABLE_MAX_ROWS.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(numrows, EFI_TABLE_MAX_ROWS);

    _pg_data[_pg_byteindex + 3] = 0;

    // Number of columns used in this table
    // Range of numcols is 0 to EFI_TABLE_MAX_COLS.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)limitMax(numcols, EFI_TABLE_MAX_COLS);
    _pg_byteindex += 4; // close bit field


    // The number of rows used in this table
    // Range of rowindices is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        float16ToBeBytes((float)rowindices[_pg_i], _pg_data, &_pg_byteindex, 10);

    // The number of columns used in this table
    // Range of colindices is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        float16ToBeBytes((float)colindices[_pg_i], _pg_data, &_pg_byteindex, 10);

    // The table data organized as row major
    // Range of data is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            float16ToBeBytes((float)data[_pg_i][_pg_j], _pg_data, &_pg_byteindex, 10);

    // The table meta data organized as row major
    // Range of meta is 0 to 255.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            uint8ToBytes(meta[_pg_i][_pg_j], _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTable2D_1x_t::encode

/*!
 * \brief Decode the efiTable2D_1x packet
 *
 * This packet is used to change or request a 2D table, for software version
 * 1.x. It should not be used when communicating with 2.x IntelliJect. Send
 * this packet with just the first byte to request a specific table.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTable2D_1x_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    for(_pg_i = 0; _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            meta[_pg_i][_pg_j] = 0;

    // Table enable. If clear this table is not used
    enabled = (_pg_data[_pg_byteindex] >> 7);

    // Set to use the percent ratio of manifold to baro pressure as the row axis index, otherwise use the throttle. This only applies to tables that use throttle/load for the row index.
    loadfrommap = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Enumeration specifying to which old table this packet applies.
    index = (efiOldTableList)((_pg_data[_pg_byteindex]) & 0x3F);

    // This bit must be clear for a 1.x table.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] >> 7);
    // Decoded value must be 0
    if(_pg_tempbitfield != 0)
        return false;

    // Number of rows used in this table
    // Range of numrows is 0 to 31.
    numrows = ((_pg_data[_pg_byteindex + 2]) & 0x1F);

    // Number of columns used in this table
    // Range of numcols is 0 to 31.
    numcols = ((_pg_data[_pg_byteindex + 3]) & 0x1F);
    _pg_byteindex += 4; // close bit field

    // The number of rows used in this table
    // Range of rowindices is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        rowindices[_pg_i] = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // The number of columns used in this table
    // Range of colindices is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        colindices[_pg_i] = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // The table data organized as row major
    // Range of data is -65504.0 to 65504.0.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            data[_pg_i][_pg_j] = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    if(_pg_byteindex + 1*numrows*numcols > _pg_numbytes)
        return true;

    // The table meta data organized as row major
    // Range of meta is 0 to 255.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            meta[_pg_i][_pg_j] = uint8FromBytes(_pg_data, &_pg_byteindex);

    return true;

}// efiTable2D_1x_t::decode

/*!
 * \brief Verify a efiTable2D_1x_t has acceptable values.
 *
 * Verify a efiTable2D_1x_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \return true if all verifiable data where valid, else false if data had to be corrected
 */
bool efiTable2D_1x_t::verify(void)
{
    bool _pg_good = true;

    // Enumeration specifying to which old table this packet applies.
    if(index > EFI_OLDTABLE_MAXINDEX)
    {
        index = EFI_OLDTABLE_MAXINDEX;
        _pg_good = false;
    }

    // Number of rows used in this table
    if(numrows > EFI_TABLE_MAX_ROWS)
    {
        numrows = EFI_TABLE_MAX_ROWS;
        _pg_good = false;
    }

    // Number of columns used in this table
    if(numcols > EFI_TABLE_MAX_COLS)
    {
        numcols = EFI_TABLE_MAX_COLS;
        _pg_good = false;
    }

    return _pg_good;

}// efiTable2D_1x_t::verify

/*!
 * \brief Create the efiTable2D packet
 *
 * This packet is used to change or request a 2D table. It should not be used
 * when communicating with 1.x IntelliJect. Send this packet with just the
 * first byte to request a specific table.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTable2D_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    // Table enable. If clear this table is not used
    _pg_data[_pg_byteindex] = (uint8_t)enabled << 7;


    // Enumeration specifying to which table this packet applies.
    _pg_data[_pg_byteindex] |= (uint8_t)index;

    // This bit must be set for a 2.x table.
    _pg_data[_pg_byteindex + 1] = (uint8_t)1 << 7;

    // If set the result of the table interpolation is added to 1.0 after applying the multiplier and divider.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)addone << 6;


    _pg_data[_pg_byteindex + 2] = 0;

    // Enumeration identifying what variable is used for the row index
    _pg_data[_pg_byteindex + 2] |= (uint8_t)rowindex;

    _pg_data[_pg_byteindex + 3] = 0;

    // Enumeration identifying what variable is used for the column index
    _pg_data[_pg_byteindex + 3] |= (uint8_t)colindex;

    _pg_data[_pg_byteindex + 4] = 0;

    // Enumeration identifying what variable is used to multiply the table output
    _pg_data[_pg_byteindex + 4] |= (uint8_t)multiplierindex;

    _pg_data[_pg_byteindex + 5] = 0;

    // Enumeration identifying what variable is used to divide the table output
    _pg_data[_pg_byteindex + 5] |= (uint8_t)dividerindex;
    _pg_byteindex += 6; // close bit field


    // User definable name for the table.
    stringToBytes(description, _pg_data, &_pg_byteindex, 28, 0);

    uint32ToBeBytes((uint32_t)(0), _pg_data, &_pg_byteindex);

    _pg_data[_pg_byteindex] = 0;

    // Number of rows used in this table
    // Range of numrows is 0 to EFI_TABLE_MAX_ROWS.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(numrows, EFI_TABLE_MAX_ROWS);

    _pg_data[_pg_byteindex + 1] = 0;

    // Number of columns used in this table
    // Range of numcols is 0 to EFI_TABLE_MAX_COLS.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)limitMax(numcols, EFI_TABLE_MAX_COLS);
    _pg_byteindex += 2; // close bit field


    // The number of rows used in this table
    // Range of rowindices is -3.4027717462407993e+38 to 3.4027717462407993e+38.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        float24ToBeBytes((float)rowindices[_pg_i], _pg_data, &_pg_byteindex, 15);

    // The number of columns used in this table
    // Range of colindices is -3.4027717462407993e+38 to 3.4027717462407993e+38.
    for(_pg_i = 0; _pg_i < (unsigned)numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        float24ToBeBytes((float)colindices[_pg_i], _pg_data, &_pg_byteindex, 15);

    // The table data organized as row major
    // Range of data is -3.4027717462407993e+38 to 3.4027717462407993e+38.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            float24ToBeBytes((float)data[_pg_i][_pg_j], _pg_data, &_pg_byteindex, 15);

    // The table meta data organized as row major
    // Range of meta is 0 to 255.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            uint8ToBytes(meta[_pg_i][_pg_j], _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTable2D_t::encode

/*!
 * \brief Decode the efiTable2D packet
 *
 * This packet is used to change or request a 2D table. It should not be used
 * when communicating with 1.x IntelliJect. Send this packet with just the
 * first byte to request a specific table.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTable2D_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Table enable. If clear this table is not used
    enabled = (_pg_data[_pg_byteindex] >> 7);

    // Enumeration specifying to which table this packet applies.
    index = (efiTableList)((_pg_data[_pg_byteindex]) & 0x3F);

    // This bit must be set for a 2.x table.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] >> 7);
    // Decoded value must be 1
    if(_pg_tempbitfield != 1)
        return false;

    // If set the result of the table interpolation is added to 1.0 after applying the multiplier and divider.
    addone = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // Enumeration identifying what variable is used for the row index
    rowindex = (efiTableIndex)((_pg_data[_pg_byteindex + 2]) & 0x3F);

    // Enumeration identifying what variable is used for the column index
    colindex = (efiTableIndex)((_pg_data[_pg_byteindex + 3]) & 0x3F);

    // Enumeration identifying what variable is used to multiply the table output
    multiplierindex = (efiTableIndex)((_pg_data[_pg_byteindex + 4]) & 0x3F);

    // Enumeration identifying what variable is used to divide the table output
    dividerindex = (efiTableIndex)((_pg_data[_pg_byteindex + 5]) & 0x3F);
    _pg_byteindex += 6; // close bit field

    // User definable name for the table.
    stringFromBytes(description, _pg_data, &_pg_byteindex, 28, 0);

    // Skip over reserved space
    _pg_byteindex += 4;

    // Number of rows used in this table
    // Range of numrows is 0 to 31.
    numrows = ((_pg_data[_pg_byteindex]) & 0x1F);

    // Number of columns used in this table
    // Range of numcols is 0 to 31.
    numcols = ((_pg_data[_pg_byteindex + 1]) & 0x1F);
    _pg_byteindex += 2; // close bit field

    // The number of rows used in this table
    // Range of rowindices is -3.4027717462407993e+38 to 3.4027717462407993e+38.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        rowindices[_pg_i] = float24FromBeBytes(_pg_data, &_pg_byteindex, 15);

    // The number of columns used in this table
    // Range of colindices is -3.4027717462407993e+38 to 3.4027717462407993e+38.
    for(_pg_i = 0; _pg_i < (unsigned)numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        colindices[_pg_i] = float24FromBeBytes(_pg_data, &_pg_byteindex, 15);

    // The table data organized as row major
    // Range of data is -3.4027717462407993e+38 to 3.4027717462407993e+38.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            data[_pg_i][_pg_j] = float24FromBeBytes(_pg_data, &_pg_byteindex, 15);

    // The table meta data organized as row major
    // Range of meta is 0 to 255.
    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            meta[_pg_i][_pg_j] = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    return true;

}// efiTable2D_t::decode

/*!
 * \brief Verify a efiTable2D_t has acceptable values.
 *
 * Verify a efiTable2D_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \return true if all verifiable data where valid, else false if data had to be corrected
 */
bool efiTable2D_t::verify(void)
{
    bool _pg_good = true;

    // Enumeration specifying to which table this packet applies.
    if(index > EFI_TABLE_MAXINDEX)
    {
        index = EFI_TABLE_MAXINDEX;
        _pg_good = false;
    }

    // Enumeration identifying what variable is used for the row index
    if(rowindex > EFI_TBLIDX_MAXINDEX)
    {
        rowindex = EFI_TBLIDX_MAXINDEX;
        _pg_good = false;
    }

    // Enumeration identifying what variable is used for the column index
    if(colindex > EFI_TBLIDX_MAXINDEX)
    {
        colindex = EFI_TBLIDX_MAXINDEX;
        _pg_good = false;
    }

    // Enumeration identifying what variable is used to multiply the table output
    if(multiplierindex > EFI_TBLIDX_MAXINDEX)
    {
        multiplierindex = EFI_TBLIDX_MAXINDEX;
        _pg_good = false;
    }

    // Enumeration identifying what variable is used to divide the table output
    if(dividerindex > EFI_TBLIDX_MAXINDEX)
    {
        dividerindex = EFI_TBLIDX_MAXINDEX;
        _pg_good = false;
    }

    // Number of rows used in this table
    if(numrows > EFI_TABLE_MAX_ROWS)
    {
        numrows = EFI_TABLE_MAX_ROWS;
        _pg_good = false;
    }

    // Number of columns used in this table
    if(numcols > EFI_TABLE_MAX_COLS)
    {
        numcols = EFI_TABLE_MAX_COLS;
        _pg_good = false;
    }

    return _pg_good;

}// efiTable2D_t::verify

/*!
 * \brief Create the efiTableValue packet
 *
 * Change a single table value and meta-value. Note that the table value packet
 * incudes a 'do not store' flag. When calibrating an engine this packet is
 * used frequently, and the do not store flag can be used to suppress the
 * non-volatile storage update. IntelliJect will respond by sending the entire
 * table back.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTableValue_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // If set the table in memory will be updated, but not stored to non-volatile storage
    _pg_data[_pg_byteindex] = (uint8_t)donotstore << 7;


    // Enumeration specifying to which table this packet applies.
    _pg_data[_pg_byteindex] |= (uint8_t)index;

    // This bit must be set for a 2.x table.
    _pg_data[_pg_byteindex + 1] = (uint8_t)1 << 7;


    // The row number, starting at zero.
    // Range of row is 0 to 31.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)row;

    _pg_data[_pg_byteindex + 2] = 0;

    // The column number, starting at zero.
    // Range of col is 0 to 31.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)col;
    _pg_byteindex += 3; // close bit field


    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // The value of this table at [row, col]
    // Range of value is -65504.0 to 65504.0.
    float16ToBeBytes((float)value, _pg_data, &_pg_byteindex, 10);

    // Meta data for this table cell
    // Range of meta is 0 to 255.
    uint8ToBytes(meta, _pg_data, &_pg_byteindex);

    // The value of this table at [row, col] at higher resolution
    // Range of value is -3.4027717462407993e+38 to 3.4027717462407993e+38.
    float24ToBeBytes((float)value, _pg_data, &_pg_byteindex, 15);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTableValue_t::encode

/*!
 * \brief Decode the efiTableValue packet
 *
 * Change a single table value and meta-value. Note that the table value packet
 * incudes a 'do not store' flag. When calibrating an engine this packet is
 * used frequently, and the do not store flag can be used to suppress the
 * non-volatile storage update. IntelliJect will respond by sending the entire
 * table back.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTableValue_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // If set the table in memory will be updated, but not stored to non-volatile storage
    donotstore = (_pg_data[_pg_byteindex] >> 7);

    // Enumeration specifying to which table this packet applies.
    index = (efiTableList)((_pg_data[_pg_byteindex]) & 0x3F);

    // This bit must be set for a 2.x table.
    version2 = (_pg_data[_pg_byteindex + 1] >> 7);

    // The row number, starting at zero.
    // Range of row is 0 to 31.
    row = ((_pg_data[_pg_byteindex + 1]) & 0x1F);

    // The column number, starting at zero.
    // Range of col is 0 to 31.
    col = ((_pg_data[_pg_byteindex + 2]) & 0x1F);
    _pg_byteindex += 3; // close bit field

    // Skip over reserved space
    _pg_byteindex += 1;

    // The value of this table at [row, col]
    // Range of value is -65504.0 to 65504.0.
    value = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Meta data for this table cell
    // Range of meta is 0 to 255.
    meta = uint8FromBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 3 > _pg_numbytes)
        return true;

    // The value of this table at [row, col] at higher resolution
    // Range of value is -3.4027717462407993e+38 to 3.4027717462407993e+38.
    value = float24FromBeBytes(_pg_data, &_pg_byteindex, 15);

    return true;

}// efiTableValue_t::decode

/*!
 * \brief Verify a efiTableValue_t has acceptable values.
 *
 * Verify a efiTableValue_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \return true if all verifiable data where valid, else false if data had to be corrected
 */
bool efiTableValue_t::verify(void)
{
    bool _pg_good = true;

    // Enumeration specifying to which table this packet applies.
    if(index > EFI_TABLE_MAXINDEX)
    {
        index = EFI_TABLE_MAXINDEX;
        _pg_good = false;
    }

    // The row number, starting at zero.
    if(row > EFI_TABLE_MAX_ROWS-1)
    {
        row = EFI_TABLE_MAX_ROWS-1;
        _pg_good = false;
    }

    // The column number, starting at zero.
    if(col > EFI_TABLE_MAX_COLS-1)
    {
        col = EFI_TABLE_MAX_COLS-1;
        _pg_good = false;
    }

    return _pg_good;

}// efiTableValue_t::verify

/*!
 * \brief Create the efiTableEnable packet
 *
 * Change the table enable and the row or column index variables and the math
 * index variables without changing the entire table. This packet is the same
 * as the Table2D packet, but it excludes the row and column indices and the
 * table data. IntelliJect will respond by sending the entire table back.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTableEnable_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Table enable. If clear this table is not used
    _pg_data[_pg_byteindex] = (uint8_t)enabled << 7;


    // Enumeration specifying to which table this packet applies.
    _pg_data[_pg_byteindex] |= (uint8_t)index;

    // This bit must be set for a 2.x table.
    _pg_data[_pg_byteindex + 1] = (uint8_t)1 << 7;

    // If set the result of the table interpolation is added to 1.0 after applying the multiplier and divider.
    _pg_data[_pg_byteindex + 1] |= (uint8_t)addone << 6;


    _pg_data[_pg_byteindex + 2] = 0;

    // Enumeration identifying what variable is used for the row index
    _pg_data[_pg_byteindex + 2] |= (uint8_t)rowindex;

    _pg_data[_pg_byteindex + 3] = 0;

    // Enumeration identifying what variable is used for the column index
    _pg_data[_pg_byteindex + 3] |= (uint8_t)colindex;

    _pg_data[_pg_byteindex + 4] = 0;

    // Enumeration identifying what variable is used to multiply the table output
    _pg_data[_pg_byteindex + 4] |= (uint8_t)multiplierindex;

    _pg_data[_pg_byteindex + 5] = 0;

    // Enumeration identifying what variable is used to divide the table output
    _pg_data[_pg_byteindex + 5] |= (uint8_t)dividerindex;
    _pg_byteindex += 6; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTableEnable_t::encode

/*!
 * \brief Decode the efiTableEnable packet
 *
 * Change the table enable and the row or column index variables and the math
 * index variables without changing the entire table. This packet is the same
 * as the Table2D packet, but it excludes the row and column indices and the
 * table data. IntelliJect will respond by sending the entire table back.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTableEnable_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Table enable. If clear this table is not used
    enabled = (_pg_data[_pg_byteindex] >> 7);

    // Enumeration specifying to which table this packet applies.
    index = (efiTableList)((_pg_data[_pg_byteindex]) & 0x3F);

    // This bit must be set for a 2.x table.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] >> 7);
    // Decoded value must be 1
    if(_pg_tempbitfield != 1)
        return false;

    // If set the result of the table interpolation is added to 1.0 after applying the multiplier and divider.
    addone = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // Enumeration identifying what variable is used for the row index
    rowindex = (efiTableIndex)((_pg_data[_pg_byteindex + 2]) & 0x3F);

    // Enumeration identifying what variable is used for the column index
    colindex = (efiTableIndex)((_pg_data[_pg_byteindex + 3]) & 0x3F);

    // Enumeration identifying what variable is used to multiply the table output
    multiplierindex = (efiTableIndex)((_pg_data[_pg_byteindex + 4]) & 0x3F);

    // Enumeration identifying what variable is used to divide the table output
    dividerindex = (efiTableIndex)((_pg_data[_pg_byteindex + 5]) & 0x3F);
    _pg_byteindex += 6; // close bit field

    return true;

}// efiTableEnable_t::decode

/*!
 * \brief Create the efiTelemetryFastSummary packet
 *
 * Summary packet that contains all the fast telemetry in a single packet.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param time is Time information for the fast telemetry
 * \param fast is Fast EFI telemetry
 */
void efiTelemetryFastSummary_t::encode(efiPacket_t* _pg_pkt, const efiTelemetryTime_t* time, const efiTelemetryFast_t* fast)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Time information for the fast telemetry
    time->encode(_pg_data, &_pg_byteindex);

    // Fast EFI telemetry
    fast->encode(_pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryFastSummary_t::encode

/*!
 * \brief Decode the efiTelemetryFastSummary packet
 *
 * Summary packet that contains all the fast telemetry in a single packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time information for the fast telemetry
 * \param fast receives Fast EFI telemetry
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryFastSummary_t::decode(const efiPacket_t* _pg_pkt, efiTelemetryTime_t* time, efiTelemetryFast_t* fast)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time information for the fast telemetry
    if(time->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fast EFI telemetry
    if(fast->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return 1;

}// efiTelemetryFastSummary_t::decode

/*!
 * \brief Create the efiEngineWearExtended packet
 *
 * Engine wear information beyond just hobbs and revcount, output at the slow
 * telemetry rate over the CAN bus. This packet, in combination with
 * `EngineWearShort` is equivalent to the full `EngineWear` packet.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param hotTime is Seconds the engine has spent running above the CHT limit
 * \param highLoadTime is Seconds the engine has spent running at high load (throttle greater than 80%).
 * \param peakCHT is Highest head temperature observed while the engine was running
 * \param numStarts is Number of times the engine has started
 */
void efiEngineWearExtended_t::encode(efiPacket_t* _pg_pkt, uint32_t hotTime, uint32_t highLoadTime, float peakCHT, uint16_t numStarts)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Seconds the engine has spent running above the CHT limit
    // Range of hotTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)hotTime, 0.0f, 0.1f, 20);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // Seconds the engine has spent running at high load (throttle greater than 80%).
    // Range of highLoadTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)highLoadTime, 0.0f, 0.1f, 20);
    _pg_data[_pg_byteindex + 4] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 5; // close bit field

    // Highest head temperature observed while the engine was running
    // Range of peakCHT is 0.0 to 510.0.
    float32ScaledTo1UnsignedBytes(peakCHT, _pg_data, &_pg_byteindex, 0.0f, 0.5f);

    _pg_data[_pg_byteindex] = 0;

    // Number of times the engine has started
    // Range of numStarts is 0 to 4095.
    _pg_tempbitfield = (unsigned int)limitMax(numStarts, 4095);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiEngineWearExtended_t::encode

/*!
 * \brief Decode the efiEngineWearExtended packet
 *
 * Engine wear information beyond just hobbs and revcount, output at the slow
 * telemetry rate over the CAN bus. This packet, in combination with
 * `EngineWearShort` is equivalent to the full `EngineWear` packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param hotTime receives Seconds the engine has spent running above the CHT limit
 * \param highLoadTime receives Seconds the engine has spent running at high load (throttle greater than 80%).
 * \param peakCHT receives Highest head temperature observed while the engine was running
 * \param numStarts receives Number of times the engine has started
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiEngineWearExtended_t::decode(const efiPacket_t* _pg_pkt, uint32_t* hotTime, uint32_t* highLoadTime, float* peakCHT, uint16_t* numStarts)
{
    unsigned int _pg_tempbitfield = 0;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Seconds the engine has spent running above the CHT limit
    // Range of hotTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    (*hotTime) = (uint32_t)float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/0.1f);

    // Seconds the engine has spent running at high load (throttle greater than 80%).
    // Range of highLoadTime is 0.0 to 10485750.0.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 4];

    (*highLoadTime) = (uint32_t)float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/0.1f);
    _pg_byteindex += 5; // close bit field

    // Highest head temperature observed while the engine was running
    // Range of peakCHT is 0.0 to 510.0.
    (*peakCHT) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.5f);

    // Number of times the engine has started
    // Range of numStarts is 0 to 4095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    (*numStarts) = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    return 1;

}// efiEngineWearExtended_t::decode

/*!
 * \brief Create the efiTelemetryAutoFuel packet
 *
 * Automatic fuel determination packet. This packet reports the results of the
 * autofuel algorithm, each time it runs.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryAutoFuel_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Correlation value between fuel multiplier and specific power.
    // Range of correlation is -65504.0 to 65504.0.
    float16ToBeBytes((float)correlation, _pg_data, &_pg_byteindex, 10);

    // Pearson's correlation coefficient from 0.0 to 1.0
    // Range of coefficient is 0.0 to 1.275.
    float32ScaledTo1UnsignedBytes(coefficient, _pg_data, &_pg_byteindex, 0.0f, 200.0f);

    // Time delay in seconds for maximum correlation magnitude.
    // Range of timedelay is 0.0 to 12.75.
    float32ScaledTo1UnsignedBytes(timedelay, _pg_data, &_pg_byteindex, 0.0f, 20.0f);

    uint32ToBeBytes((uint32_t)(0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryAutoFuel_t::encode

/*!
 * \brief Decode the efiTelemetryAutoFuel packet
 *
 * Automatic fuel determination packet. This packet reports the results of the
 * autofuel algorithm, each time it runs.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryAutoFuel_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Correlation value between fuel multiplier and specific power.
    // Range of correlation is -65504.0 to 65504.0.
    correlation = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Pearson's correlation coefficient from 0.0 to 1.0
    // Range of coefficient is 0.0 to 1.275.
    coefficient = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/200.0f);

    // Time delay in seconds for maximum correlation magnitude.
    // Range of timedelay is 0.0 to 12.75.
    timedelay = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/20.0f);

    // Skip over reserved space
    _pg_byteindex += 4;

    return true;

}// efiTelemetryAutoFuel_t::decode

/*!
 * \brief Create the efiTelemetryOilInjection packet
 *
 * Telemetry about the oil injection system. The oil injection system must be
 * enabled in the injector configuration. If oil injection is not enabled this
 * packet will not be sent.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryOilInjection_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Oil flow rate in grams per minute.
    // Range of oilFlowRate is -65504.0 to 65504.0.
    float16ToBeBytes((float)oilFlowRate, _pg_data, &_pg_byteindex, 10);

    // Oil consumption in grams since the system turned on.
    // Range of oilConsumption is -65504.0 to 65504.0.
    float16ToBeBytes((float)oilConsumption, _pg_data, &_pg_byteindex, 10);

    // Oil injector pump duty cycle in percent
    // Range of oilDuty is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(oilDuty, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Oil injector pump frequency in Hz
    // Range of oilFreq is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(oilFreq, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Number of oil injection priming pulses remaining, zero if priming is off
    // Range of oilPrimeLeft is 0.0 to 5100.0.
    float32ScaledTo1UnsignedBytes((float)oilPrimeLeft, _pg_data, &_pg_byteindex, 0.0f, 0.05f);

    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryOilInjection_t::encode

/*!
 * \brief Decode the efiTelemetryOilInjection packet
 *
 * Telemetry about the oil injection system. The oil injection system must be
 * enabled in the injector configuration. If oil injection is not enabled this
 * packet will not be sent.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryOilInjection_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Oil flow rate in grams per minute.
    // Range of oilFlowRate is -65504.0 to 65504.0.
    oilFlowRate = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Oil consumption in grams since the system turned on.
    // Range of oilConsumption is -65504.0 to 65504.0.
    oilConsumption = float16FromBeBytes(_pg_data, &_pg_byteindex, 10);

    // Oil injector pump duty cycle in percent
    // Range of oilDuty is 0.0 to 127.5.
    oilDuty = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Oil injector pump frequency in Hz
    // Range of oilFreq is 0.0 to 25.5.
    oilFreq = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Number of oil injection priming pulses remaining, zero if priming is off
    // Range of oilPrimeLeft is 0.0 to 5100.0.
    oilPrimeLeft = (uint16_t)float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.05f);

    // Skip over reserved space
    _pg_byteindex += 1;

    return true;

}// efiTelemetryOilInjection_t::decode


/*!
 * \brief Lookup title for 'gcuSource' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string title of the given entry (comment if no title given)
 */
const char* gcuSource_EnumTitle(int value)
{
    switch (value)
    {
    default:
        return "";
    case NWGCU:
        return translateeficomms("Northwest GCU");
    case MWPMU:
        return translateeficomms("Millswood PMU");
    case P4FGEN:
        return translateeficomms("P4F Generator");
    }
}

/*!
 * \brief Create the efiTelemetryGCU packet
 *
 * Telemetry about the Generator Control Unit (GCU). The GCU is external
 * hardware that sends status information on the CAN bus. This packet is only
 * sent by IntelliJect if the GCU data are detected on the CAN bus. Detection
 * of the GCU is always visible in the [CPU telemetry](#EFI_PKT_TELEMETRYCPU)
 * packet.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTelemetryGCU_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Enumeration describing the source of the GCU information
    _pg_data[_pg_byteindex] = (uint8_t)source << 6;

    // Voltage of the 28 V rail
    // Range of volts28 is 0.0 to 163.83.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)volts28, 0.0f, 100.0f, 14);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;

    // Voltage of the 12 V rail
    // Range of volts12 is 0.0 to 40.95.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)volts12, 0.0f, 100.0f, 12);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;


    // Voltage of the 6 V rail
    // Range of volts6 is 0.0 to 40.95.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)volts6, 0.0f, 100.0f, 12);
    _pg_data[_pg_byteindex + 4] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 5; // close bit field


    // Internal temperature of the GCU in Celsius
    // Range of gcuTemp is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(gcuTemp, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Set if the GCU is cranking the engine for start
    _pg_data[_pg_byteindex] = (uint8_t)cranking << 7;

    // Set if the GCU is making electricity from the generator
    _pg_data[_pg_byteindex] |= (uint8_t)generating << 6;

    // Set if the GCU is charging the battery
    _pg_data[_pg_byteindex] |= (uint8_t)charging << 5;

    // Set if the GCU starter is available
    _pg_data[_pg_byteindex] |= (uint8_t)startAvailable << 4;

    // Current in Amps of the 28 V rail
    // Range of current28 is 0.0 to 40.95.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)current28, 0.0f, 100.0f, 12);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetryGCU_t::encode

/*!
 * \brief Decode the efiTelemetryGCU packet
 *
 * Telemetry about the Generator Control Unit (GCU). The GCU is external
 * hardware that sends status information on the CAN bus. This packet is only
 * sent by IntelliJect if the GCU data are detected on the CAN bus. Detection
 * of the GCU is always visible in the [CPU telemetry](#EFI_PKT_TELEMETRYCPU)
 * packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetryGCU_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Enumeration describing the source of the GCU information
    source = (gcuSource)(_pg_data[_pg_byteindex] >> 6);

    // Voltage of the 28 V rail
    // Range of volts28 is 0.0 to 163.83.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    volts28 = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/100.0f);

    // Voltage of the 12 V rail
    // Range of volts12 is 0.0 to 40.95.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 4);

    volts12 = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/100.0f);

    // Voltage of the 6 V rail
    // Range of volts6 is 0.0 to 40.95.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 3] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 4];

    volts6 = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/100.0f);
    _pg_byteindex += 5; // close bit field

    // Internal temperature of the GCU in Celsius
    // Range of gcuTemp is 0.0 to 127.5.
    gcuTemp = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Set if the GCU is cranking the engine for start
    cranking = (_pg_data[_pg_byteindex] >> 7);

    // Set if the GCU is making electricity from the generator
    generating = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if the GCU is charging the battery
    charging = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if the GCU starter is available
    startAvailable = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Current in Amps of the 28 V rail
    // Range of current28 is 0.0 to 40.95.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    current28 = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/100.0f);
    _pg_byteindex += 2; // close bit field

    return true;

}// efiTelemetryGCU_t::decode

/*!
 * \brief Decode the efiTelemetrySlowSummaryapi0 packet
 *
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time information for the slow telemetry
 * \param sensors receives First set of sensor information
 * \param sensors2 receives Second set of sensor information
 * \param fuel receives Fuel flow and fuel used information
 * \param injector receives Injector(s) information
 * \param slow receives Slow telemetry data
 * \param cpu receives Run time CPU information
 * \param sensors3 receives Third set of sensor information
 * \param dynamicError receives Dynamic engine errors
 * \param stickyError receives Sticky engine errors
 * \param wear receives Short engine wear information
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlowSummaryapi0_t::decode(const efiPacket_t* _pg_pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3api0_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWearShort_t* wear)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time information for the slow telemetry
    if(time->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // First set of sensor information
    if(sensors->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Second set of sensor information
    if(sensors2->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fuel flow and fuel used information
    if(fuel->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Injector(s) information
    if(injector->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Slow telemetry data
    if(slow->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Run time CPU information
    if(cpu->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Third set of sensor information
    if(sensors3->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Dynamic engine errors
    if(dynamicError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Sticky engine errors
    if(stickyError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Short engine wear information
    if(wear->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return 1;

}// efiTelemetrySlowSummaryapi0_t::decode

/*!
 * \brief Decode the efiTelemetrySlowSummaryapi1 packet
 *
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time information for the slow telemetry
 * \param sensors receives First set of sensor information
 * \param sensors2 receives Second set of sensor information
 * \param fuel receives Fuel flow and fuel used information
 * \param injector receives Injector(s) information
 * \param slow receives Slow telemetry data
 * \param cpu receives Run time CPU information
 * \param sensors3 receives Third set of sensor information
 * \param dynamicError receives Dynamic engine errors
 * \param stickyError receives Sticky engine errors
 * \param wear receives Short engine wear information
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlowSummaryapi1_t::decode(const efiPacket_t* _pg_pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWearShort_t* wear)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time information for the slow telemetry
    if(time->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // First set of sensor information
    if(sensors->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Second set of sensor information
    if(sensors2->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fuel flow and fuel used information
    if(fuel->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Injector(s) information
    if(injector->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Slow telemetry data
    if(slow->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Run time CPU information
    if(cpu->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Third set of sensor information
    if(sensors3->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Dynamic engine errors
    if(dynamicError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Sticky engine errors
    if(stickyError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Short engine wear information
    if(wear->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return 1;

}// efiTelemetrySlowSummaryapi1_t::decode

/*!
 * \brief Decode the efiTelemetrySlowSummaryapi2 packet
 *
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time information for the slow telemetry
 * \param sensors receives First set of sensor information
 * \param sensors2 receives Second set of sensor information
 * \param fuel receives Fuel flow and fuel used information
 * \param injector receives Injector(s) information
 * \param slow receives Slow telemetry data
 * \param cpu receives Run time CPU information
 * \param sensors3 receives Third set of sensor information
 * \param dynamicError receives Dynamic engine errors
 * \param stickyError receives Sticky engine errors
 * \param wear receives Short engine wear information
 * \param comms receives Communications error and performance information
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlowSummaryapi2_t::decode(const efiPacket_t* _pg_pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWearShort_t* wear, efiTelemetryComms_t* comms)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time information for the slow telemetry
    if(time->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // First set of sensor information
    if(sensors->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Second set of sensor information
    if(sensors2->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fuel flow and fuel used information
    if(fuel->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Injector(s) information
    if(injector->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Slow telemetry data
    if(slow->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Run time CPU information
    if(cpu->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Third set of sensor information
    if(sensors3->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Dynamic engine errors
    if(dynamicError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Sticky engine errors
    if(stickyError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Short engine wear information
    if(wear->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Communications error and performance information
    if(comms->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return 1;

}// efiTelemetrySlowSummaryapi2_t::decode

/*!
 * \brief Decode the efiTelemetrySlowSummaryapi3 packet
 *
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time information for the slow telemetry
 * \param sensors receives First set of sensor information
 * \param sensors2 receives Second set of sensor information
 * \param fuel receives Fuel flow and fuel used information
 * \param injector receives Injector(s) information
 * \param slow receives Slow telemetry data
 * \param cpu receives Run time CPU information
 * \param sensors3 receives Third set of sensor information
 * \param dynamicError receives Dynamic engine errors
 * \param stickyError receives Sticky engine errors
 * \param wear receives Short engine wear information
 * \param comms receives Communications error and performance information
 * \param sensors4 receives Fourth set of sensor information
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlowSummaryapi3_t::decode(const efiPacket_t* _pg_pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWearShort_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time information for the slow telemetry
    if(time->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // First set of sensor information
    if(sensors->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Second set of sensor information
    if(sensors2->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fuel flow and fuel used information
    if(fuel->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Injector(s) information
    if(injector->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Slow telemetry data
    if(slow->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Run time CPU information
    if(cpu->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Third set of sensor information
    if(sensors3->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Dynamic engine errors
    if(dynamicError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Sticky engine errors
    if(stickyError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Short engine wear information
    if(wear->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Communications error and performance information
    if(comms->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fourth set of sensor information
    if(sensors4->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return 1;

}// efiTelemetrySlowSummaryapi3_t::decode

/*!
 * \brief Decode the efiTelemetrySlowSummaryapi4 packet
 *
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time information for the slow telemetry
 * \param sensors receives First set of sensor information
 * \param sensors2 receives Second set of sensor information
 * \param fuel receives Fuel flow and fuel used information
 * \param injector receives Injector(s) information
 * \param slow receives Slow telemetry data
 * \param cpu receives Run time CPU information
 * \param sensors3 receives Third set of sensor information
 * \param dynamicError receives Dynamic engine errors
 * \param stickyError receives Sticky engine errors
 * \param wear receives Engine wear information
 * \param comms receives Communications error and performance information
 * \param sensors4 receives Fourth set of sensor information
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlowSummaryapi4_t::decode(const efiPacket_t* _pg_pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWear_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time information for the slow telemetry
    if(time->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // First set of sensor information
    if(sensors->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Second set of sensor information
    if(sensors2->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fuel flow and fuel used information
    if(fuel->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Injector(s) information
    if(injector->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Slow telemetry data
    if(slow->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Run time CPU information
    if(cpu->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Third set of sensor information
    if(sensors3->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Dynamic engine errors
    if(dynamicError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Sticky engine errors
    if(stickyError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Engine wear information
    if(wear->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Communications error and performance information
    if(comms->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fourth set of sensor information
    if(sensors4->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return 1;

}// efiTelemetrySlowSummaryapi4_t::decode

/*!
 * \brief Decode the efiTelemetrySlowSummaryapi5 packet
 *
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time information for the slow telemetry
 * \param sensors receives First set of sensor information
 * \param sensors2 receives Second set of sensor information
 * \param fuel receives Fuel flow and fuel used information
 * \param injector receives Injector(s) information
 * \param slow receives Slow telemetry data
 * \param cpu receives Run time CPU information
 * \param sensors3 receives Third set of sensor information
 * \param dynamicError receives Dynamic engine errors
 * \param stickyError receives Sticky engine errors
 * \param wear receives Engine wear information
 * \param comms receives Communications error and performance information
 * \param sensors4 receives Fourth set of sensor information
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlowSummaryapi5_t::decode(const efiPacket_t* _pg_pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPU_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrors_t* dynamicError, efiErrors_t* stickyError, efiEngineWear_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time information for the slow telemetry
    if(time->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // First set of sensor information
    if(sensors->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Second set of sensor information
    if(sensors2->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fuel flow and fuel used information
    if(fuel->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Injector(s) information
    if(injector->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Slow telemetry data
    if(slow->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Run time CPU information
    if(cpu->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Third set of sensor information
    if(sensors3->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Dynamic engine errors
    if(dynamicError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Sticky engine errors
    if(stickyError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Engine wear information
    if(wear->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Communications error and performance information
    if(comms->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fourth set of sensor information
    if(sensors4->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return 1;

}// efiTelemetrySlowSummaryapi5_t::decode

/*!
 * \brief Decode the efiTelemetrySlowSummaryapi7 packet
 *
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time information for the slow telemetry
 * \param sensors receives First set of sensor information
 * \param sensors2 receives Second set of sensor information
 * \param fuel receives Fuel flow and fuel used information
 * \param injector receives Injector(s) information
 * \param slow receives Slow telemetry data
 * \param cpu receives Run time CPU information
 * \param sensors3 receives Third set of sensor information
 * \param dynamicError receives Dynamic engine errors
 * \param stickyError receives Sticky engine errors
 * \param wear receives Engine wear information
 * \param comms receives Communications error and performance information
 * \param sensors4 receives Fourth set of sensor information
 * \param sdcard receives SD Card telemetry information
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlowSummaryapi7_t::decode(const efiPacket_t* _pg_pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPU_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrors_t* dynamicError, efiErrors_t* stickyError, efiEngineWear_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4, efiTelemetrySDCard_t* sdcard)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time information for the slow telemetry
    if(time->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // First set of sensor information
    if(sensors->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Second set of sensor information
    if(sensors2->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fuel flow and fuel used information
    if(fuel->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Injector(s) information
    if(injector->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Slow telemetry data
    if(slow->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Run time CPU information
    if(cpu->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Third set of sensor information
    if(sensors3->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Dynamic engine errors
    if(dynamicError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Sticky engine errors
    if(stickyError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Engine wear information
    if(wear->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Communications error and performance information
    if(comms->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fourth set of sensor information
    if(sensors4->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // SD Card telemetry information
    if(sdcard->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return 1;

}// efiTelemetrySlowSummaryapi7_t::decode

/*!
 * \brief Create the efiTelemetrySlowSummary packet
 *
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param time is Time information for the slow telemetry
 * \param sensors is First set of sensor information
 * \param sensors2 is Second set of sensor information
 * \param fuel is Fuel flow and fuel used information
 * \param injector is Injector(s) information
 * \param slow is Slow telemetry data
 * \param cpu is Run time CPU information
 * \param sensors3 is Third set of sensor information
 * \param dynamicError is Dynamic engine errors
 * \param stickyError is Sticky engine errors
 * \param wear is Engine wear information
 * \param comms is Communications error and performance information
 * \param sensors4 is Fourth set of sensor information
 * \param sdcard is SD Card telemetry information
 * \param extendedoutputs is Telemetry for injector3, spark2, and spark3
 */
void efiTelemetrySlowSummary_t::encode(efiPacket_t* _pg_pkt, const efiTelemetryTime_t* time, const efiTelemetrySensors_t* sensors, const efiTelemetrySensors2_t* sensors2, const efiTelemetryFuel_t* fuel, const efiTelemetryInjector_t* injector, const efiTelemetrySlow_t* slow, const efiTelemetryCPU_t* cpu, const efiTelemetrySensors3_t* sensors3, const efiErrors_t* dynamicError, const efiErrors_t* stickyError, const efiEngineWear_t* wear, const efiTelemetryComms_t* comms, const efiTelemetrySensors4_t* sensors4, const efiTelemetrySDCard_t* sdcard, const efiTelemetryExtendedOutputs_t* extendedoutputs)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Time information for the slow telemetry
    time->encode(_pg_data, &_pg_byteindex);

    // First set of sensor information
    sensors->encode(_pg_data, &_pg_byteindex);

    // Second set of sensor information
    sensors2->encode(_pg_data, &_pg_byteindex);

    // Fuel flow and fuel used information
    fuel->encode(_pg_data, &_pg_byteindex);

    // Injector(s) information
    injector->encode(_pg_data, &_pg_byteindex);

    // Slow telemetry data
    slow->encode(_pg_data, &_pg_byteindex);

    // Run time CPU information
    cpu->encode(_pg_data, &_pg_byteindex);

    // Third set of sensor information
    sensors3->encode(_pg_data, &_pg_byteindex);

    // Dynamic engine errors
    dynamicError->encode(_pg_data, &_pg_byteindex);

    // Sticky engine errors
    stickyError->encode(_pg_data, &_pg_byteindex);

    // Engine wear information
    wear->encode(_pg_data, &_pg_byteindex);

    // Communications error and performance information
    comms->encode(_pg_data, &_pg_byteindex);

    // Fourth set of sensor information
    sensors4->encode(_pg_data, &_pg_byteindex);

    // SD Card telemetry information
    sdcard->encode(_pg_data, &_pg_byteindex);

    // Telemetry for injector3, spark2, and spark3
    extendedoutputs->encode(_pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTelemetrySlowSummary_t::encode

/*!
 * \brief Decode the efiTelemetrySlowSummary packet
 *
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time information for the slow telemetry
 * \param sensors receives First set of sensor information
 * \param sensors2 receives Second set of sensor information
 * \param fuel receives Fuel flow and fuel used information
 * \param injector receives Injector(s) information
 * \param slow receives Slow telemetry data
 * \param cpu receives Run time CPU information
 * \param sensors3 receives Third set of sensor information
 * \param dynamicError receives Dynamic engine errors
 * \param stickyError receives Sticky engine errors
 * \param wear receives Engine wear information
 * \param comms receives Communications error and performance information
 * \param sensors4 receives Fourth set of sensor information
 * \param sdcard receives SD Card telemetry information
 * \param extendedoutputs receives Telemetry for injector3, spark2, and spark3
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTelemetrySlowSummary_t::decode(const efiPacket_t* _pg_pkt, efiTelemetryTime_t* time, efiTelemetrySensors_t* sensors, efiTelemetrySensors2_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlow_t* slow, efiTelemetryCPU_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrors_t* dynamicError, efiErrors_t* stickyError, efiEngineWear_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4, efiTelemetrySDCard_t* sdcard, efiTelemetryExtendedOutputs_t* extendedoutputs)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time information for the slow telemetry
    if(time->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // First set of sensor information
    if(sensors->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Second set of sensor information
    if(sensors2->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fuel flow and fuel used information
    if(fuel->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Injector(s) information
    if(injector->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Slow telemetry data
    if(slow->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Run time CPU information
    if(cpu->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Third set of sensor information
    if(sensors3->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Dynamic engine errors
    if(dynamicError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Sticky engine errors
    if(stickyError->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Engine wear information
    if(wear->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Communications error and performance information
    if(comms->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Fourth set of sensor information
    if(sensors4->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // SD Card telemetry information
    if(sdcard->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Telemetry for injector3, spark2, and spark3
    if(extendedoutputs->decode(_pg_data, &_pg_byteindex) == false)
        return false;

    return 1;

}// efiTelemetrySlowSummary_t::decode

/*!
 * \brief Create the efiResetStickyCounter packet
 *
 * This packet is used to record the number of times the CPU has reset.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param stickyresetcount is Non-volatile reset count information. Each time the system boots up, it increments this counter.
 */
void efiResetStickyCounter_t::encode(efiPacket_t* _pg_pkt, uint16_t stickyresetcount)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Non-volatile reset count information. Each time the system boots up, it increments this counter.
    // Range of stickyresetcount is 0 to 65535.
    uint16ToBeBytes(stickyresetcount, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiResetStickyCounter_t::encode

/*!
 * \brief Decode the efiResetStickyCounter packet
 *
 * This packet is used to record the number of times the CPU has reset.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param stickyresetcount receives Non-volatile reset count information. Each time the system boots up, it increments this counter.
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiResetStickyCounter_t::decode(const efiPacket_t* _pg_pkt, uint16_t* stickyresetcount)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Non-volatile reset count information. Each time the system boots up, it increments this counter.
    // Range of stickyresetcount is 0 to 65535.
    (*stickyresetcount) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// efiResetStickyCounter_t::decode


/*!
 * \brief Lookup label for 'efiExceptionId' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* efiExceptionId_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case EFI_EXC_NMI:
        return translateeficomms("EFI_EXC_NMI");
    case EFI_EXC_HARD_FAULT:
        return translateeficomms("EFI_EXC_HARD_FAULT");
    case EFI_EXC_MEM_MANAGE:
        return translateeficomms("EFI_EXC_MEM_MANAGE");
    case EFI_EXC_BUS_FAULT:
        return translateeficomms("EFI_EXC_BUS_FAULT");
    case EFI_EXC_USAGE_FAULT:
        return translateeficomms("EFI_EXC_USAGE_FAULT");
    case EFI_EXC_SV_CALL:
        return translateeficomms("EFI_EXC_SV_CALL");
    case EFI_EXC_DEBUG_MONITOR:
        return translateeficomms("EFI_EXC_DEBUG_MONITOR");
    case EFI_EXC_PEND_SV:
        return translateeficomms("EFI_EXC_PEND_SV");
    case EFI_EXC_SYSTICK:
        return translateeficomms("EFI_EXC_SYSTICK");
    case EFI_INT_WWDG:
        return translateeficomms("EFI_INT_WWDG");
    case EFI_INT_PVD:
        return translateeficomms("EFI_INT_PVD");
    case EFI_INT_TAMP_STAMP:
        return translateeficomms("EFI_INT_TAMP_STAMP");
    case EFI_INT_RTC_WKUP:
        return translateeficomms("EFI_INT_RTC_WKUP");
    case EFI_INT_FLASH:
        return translateeficomms("EFI_INT_FLASH");
    case EFI_INT_RCC:
        return translateeficomms("EFI_INT_RCC");
    case EFI_INT_EXTI0:
        return translateeficomms("EFI_INT_EXTI0");
    case EFI_INT_EXTI1:
        return translateeficomms("EFI_INT_EXTI1");
    case EFI_INT_EXTI2:
        return translateeficomms("EFI_INT_EXTI2");
    case EFI_INT_EXTI3:
        return translateeficomms("EFI_INT_EXTI3");
    case EFI_INT_EXTI4:
        return translateeficomms("EFI_INT_EXTI4");
    case EFI_INT_DMA1_Stream0:
        return translateeficomms("EFI_INT_DMA1_Stream0");
    case EFI_INT_DMA1_Stream1:
        return translateeficomms("EFI_INT_DMA1_Stream1");
    case EFI_INT_DMA1_Stream2:
        return translateeficomms("EFI_INT_DMA1_Stream2");
    case EFI_INT_DMA1_Stream3:
        return translateeficomms("EFI_INT_DMA1_Stream3");
    case EFI_INT_DMA1_Stream4:
        return translateeficomms("EFI_INT_DMA1_Stream4");
    case EFI_INT_DMA1_Stream5:
        return translateeficomms("EFI_INT_DMA1_Stream5");
    case EFI_INT_DMA1_Stream6:
        return translateeficomms("EFI_INT_DMA1_Stream6");
    case EFI_INT_ADC:
        return translateeficomms("EFI_INT_ADC");
    case EFI_INT_CAN1_TX:
        return translateeficomms("EFI_INT_CAN1_TX");
    case EFI_INT_CAN1_RX0:
        return translateeficomms("EFI_INT_CAN1_RX0");
    case EFI_INT_CAN1_RX1:
        return translateeficomms("EFI_INT_CAN1_RX1");
    case EFI_INT_CAN1_SCE:
        return translateeficomms("EFI_INT_CAN1_SCE");
    case EFI_INT_EXTI9_5:
        return translateeficomms("EFI_INT_EXTI9_5");
    case EFI_INT_TIM1_BRK_TIM9:
        return translateeficomms("EFI_INT_TIM1_BRK_TIM9");
    case EFI_INT_TIM1_UP_TIM10:
        return translateeficomms("EFI_INT_TIM1_UP_TIM10");
    case EFI_INT_TIM_TRG_COM_TIM11:
        return translateeficomms("EFI_INT_TIM_TRG_COM_TIM11");
    case EFI_INT_TIM1_CC:
        return translateeficomms("EFI_INT_TIM1_CC");
    case EFI_INT_TIM2:
        return translateeficomms("EFI_INT_TIM2");
    case EFI_INT_TIM3:
        return translateeficomms("EFI_INT_TIM3");
    case EFI_INT_TIM4:
        return translateeficomms("EFI_INT_TIM4");
    case EFI_INT_I2C1_EVT:
        return translateeficomms("EFI_INT_I2C1_EVT");
    case EFI_INT_I2C1_ERR:
        return translateeficomms("EFI_INT_I2C1_ERR");
    case EFI_INT_I2C2_EVT:
        return translateeficomms("EFI_INT_I2C2_EVT");
    case EFI_INT_I2C2_ERR:
        return translateeficomms("EFI_INT_I2C2_ERR");
    case EFI_INT_SPI1:
        return translateeficomms("EFI_INT_SPI1");
    case EFI_INT_SPI2:
        return translateeficomms("EFI_INT_SPI2");
    case EFI_INT_USART1:
        return translateeficomms("EFI_INT_USART1");
    case EFI_INT_USART2:
        return translateeficomms("EFI_INT_USART2");
    case EFI_INT_USART3:
        return translateeficomms("EFI_INT_USART3");
    case EFI_INT_EXTI15_10:
        return translateeficomms("EFI_INT_EXTI15_10");
    case EFI_INT_EXTI17_RTC_Alarm:
        return translateeficomms("EFI_INT_EXTI17_RTC_Alarm");
    case EFI_INT_EXTI18_OTG_FS_WKUP:
        return translateeficomms("EFI_INT_EXTI18_OTG_FS_WKUP");
    case EFI_INT_TIM8_BRK_TIM12:
        return translateeficomms("EFI_INT_TIM8_BRK_TIM12");
    case EFI_INT_TIM8_UP_TIM13:
        return translateeficomms("EFI_INT_TIM8_UP_TIM13");
    case EFI_INT_TIM8_TRG_COM_TIM14:
        return translateeficomms("EFI_INT_TIM8_TRG_COM_TIM14");
    case EFI_INT_TIM8_CC:
        return translateeficomms("EFI_INT_TIM8_CC");
    case EFI_INT_DMA1_Stream7:
        return translateeficomms("EFI_INT_DMA1_Stream7");
    case EFI_INT_FSMC:
        return translateeficomms("EFI_INT_FSMC");
    case EFI_INT_SDIO:
        return translateeficomms("EFI_INT_SDIO");
    case EFI_INT_TIM5:
        return translateeficomms("EFI_INT_TIM5");
    case EFI_INT_SPI3:
        return translateeficomms("EFI_INT_SPI3");
    case EFI_INT_TIM6:
        return translateeficomms("EFI_INT_TIM6");
    case EFI_INT_TIM7:
        return translateeficomms("EFI_INT_TIM7");
    case EFI_INT_DMA2_Stream0:
        return translateeficomms("EFI_INT_DMA2_Stream0");
    case EFI_INT_DMA2_Stream1:
        return translateeficomms("EFI_INT_DMA2_Stream1");
    case EFI_INT_DMA2_Stream2:
        return translateeficomms("EFI_INT_DMA2_Stream2");
    case EFI_INT_DMA2_Stream3:
        return translateeficomms("EFI_INT_DMA2_Stream3");
    case EFI_INT_DMA2_Stream4:
        return translateeficomms("EFI_INT_DMA2_Stream4");
    case EFI_INT_DFSDM1_FLT0:
        return translateeficomms("EFI_INT_DFSDM1_FLT0");
    case EFI_INT_DFSDM1_FLT1:
        return translateeficomms("EFI_INT_DFSDM1_FLT1");
    case EFI_INT_CAN2_TX:
        return translateeficomms("EFI_INT_CAN2_TX");
    case EFI_INT_CAN2_RX0:
        return translateeficomms("EFI_INT_CAN2_RX0");
    case EFI_INT_CAN2_RX1:
        return translateeficomms("EFI_INT_CAN2_RX1");
    case EFI_INT_CAN2_SCE:
        return translateeficomms("EFI_INT_CAN2_SCE");
    case EFI_INT_OTG_FS:
        return translateeficomms("EFI_INT_OTG_FS");
    case EFI_INT_DMA2_Stream5:
        return translateeficomms("EFI_INT_DMA2_Stream5");
    case EFI_INT_DMA2_Stream6:
        return translateeficomms("EFI_INT_DMA2_Stream6");
    case EFI_INT_DMA2_Stream7:
        return translateeficomms("EFI_INT_DMA2_Stream7");
    case EFI_INT_USART6:
        return translateeficomms("EFI_INT_USART6");
    case EFI_INT_I2C3_EV:
        return translateeficomms("EFI_INT_I2C3_EV");
    case EFI_INT_I2C3_ER:
        return translateeficomms("EFI_INT_I2C3_ER");
    case EFI_INT_RNG:
        return translateeficomms("EFI_INT_RNG");
    case EFI_INT_FPU:
        return translateeficomms("EFI_INT_FPU");
    case EFI_INT_SPI4:
        return translateeficomms("EFI_INT_SPI4");
    case EFI_INT_SPI5:
        return translateeficomms("EFI_INT_SPI5");
    case EFI_INT_Quad_SPI:
        return translateeficomms("EFI_INT_Quad_SPI");
    case EFI_INT_I2CFMP1_EV:
        return translateeficomms("EFI_INT_I2CFMP1_EV");
    case EFI_INT_I2CFMP1_ER:
        return translateeficomms("EFI_INT_I2CFMP1_ER");
    }
}

/*!
 * \brief Create the efiResetReport packet
 *
 * This packet reports the cause of a reset; it is spontaneously sent each time
 * the EFI resets, on the first connection from a user. In addition the reset
 * packet can be requested by sending this packet with zero length. The
 * firmware will handle any unexpected exception or interrupt by immediately
 * performing a software reset. In that case the `exceptionReset` bit will be
 * set, and the exception field will indicate which unhandled interrupt or
 * exception triggered the reset. The register values reported by this packet
 * are only valid for an exception reset. For other reset causes the register
 * values will be zero.
 * 
 * Resets which are not caused by power are counted in the `errorresetcnt`. If
 * the error counter reaches 20 the software will enter a safe mode in which it
 * does not load any settings from storage. 10 seconds after the system boots
 * up the `errorresetcnt` is zeroed. This makes it possible to recover the
 * system from a reset loop caused by bad settings data.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiResetReport_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Reset caused by the low power management
    _pg_data[_pg_byteindex] = (uint8_t)lowPowerReset << 7;

    // Reset caused by the window watchdog
    _pg_data[_pg_byteindex] |= (uint8_t)windowWatchdogReset << 6;

    // Reset caused by the independent watchdog
    _pg_data[_pg_byteindex] |= (uint8_t)watchdogReset << 5;

    // Reset caused by software
    _pg_data[_pg_byteindex] |= (uint8_t)softwareReset << 4;

    // Reset caused by power on
    _pg_data[_pg_byteindex] |= (uint8_t)powerReset << 3;

    // Reset caused by the reset pin
    _pg_data[_pg_byteindex] |= (uint8_t)pinReset << 2;

    // Brown out reset
    _pg_data[_pg_byteindex] |= (uint8_t)borReset << 1;

    // Reset caused by unhandled exception or interrupt
    _pg_data[_pg_byteindex] |= (uint8_t)exceptionReset;
    _pg_byteindex += 1; // close bit field


    // The number of the interrupt or exception which caused this reset, valid only if `exceptionReset` is set, otherwise zero.
    // Range of exception is 0 to 255.
    uint8ToBytes(exception, _pg_data, &_pg_byteindex);

    // If set, this is the first report generated since the system reset. Subsequent requests for the reset report will have this bit clear.
    _pg_data[_pg_byteindex] = (uint8_t)first << 7;

    // If set the system booted in safe mode because `errorresetcnt` was too large. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system.
    _pg_data[_pg_byteindex] |= (uint8_t)safeModeActive << 6;

    // If set the system booted in quick restart mode because the engine was running when the reset occurred.
    _pg_data[_pg_byteindex] |= (uint8_t)quickRestartActive << 5;

    // Reset caused by special watchdog handling. This is an exception that fires before the true watchdog in an attempt to learn the program counter of the stuck code.
    _pg_data[_pg_byteindex] |= (uint8_t)specialWatchdogReset << 4;

    _pg_byteindex += 1; // close bit field


    // Volatile reset count information. Each time the system boots up, it increments this counter. If the system resets by losing power long enough to clear the RAM then this counter will reset to zero. After the counter reaches 255 it will roll over to zero.
    // Range of count is 0 to 255.
    uint8ToBytes(count, _pg_data, &_pg_byteindex);

    // The program counter of the instruction that triggered the exception.
    // Range of programCounter is 0 to -2147483648.
    uint32ToBeBytes(programCounter, _pg_data, &_pg_byteindex);

    // The link register at the time of the exception.
    // Range of linkRegister is 0 to -2147483648.
    uint32ToBeBytes(linkRegister, _pg_data, &_pg_byteindex);

    // The program status register at the time of the exception.
    // Range of xpsr is 0 to -2147483648.
    uint32ToBeBytes(xpsr, _pg_data, &_pg_byteindex);

    // The floating point status and control register at the time of the exception.
    // Range of fpscr is 0 to -2147483648.
    uint32ToBeBytes(fpscr, _pg_data, &_pg_byteindex);

    // The configurable fault status register at the time of the exception.
    // Range of cfsr is 0 to -2147483648.
    uint32ToBeBytes(cfsr, _pg_data, &_pg_byteindex);

    // The memory management fault address register at the time of the exception.
    // Range of mmfar is 0 to -2147483648.
    uint32ToBeBytes(mmfar, _pg_data, &_pg_byteindex);

    // The bus fault address register at the time of the exception.
    // Range of bfar is 0 to -2147483648.
    uint32ToBeBytes(bfar, _pg_data, &_pg_byteindex);

    // The error reset count is incremented once for each time the system resets due to an error which is not power related. If the error counter reaches 20 the software will enter a safe mode in which it does not load any settings from storage. 10 seconds after the system boots up the `errorresetcnt` is zeroed.
    // Range of errorresetcnt is 0 to 255.
    uint8ToBytes(errorresetcnt, _pg_data, &_pg_byteindex);

    // Non-volatile reset count information. Each time the system boots up, it increments this counter.
    // Range of stickyresetcount is 0 to 65535.
    uint16ToBeBytes(stickyresetcount, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiResetReport_t::encode

/*!
 * \brief Decode the efiResetReport packet
 *
 * This packet reports the cause of a reset; it is spontaneously sent each time
 * the EFI resets, on the first connection from a user. In addition the reset
 * packet can be requested by sending this packet with zero length. The
 * firmware will handle any unexpected exception or interrupt by immediately
 * performing a software reset. In that case the `exceptionReset` bit will be
 * set, and the exception field will indicate which unhandled interrupt or
 * exception triggered the reset. The register values reported by this packet
 * are only valid for an exception reset. For other reset causes the register
 * values will be zero.
 * 
 * Resets which are not caused by power are counted in the `errorresetcnt`. If
 * the error counter reaches 20 the software will enter a safe mode in which it
 * does not load any settings from storage. 10 seconds after the system boots
 * up the `errorresetcnt` is zeroed. This makes it possible to recover the
 * system from a reset loop caused by bad settings data.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiResetReport_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    mmfar = 0;
    bfar = 0;
    errorresetcnt = 0;
    stickyresetcount = 0;

    // Reset caused by the low power management
    lowPowerReset = (_pg_data[_pg_byteindex] >> 7);

    // Reset caused by the window watchdog
    windowWatchdogReset = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Reset caused by the independent watchdog
    watchdogReset = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Reset caused by software
    softwareReset = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Reset caused by power on
    powerReset = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Reset caused by the reset pin
    pinReset = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Brown out reset
    borReset = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Reset caused by unhandled exception or interrupt
    exceptionReset = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    // The number of the interrupt or exception which caused this reset, valid only if `exceptionReset` is set, otherwise zero.
    // Range of exception is 0 to 255.
    exception = uint8FromBytes(_pg_data, &_pg_byteindex);

    // If set, this is the first report generated since the system reset. Subsequent requests for the reset report will have this bit clear.
    first = (_pg_data[_pg_byteindex] >> 7);

    // If set the system booted in safe mode because `errorresetcnt` was too large. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system.
    safeModeActive = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // If set the system booted in quick restart mode because the engine was running when the reset occurred.
    quickRestartActive = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Reset caused by special watchdog handling. This is an exception that fires before the true watchdog in an attempt to learn the program counter of the stuck code.
    specialWatchdogReset = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    _pg_byteindex += 1; // close bit field

    // Volatile reset count information. Each time the system boots up, it increments this counter. If the system resets by losing power long enough to clear the RAM then this counter will reset to zero. After the counter reaches 255 it will roll over to zero.
    // Range of count is 0 to 255.
    count = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The program counter of the instruction that triggered the exception.
    // Range of programCounter is 0 to -2147483648.
    programCounter = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // The link register at the time of the exception.
    // Range of linkRegister is 0 to -2147483648.
    linkRegister = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // The program status register at the time of the exception.
    // Range of xpsr is 0 to -2147483648.
    xpsr = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // The floating point status and control register at the time of the exception.
    // Range of fpscr is 0 to -2147483648.
    fpscr = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // The configurable fault status register at the time of the exception.
    // Range of cfsr is 0 to -2147483648.
    cfsr = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 4 > _pg_numbytes)
        return true;

    // The memory management fault address register at the time of the exception.
    // Range of mmfar is 0 to -2147483648.
    mmfar = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 4 > _pg_numbytes)
        return true;

    // The bus fault address register at the time of the exception.
    // Range of bfar is 0 to -2147483648.
    bfar = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return true;

    // The error reset count is incremented once for each time the system resets due to an error which is not power related. If the error counter reaches 20 the software will enter a safe mode in which it does not load any settings from storage. 10 seconds after the system boots up the `errorresetcnt` is zeroed.
    // Range of errorresetcnt is 0 to 255.
    errorresetcnt = uint8FromBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return true;

    // Non-volatile reset count information. Each time the system boots up, it increments this counter.
    // Range of stickyresetcount is 0 to 65535.
    stickyresetcount = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return true;

}// efiResetReport_t::decode

/*!
 * \brief Create the efiNack packet
 *
 * This packet is sent by the EFI to indicate a not-acknowledge response. The
 * nack always occurs in reponse to a packet from the user. There are six
 * different nack cases: 1) The input packet was not recognized. 2) The input
 * packet attempted to change locked configuration data, 3) The input packet
 * attempted to read hidden configuration data, 4) The input packet attempted a
 * command that cannot be performed while the engine is running, or 5) The
 * input packet was `EFI_PKT_REQUEST` but one of the request bits was reserved,
 * or 6) The input packet required the system be enabled when it was disabled,
 * or vice versa.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiNack_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // The type of the packet that triggered the NACK response.
    // Range of type is 0 to 255.
    uint8ToBytes(type, _pg_data, &_pg_byteindex);

    // The reason for the nack response.
    _pg_data[_pg_byteindex] = (uint8_t)cause << 5;

    // The index information from the first data byte of the packet that triggered the NACK response. This is only relevant for those packets that have indices.
    // Range of index is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(index, 31);
    _pg_byteindex += 1; // close bit field


    // If the cause of the nack was `nackReqBitNotRecognized` this field gives the bit number, from 95 (most significant) to 0 (least), of the request bit that was not understood.
    // Range of requestbit is 0 to 255.
    uint8ToBytes(requestbit, _pg_data, &_pg_byteindex);

    _pg_data[_pg_byteindex] = 0;

    // The index information from the first data byte of the packet that triggered the NACK response. This is only relevant for those packets that have indices.
    // Range of index is 0 to 63.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(index, 63);
    _pg_byteindex += 1; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiNack_t::encode

/*!
 * \brief Decode the efiNack packet
 *
 * This packet is sent by the EFI to indicate a not-acknowledge response. The
 * nack always occurs in reponse to a packet from the user. There are six
 * different nack cases: 1) The input packet was not recognized. 2) The input
 * packet attempted to change locked configuration data, 3) The input packet
 * attempted to read hidden configuration data, 4) The input packet attempted a
 * command that cannot be performed while the engine is running, or 5) The
 * input packet was `EFI_PKT_REQUEST` but one of the request bits was reserved,
 * or 6) The input packet required the system be enabled when it was disabled,
 * or vice versa.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiNack_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    requestbit = 0;
    index = 0;

    // The type of the packet that triggered the NACK response.
    // Range of type is 0 to 255.
    type = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The reason for the nack response.
    cause = (efiNackCause)(_pg_data[_pg_byteindex] >> 5);

    // The index information from the first data byte of the packet that triggered the NACK response. This is only relevant for those packets that have indices.
    // Range of index is 0 to 31.
    index = ((_pg_data[_pg_byteindex]) & 0x1F);
    _pg_byteindex += 1; // close bit field

    if(_pg_byteindex + 1 > _pg_numbytes)
        return true;

    // If the cause of the nack was `nackReqBitNotRecognized` this field gives the bit number, from 95 (most significant) to 0 (least), of the request bit that was not understood.
    // Range of requestbit is 0 to 255.
    requestbit = uint8FromBytes(_pg_data, &_pg_byteindex);

    // The index information from the first data byte of the packet that triggered the NACK response. This is only relevant for those packets that have indices.
    // Range of index is 0 to 63.
    index = ((_pg_data[_pg_byteindex]) & 0x3F);
    _pg_byteindex += 1; // close bit field

    return true;

}// efiNack_t::decode


/*!
 * \brief Lookup title for 'efiScopeEnum' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string title of the given entry (comment if no title given)
 */
const char* efiScopeEnum_EnumTitle(int value)
{
    switch (value)
    {
    default:
        return "";
    case EFI_SCOPE_VOLT:
        return translateeficomms("Input Voltage");
    case EFI_SCOPE_MAT:
        return translateeficomms("MAT");
    case EFI_SCOPE_CHT1:
        return translateeficomms("CHT1");
    case EFI_SCOPE_CHT2:
        return translateeficomms("CHT2");
    case EFI_SCOPE_MAP:
        return translateeficomms("MAP");
    case EFI_SCOPE_FUELP:
        return translateeficomms("Fuel pressure");
    case EFI_SCOPE_ANALOGTPS:
        return translateeficomms("Analog TPS");
    case EFI_SCOPE_CPUTEMP:
        return translateeficomms("CPU Temp");
    case EFI_SCOPE_SPARETEMP:
        return translateeficomms("Spare Temp");
    case EFI_SCOPE_RESERVED2:
        return translateeficomms("Reserved");
    case EFI_SCOPE_RESERVED3:
        return translateeficomms("Reserved");
    case EFI_SCOPE_CURRENT:
        return translateeficomms("Current");
    case EFI_SCOPE_12VOLT:
        return translateeficomms("12 Volts");
    case EFI_SCOPE_12CURRENT:
        return translateeficomms("12 Current");
    case EFI_SCOPE_ANALOGBARO:
        return translateeficomms("Barometer");
    case EFI_SCOPE_RESERVED4:
        return translateeficomms("Reserved");
    case EFI_SCOPE_IOENABLE:
        return translateeficomms("IO enable");
    case EFI_SCOPE_CRANKSENSE1:
        return translateeficomms("Crank sense 1");
    case EFI_SCOPE_CRANKSENSE2:
        return translateeficomms("Crank sense 2");
    case EFI_SCOPE_THROTTLEOUT:
        return translateeficomms("Throttle out");
    case EFI_SCOPE_THROTTLEIN:
        return translateeficomms("Throttle in");
    case EFI_SCOPE_COOLINGOUT:
        return translateeficomms("Cooling out");
    case EFI_SCOPE_EDGEERROR:
        return translateeficomms("Edge error");
    case EFI_SCOPE_SPARK1:
        return translateeficomms("Spark 1");
    case EFI_SCOPE_SPARK2:
        return translateeficomms("Spark 2");
    case EFI_SCOPE_SPARK3:
        return translateeficomms("Spark 3");
    case EFI_SCOPE_INJECTOR1:
        return translateeficomms("Injector 1");
    case EFI_SCOPE_INJECTOR2:
        return translateeficomms("Injector 2");
    case EFI_SCOPE_INJECTOR3:
        return translateeficomms("Injector 3");
    case EFI_SCOPE_CRANKERROR1:
        return translateeficomms("Crank 1 error");
    case EFI_SCOPE_CRANKERROR2:
        return translateeficomms("Crank 2 error");
    case EFI_SCOPE_ASYNCSAMPLE:
        return translateeficomms("Asynchronous");
    }
}

/*!
 * \brief Create the efiOscilloscopeSetup packet
 *
 * This packet is used to configure and enable the high speed oscilloscope.
 * Triggering scope mode when a previous scope capture is underway will cause
 * the previous capture to be discarded. If you ask for continuous scope
 * output, but lack the neccessary communications bandwidth, the scope output
 * will be intermittent. A single scope capture may take multiple packets to
 * completely report. Send this packet with zero length to request the current
 * oscilloscope setup.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiOscilloscopeSetup_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Set to enable the oscilloscope, for packets going to the EFI. For packets from the EFI this reports the running status of the scope.
    _pg_data[_pg_byteindex] = (uint8_t)enable << 7;

    // Set for a single oscilloscope reporting window. If this is set the oscilloscope will automatically disable after a single capture.
    _pg_data[_pg_byteindex] |= (uint8_t)single << 6;

    _pg_data[_pg_byteindex + 1] = 0;


    // Time window the scope will report in microseconds.
    // Range of timewindow is 0 to 4194303.
    _pg_tempbitfield = (unsigned int)timewindow;
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 4; // close bit field


    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // Set to enable triggering, if clear then the scope is always triggered (i.e. always generating data).
    _pg_data[_pg_byteindex] = (uint8_t)triggerenable << 7;

    // Set to trigger on the falling edge, else the trigger is on the rising edge.
    _pg_data[_pg_byteindex] |= (uint8_t)triggerfalling << 6;

    // Scope channel used to trigger oscilloscope output, if `triggerenable` is set.
    _pg_data[_pg_byteindex] |= (uint8_t)triggerchannel;
    _pg_byteindex += 1; // close bit field


    // Level of the trigger channel that causes an oscilloscope trigger. For analog sensor signals this in raw ADC units, with 0 the lowest value from the ADC and 65535 the largest value from the ADC. For digital signals this is either 0 or 1.
    // Range of triggerlevel is 0 to 65535.
    uint16ToBeBytes(triggerlevel, _pg_data, &_pg_byteindex);

    // A bitfield flag indicating which channels should be captured for the scope. The channel numbers follow `efiScopeEnum` enumeration, with channel zero being the least significant bit. Digital channels (`EFI_SCOPE_IOENABLE` and higher) are always reported in the data packet, but will not generate data packets unless they are set in this bitfield.
    // Range of channels is 0 to -2147483648.
    uint32ToBeBytes(channels, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiOscilloscopeSetup_t::encode

/*!
 * \brief Decode the efiOscilloscopeSetup packet
 *
 * This packet is used to configure and enable the high speed oscilloscope.
 * Triggering scope mode when a previous scope capture is underway will cause
 * the previous capture to be discarded. If you ask for continuous scope
 * output, but lack the neccessary communications bandwidth, the scope output
 * will be intermittent. A single scope capture may take multiple packets to
 * completely report. Send this packet with zero length to request the current
 * oscilloscope setup.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiOscilloscopeSetup_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Set to enable the oscilloscope, for packets going to the EFI. For packets from the EFI this reports the running status of the scope.
    enable = (_pg_data[_pg_byteindex] >> 7);

    // Set for a single oscilloscope reporting window. If this is set the oscilloscope will automatically disable after a single capture.
    single = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Time window the scope will report in microseconds.
    // Range of timewindow is 0 to 4194303.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0x3F);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    timewindow = _pg_tempbitfield;
    _pg_byteindex += 4; // close bit field

    // Skip over reserved space
    _pg_byteindex += 1;

    // Set to enable triggering, if clear then the scope is always triggered (i.e. always generating data).
    triggerenable = (_pg_data[_pg_byteindex] >> 7);

    // Set to trigger on the falling edge, else the trigger is on the rising edge.
    triggerfalling = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Scope channel used to trigger oscilloscope output, if `triggerenable` is set.
    triggerchannel = (efiScopeEnum)((_pg_data[_pg_byteindex]) & 0x3F);
    _pg_byteindex += 1; // close bit field

    // Level of the trigger channel that causes an oscilloscope trigger. For analog sensor signals this in raw ADC units, with 0 the lowest value from the ADC and 65535 the largest value from the ADC. For digital signals this is either 0 or 1.
    // Range of triggerlevel is 0 to 65535.
    triggerlevel = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // A bitfield flag indicating which channels should be captured for the scope. The channel numbers follow `efiScopeEnum` enumeration, with channel zero being the least significant bit. Digital channels (`EFI_SCOPE_IOENABLE` and higher) are always reported in the data packet, but will not generate data packets unless they are set in this bitfield.
    // Range of channels is 0 to -2147483648.
    channels = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return true;

}// efiOscilloscopeSetup_t::decode

/*!
 * \brief Create the efiOscilloscopeData packet
 *
 * This packet is used to report the oscilliscope data. If the scope is setup
 * for continuous output, but the communications hardware lacks the neccessary
 * bandwidth, the scope output will be intermittent. A single scope capture
 * will usually take multiple packets to completely report; however the exact
 * number of packets is not known until the scope capture is complete. The EFI
 * will begin sending scope data as soon as possible, and the transfer is
 * complete when the `lastPacket` flag is set.
 * 
 * The oscilloscope data packet can contain multiple samples of data. Since the
 * number of signals in each sample depends on the oscilloscope configuration
 * the data are encoded as a repeating array of 16-bit words. The first word is
 * always the time offset, which gives the time of the sample in microseconds,
 * relative to the `reftime` of the packet. The second word of the sample is
 * always the digital sample word, with the least significant bit corresponding
 * to the `EFI_SCOPE_IOENABLE` digital channel. The remaining words in the
 * sample provide the analog scope signals; the number of analog signals are
 * given by `numAnalogPerSample`, which will equal the number of analog
 * channels that were selected in the oscilloscope configuration packet. The
 * total number of words in the packet will always be a multiple of `2 +
 * numAnalogPerSample`. The analog signals are transmitted in their raw 16-bit
 * ADC form. You must use the sensor configurations to convert the sensors to
 * engineering units data.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiOscilloscopeData_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;
    unsigned _pg_i = 0;

    // If set this packet is the last packet in a series of scope packets that report a single scope window of data.
    _pg_data[_pg_byteindex] = (uint8_t)lastPacket << 7;

    // If set this packet contains the time reference of the triggering event.
    _pg_data[_pg_byteindex] |= (uint8_t)triggerTimeIncluded << 6;


    // The number of this packet in the series of scope packets that report a single scope window of data. This value will be zero on the first scope packet.
    // Range of packetCount is 0 to 4095.
    _pg_tempbitfield = (unsigned int)packetCount;
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;

    // The number of analog channels that are included per sample in this packet.
    // Range of numAnalogPerSample is 0 to 31.
    _pg_data[_pg_byteindex + 2] = (uint8_t)numAnalogPerSample << 3;


    // Number of words in this packet. The number of samples in the packet is equal to `numWords / (2 + numAnalogPerSample)`
    // Range of numWords is 0 to 511.
    _pg_tempbitfield = (unsigned int)numWords;
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 4; // close bit field


    // Time in microseconds since the system booted up. This is the reference time used for subsequent samples in the packet.
    // Range of refTime is 0 to -2147483648.
    uint48ToBeBytes((uint64_t)(refTime), _pg_data, &_pg_byteindex);

    // Time in microseconds since the system booted up when the trigger event occurred.
    // Range of triggerTime is 0 to -2147483648.
    if(triggerTimeIncluded)
    {
        uint48ToBeBytes((uint64_t)(triggerTime), _pg_data, &_pg_byteindex);
    }

    // The words of the samples. The interpretation of the sample words depends on the oscilloscope configuration.
    // Range of words is 0 to 65535.
    for(_pg_i = 0; _pg_i < (unsigned)numWords && _pg_i < EFI_SCOPE_MAX_WORDS; _pg_i++)
        uint16ToBeBytes(words[_pg_i], _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiOscilloscopeData_t::encode

/*!
 * \brief Decode the efiOscilloscopeData packet
 *
 * This packet is used to report the oscilliscope data. If the scope is setup
 * for continuous output, but the communications hardware lacks the neccessary
 * bandwidth, the scope output will be intermittent. A single scope capture
 * will usually take multiple packets to completely report; however the exact
 * number of packets is not known until the scope capture is complete. The EFI
 * will begin sending scope data as soon as possible, and the transfer is
 * complete when the `lastPacket` flag is set.
 * 
 * The oscilloscope data packet can contain multiple samples of data. Since the
 * number of signals in each sample depends on the oscilloscope configuration
 * the data are encoded as a repeating array of 16-bit words. The first word is
 * always the time offset, which gives the time of the sample in microseconds,
 * relative to the `reftime` of the packet. The second word of the sample is
 * always the digital sample word, with the least significant bit corresponding
 * to the `EFI_SCOPE_IOENABLE` digital channel. The remaining words in the
 * sample provide the analog scope signals; the number of analog signals are
 * given by `numAnalogPerSample`, which will equal the number of analog
 * channels that were selected in the oscilloscope configuration packet. The
 * total number of words in the packet will always be a multiple of `2 +
 * numAnalogPerSample`. The analog signals are transmitted in their raw 16-bit
 * ADC form. You must use the sensor configurations to convert the sensors to
 * engineering units data.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiOscilloscopeData_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // If set this packet is the last packet in a series of scope packets that report a single scope window of data.
    lastPacket = (_pg_data[_pg_byteindex] >> 7);

    // If set this packet contains the time reference of the triggering event.
    triggerTimeIncluded = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // The number of this packet in the series of scope packets that report a single scope window of data. This value will be zero on the first scope packet.
    // Range of packetCount is 0 to 4095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    packetCount = _pg_tempbitfield;

    // The number of analog channels that are included per sample in this packet.
    // Range of numAnalogPerSample is 0 to 31.
    numAnalogPerSample = (_pg_data[_pg_byteindex + 2] >> 3);

    // Number of words in this packet. The number of samples in the packet is equal to `numWords / (2 + numAnalogPerSample)`
    // Range of numWords is 0 to 511.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0x1);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 3];

    numWords = _pg_tempbitfield;
    _pg_byteindex += 4; // close bit field

    // Time in microseconds since the system booted up. This is the reference time used for subsequent samples in the packet.
    // Range of refTime is 0 to -2147483648.
    refTime = (uint64_t)uint48FromBeBytes(_pg_data, &_pg_byteindex);

    if(triggerTimeIncluded)
    {
        // Time in microseconds since the system booted up when the trigger event occurred.
        // Range of triggerTime is 0 to -2147483648.
        triggerTime = (uint64_t)uint48FromBeBytes(_pg_data, &_pg_byteindex);
    }

    // The words of the samples. The interpretation of the sample words depends on the oscilloscope configuration.
    // Range of words is 0 to 65535.
    for(_pg_i = 0; _pg_i < (unsigned)numWords && _pg_i < EFI_SCOPE_MAX_WORDS; _pg_i++)
        words[_pg_i] = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    return true;

}// efiOscilloscopeData_t::decode

/*!
 * \brief Create the efiDebug packet
 *
 * This packet gives data used for debugging. The interpretation of this packet
 * is variable.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param time is Time in microseconds of the debug output
 * \param details is 12 bytes of data to use as the debugger sees fit
 * \param comment is Human readable debug string
 */
void efiDebug_t::encode(efiPacket_t* _pg_pkt, uint32_t time, const uint8_t details[12], const char comment[512])
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // Time in microseconds of the debug output
    // Range of time is 0 to -2147483648.
    uint32ToBeBytes(time, _pg_data, &_pg_byteindex);

    // 12 bytes of data to use as the debugger sees fit
    // Range of details is 0 to 255.
    for(_pg_i = 0; _pg_i < 12; _pg_i++)
        uint8ToBytes(details[_pg_i], _pg_data, &_pg_byteindex);

    // Human readable debug string
    stringToBytes(comment, _pg_data, &_pg_byteindex, 512, 0);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiDebug_t::encode

/*!
 * \brief Decode the efiDebug packet
 *
 * This packet gives data used for debugging. The interpretation of this packet
 * is variable.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param time receives Time in microseconds of the debug output
 * \param details receives 12 bytes of data to use as the debugger sees fit
 * \param comment receives Human readable debug string
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiDebug_t::decode(const efiPacket_t* _pg_pkt, uint32_t* time, uint8_t details[12], char comment[512])
{
    unsigned _pg_i = 0;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Time in microseconds of the debug output
    // Range of time is 0 to -2147483648.
    (*time) = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // 12 bytes of data to use as the debugger sees fit
    // Range of details is 0 to 255.
    for(_pg_i = 0; _pg_i < 12; _pg_i++)
        details[_pg_i] = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Human readable debug string
    stringFromBytes(comment, _pg_data, &_pg_byteindex, 512, 0);

    return 1;

}// efiDebug_t::decode

/*!
 * \brief Create the efiTestMode packet
 *
 * The test mode packet is used to engage special features for testing software
 * and hardware. In order to engage test mode the EFI must be unlocked, and the
 * engine must not be running. If the engine starts running while test mode is
 * active (as indicated by crank sense detection) the test mode will be
 * automatically canceled. Test mode can also be canceled by this packet, by
 * locking the EFI configuration, or by timeout. When test mode is active this
 * packet will be reported at the slow telemetry rate to indicate the test mode
 * status. The test mode status is always visible in the telemetry errors
 * packet. In addition you can send this packet with zero length to request the
 * current test mode status.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiTestMode_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Set to enable test mode. For report packets this is the test mode status.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(enabled, 1) << 7;

    // Set to enable automatic calibration of the throttle `closedPWMout` value.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enableThrottleClosedCalibration, 1) << 6;

    // Set to enable automatic calibration of the throttle `openPWMout` value.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(enableThrottleOpenCalibration, 1) << 5;

    // Set to skip the processing of one event cycle for crank sense 1.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(skipCrankSense1, 1) << 4;

    // Set to skip the processing of one event cycle for crank sense 2.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(skipCrankSense2, 1) << 3;

    // Set to add an extraneous sensed tooth for crank sense 1.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(addToothCrankSense1, 1) << 2;

    // Set to add an extraneous sensed tooth for crank sense 1.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(addToothCrankSense2, 1) << 1;

    // Test mode timeout in seconds. For report packets this is the amount of time remaining in the test. If the test is user storage this is percent remaining.
    // Range of timeout is 0 to 511.
    _pg_tempbitfield = (unsigned int)limitMax(timeout, 511);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;

    // Set to simulate crank sense events in the normal direction.
    _pg_data[_pg_byteindex + 2] = (uint8_t)limitMax(testCrankSenseNormal, 1) << 7;

    // Set for injector1 test
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(testInjector1, 1) << 6;

    // Set for injector2 test
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(testInjector2, 1) << 5;

    // Set for spark1 test
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(testSpark1, 1) << 4;

    // Set for spark2 test
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(testSpark2, 1) << 3;

    // Set to drive the fuel pump at a specific duty cycle
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(testFuelpump, 1) << 2;

    // Set to control the injector duty cycle to achieve a fuel pressure. This should be combined with testInjector1 or testInjector2 to specify which injector is used to regulate the fuel pressure.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(testFuelflow, 1) << 1;

    // Set to simulate crank sense events in the reverse direction.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(testCrankSenseReverse, 1);

    // Number of skipped outputs for spark1; 0 - 3.
    // Range of missFire1 is 0 to 3.
    _pg_data[_pg_byteindex + 3] = (uint8_t)limitMax(missFire1, 3) << 6;

    // Number of skipped outputs for spark2; 0 - 3.
    // Range of missFire2 is 0 to 3.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)limitMax(missFire2, 3) << 4;

    // Set to enable automatic calibration of the cowl flap 2 `closedPWM` value.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)limitMax(enableCowlFlap2ClosedCalibration, 1) << 3;

    // Set to enable automatic calibration of the cowl flap 2 `openPWM` value.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)limitMax(enableCowlFlap2OpenCalibration, 1) << 2;

    // Set to enable automatic calibration of the cowl flap 1 `closedPWM` value.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)limitMax(enableCowlFlap1ClosedCalibration, 1) << 1;

    // Set to enable automatic calibration of the cowl flap 1 `openPWM` value.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)limitMax(enableCowlFlap1OpenCalibration, 1);
    _pg_byteindex += 4; // close bit field


    // For injector, spark, and fuel pump tests this is duty cycle in percentage to apply to the injector output, spark output, or fuel pump output
    // Range of dutycycle is 0.0 to 100.0.
    float32ScaledTo2UnsignedBeBytes(dutycycle, _pg_data, &_pg_byteindex, 0.0f, 655.35f);

    // The frequency, in events per minute, at which the test should be performed. This does not apply to the fuel pump test.
    // Range of speed is 0.0 to 16383.75.
    float32ScaledTo2UnsignedBeBytes(speed, _pg_data, &_pg_byteindex, 0.0f, 4.0f);

    // Proportional feedback gain for fuel flow test from kPa of fuel pressure error to percentage of injector duty cycle
    // Range of fuelflowProGain is -4.2907729920000000e+09 to 4.2907729920000000e+09.
    float16ToBeBytes((float)fuelflowProGain, _pg_data, &_pg_byteindex, 9);

    // Integral feedback gain for fuel flow test from integral of kPa of fuel pressure error to percentage of injector duty cycle
    // Range of fuelflowIntGain is -4.2907729920000000e+09 to 4.2907729920000000e+09.
    float16ToBeBytes((float)fuelflowIntGain, _pg_data, &_pg_byteindex, 9);

    // The current rise used to indicate that a hard stop was discovered, used with `enableThrottleClosedCalibration`, `enableThrottleOpenCalibration`, `enableCowlFlapClosedCalibration`, and `enableCowlFlapOpenCalibration`.
    // Range of currentThreshold is 0.0 to 1.275.
    float32ScaledTo1UnsignedBytes(currentThreshold, _pg_data, &_pg_byteindex, 0.0f, 200.0f);

    // The actual position, in percent, of the closed hard stop used with `enableThrottleClosedCalibration` or `enableCowlFlapClosedCalibration`.
    // Range of actualClosedStop is -30.0 to 33.75.
    float32ScaledTo1UnsignedBytes(actualClosedStop, _pg_data, &_pg_byteindex, -30.0f, 4.0f);

    // The actual position, in percent, of the open hard stop used with `enableThrottleOpenCalibration` or `enableCowlFlapOpenCalibration`.
    // Range of actualOpenStop is 70.0 to 133.75.
    float32ScaledTo1UnsignedBytes(actualOpenStop, _pg_data, &_pg_byteindex, 70.0f, 4.0f);

    // Set for injector3 test
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(testInjector3, 1) << 7;

    // Set for spark3 test
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(testSpark3, 1) << 6;

    // Number of skipped outputs for spark3; 0 - 3.
    // Range of missFire3 is 0 to 3.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(missFire3, 3) << 4;

    // Set to enable test of user storage space. This will exercise the entire EEPROM. Do not disonnect from power until the test is complete, otherwise some data in user stroage may be lost. This test cannot be done simultaneously with other tests.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(testUserStorage, 1) << 3;

    _pg_byteindex += 1; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiTestMode_t::encode

/*!
 * \brief Decode the efiTestMode packet
 *
 * The test mode packet is used to engage special features for testing software
 * and hardware. In order to engage test mode the EFI must be unlocked, and the
 * engine must not be running. If the engine starts running while test mode is
 * active (as indicated by crank sense detection) the test mode will be
 * automatically canceled. Test mode can also be canceled by this packet, by
 * locking the EFI configuration, or by timeout. When test mode is active this
 * packet will be reported at the slow telemetry rate to indicate the test mode
 * status. The test mode status is always visible in the telemetry errors
 * packet. In addition you can send this packet with zero length to request the
 * current test mode status.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiTestMode_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    currentThreshold = (float)0.1;
    actualClosedStop = 0;
    actualOpenStop = 100;
    testInjector3 = 0;
    testSpark3 = 0;
    missFire3 = 0;
    testUserStorage = 0;

    // Set to enable test mode. For report packets this is the test mode status.
    enabled = (_pg_data[_pg_byteindex] >> 7);

    // Set to enable automatic calibration of the throttle `closedPWMout` value.
    enableThrottleClosedCalibration = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set to enable automatic calibration of the throttle `openPWMout` value.
    enableThrottleOpenCalibration = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set to skip the processing of one event cycle for crank sense 1.
    skipCrankSense1 = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set to skip the processing of one event cycle for crank sense 2.
    skipCrankSense2 = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set to add an extraneous sensed tooth for crank sense 1.
    addToothCrankSense1 = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set to add an extraneous sensed tooth for crank sense 1.
    addToothCrankSense2 = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Test mode timeout in seconds. For report packets this is the amount of time remaining in the test. If the test is user storage this is percent remaining.
    // Range of timeout is 0 to 511.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x1);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    timeout = _pg_tempbitfield;

    // Set to simulate crank sense events in the normal direction.
    testCrankSenseNormal = (_pg_data[_pg_byteindex + 2] >> 7);

    // Set for injector1 test
    testInjector1 = ((_pg_data[_pg_byteindex + 2] >> 6) & 0x1);

    // Set for injector2 test
    testInjector2 = ((_pg_data[_pg_byteindex + 2] >> 5) & 0x1);

    // Set for spark1 test
    testSpark1 = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x1);

    // Set for spark2 test
    testSpark2 = ((_pg_data[_pg_byteindex + 2] >> 3) & 0x1);

    // Set to drive the fuel pump at a specific duty cycle
    testFuelpump = ((_pg_data[_pg_byteindex + 2] >> 2) & 0x1);

    // Set to control the injector duty cycle to achieve a fuel pressure. This should be combined with testInjector1 or testInjector2 to specify which injector is used to regulate the fuel pressure.
    testFuelflow = ((_pg_data[_pg_byteindex + 2] >> 1) & 0x1);

    // Set to simulate crank sense events in the reverse direction.
    testCrankSenseReverse = ((_pg_data[_pg_byteindex + 2]) & 0x1);

    // Number of skipped outputs for spark1; 0 - 3.
    // Range of missFire1 is 0 to 3.
    missFire1 = (_pg_data[_pg_byteindex + 3] >> 6);

    // Number of skipped outputs for spark2; 0 - 3.
    // Range of missFire2 is 0 to 3.
    missFire2 = ((_pg_data[_pg_byteindex + 3] >> 4) & 0x3);

    // Set to enable automatic calibration of the cowl flap 2 `closedPWM` value.
    enableCowlFlap2ClosedCalibration = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // Set to enable automatic calibration of the cowl flap 2 `openPWM` value.
    enableCowlFlap2OpenCalibration = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);

    // Set to enable automatic calibration of the cowl flap 1 `closedPWM` value.
    enableCowlFlap1ClosedCalibration = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // Set to enable automatic calibration of the cowl flap 1 `openPWM` value.
    enableCowlFlap1OpenCalibration = ((_pg_data[_pg_byteindex + 3]) & 0x1);
    _pg_byteindex += 4; // close bit field

    // For injector, spark, and fuel pump tests this is duty cycle in percentage to apply to the injector output, spark output, or fuel pump output
    // Range of dutycycle is 0.0 to 100.0.
    dutycycle = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/655.35f);

    // The frequency, in events per minute, at which the test should be performed. This does not apply to the fuel pump test.
    // Range of speed is 0.0 to 16383.75.
    speed = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/4.0f);

    // Proportional feedback gain for fuel flow test from kPa of fuel pressure error to percentage of injector duty cycle
    // Range of fuelflowProGain is -4.2907729920000000e+09 to 4.2907729920000000e+09.
    fuelflowProGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 9);

    // Integral feedback gain for fuel flow test from integral of kPa of fuel pressure error to percentage of injector duty cycle
    // Range of fuelflowIntGain is -4.2907729920000000e+09 to 4.2907729920000000e+09.
    fuelflowIntGain = float16FromBeBytes(_pg_data, &_pg_byteindex, 9);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return true;

    // The current rise used to indicate that a hard stop was discovered, used with `enableThrottleClosedCalibration`, `enableThrottleOpenCalibration`, `enableCowlFlapClosedCalibration`, and `enableCowlFlapOpenCalibration`.
    // Range of currentThreshold is 0.0 to 1.275.
    currentThreshold = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/200.0f);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return true;

    // The actual position, in percent, of the closed hard stop used with `enableThrottleClosedCalibration` or `enableCowlFlapClosedCalibration`.
    // Range of actualClosedStop is -30.0 to 33.75.
    actualClosedStop = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -30.0f, 1.0f/4.0f);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return true;

    // The actual position, in percent, of the open hard stop used with `enableThrottleOpenCalibration` or `enableCowlFlapOpenCalibration`.
    // Range of actualOpenStop is 70.0 to 133.75.
    actualOpenStop = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 70.0f, 1.0f/4.0f);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return 1;

    // Set for injector3 test
    testInjector3 = (_pg_data[_pg_byteindex] >> 7);

    // Set for spark3 test
    testSpark3 = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Number of skipped outputs for spark3; 0 - 3.
    // Range of missFire3 is 0 to 3.
    missFire3 = ((_pg_data[_pg_byteindex] >> 4) & 0x3);

    // Set to enable test of user storage space. This will exercise the entire EEPROM. Do not disonnect from power until the test is complete, otherwise some data in user stroage may be lost. This test cannot be done simultaneously with other tests.
    testUserStorage = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    _pg_byteindex += 1; // close bit field

    return true;

}// efiTestMode_t::decode

/*!
 * \brief Create the efiRequestCrankSenseTiming packet
 *
 * Request crank sense timing packets. To request the crank sense timing set
 * either `onesample` or `continuous`. To stop the crank sense timing packets
 * clear `continuous`
 * \param _pg_pkt points to the packet which will be created by this function
 * \param onesample is Set this bit to request one capture of data.
 * \param continuous is Set this bit to request crank sense timing packets be sent continuously.
 * \param onsynclost is Set this bit to downlink the timing when synchronization is lost.
 * \param sense2 is Set this bit to request crank sense timing for sense 2, otherwise the data are requested for sense 1.
 * \param numIntervals is The requested number of sense intervals. For crank wheels IntelliJect will adjust this to be an even multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500.
 */
void efiRequestCrankSenseTiming_t::encode(efiPacket_t* _pg_pkt, unsigned onesample, unsigned continuous, unsigned onsynclost, unsigned sense2, uint16_t numIntervals)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Set this bit to request one capture of data.
    _pg_data[_pg_byteindex] = (uint8_t)onesample << 7;

    // Set this bit to request crank sense timing packets be sent continuously.
    _pg_data[_pg_byteindex] |= (uint8_t)continuous << 6;

    // Set this bit to downlink the timing when synchronization is lost.
    _pg_data[_pg_byteindex] |= (uint8_t)onsynclost << 5;

    // Set this bit to request crank sense timing for sense 2, otherwise the data are requested for sense 1.
    _pg_data[_pg_byteindex] |= (uint8_t)sense2 << 4;

    // Reserved bits for future expansion.

    // The requested number of sense intervals. For crank wheels IntelliJect will adjust this to be an even multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500.
    // Range of numIntervals is 0 to 511.
    _pg_tempbitfield = (unsigned int)limitMax(numIntervals, 511);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiRequestCrankSenseTiming_t::encode

/*!
 * \brief Decode the efiRequestCrankSenseTiming packet
 *
 * Request crank sense timing packets. To request the crank sense timing set
 * either `onesample` or `continuous`. To stop the crank sense timing packets
 * clear `continuous`
 * \param _pg_pkt points to the packet being decoded by this function
 * \param onesample receives Set this bit to request one capture of data.
 * \param continuous receives Set this bit to request crank sense timing packets be sent continuously.
 * \param onsynclost receives Set this bit to downlink the timing when synchronization is lost.
 * \param sense2 receives Set this bit to request crank sense timing for sense 2, otherwise the data are requested for sense 1.
 * \param numIntervals receives The requested number of sense intervals. For crank wheels IntelliJect will adjust this to be an even multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500.
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiRequestCrankSenseTiming_t::decode(const efiPacket_t* _pg_pkt, unsigned* onesample, unsigned* continuous, unsigned* onsynclost, unsigned* sense2, uint16_t* numIntervals)
{
    unsigned int _pg_tempbitfield = 0;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Set this bit to request one capture of data.
    (*onesample) = (_pg_data[_pg_byteindex] >> 7);

    // Set this bit to request crank sense timing packets be sent continuously.
    (*continuous) = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set this bit to downlink the timing when synchronization is lost.
    (*onsynclost) = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set this bit to request crank sense timing for sense 2, otherwise the data are requested for sense 1.
    (*sense2) = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Reserved bits for future expansion.

    // The requested number of sense intervals. For crank wheels IntelliJect will adjust this to be an even multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500.
    // Range of numIntervals is 0 to 511.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x1);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    (*numIntervals) = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    return 1;

}// efiRequestCrankSenseTiming_t::decode

/*!
 * \brief Create the efiCrankSenseTiming packet
 *
 * Details of the crank sense timing. To receive this packet you must first
 * send the `RequestCrankSenseTiming` packet. The crank sense timing details
 * simply give the time intervals of crank sense events (active edges). This is
 * most useful for crank wheels, but can be used for once-per-rev sensors.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiCrankSenseTiming_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;
    unsigned _pg_i = 0;

    // If set a single crank sense timing packet was sent.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(onesample, 1) << 7;

    // If set crank sense timing packets will be sent continuously.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(continuous, 1) << 6;

    // Set this bit to downlink the timing when synchronization is lost.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(onsynclost, 1) << 5;

    // If set this timing data comes from crank sense 2, otherwise it is from crank sense 1.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(sense2, 1) << 4;

    // Reserved bits for future expansion.

    // Set if this timing data are for a crank wheel, else it is for a once per rev sensor.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(wheelenabled, 1) << 1;

    // The number of sense intervals in this packet. For crank wheels this will be a multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500.
    // Range of numIntervals is 0 to 511.
    _pg_tempbitfield = (unsigned int)limitMax(numIntervals, 511);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field


    // Angle of the crank sense in degrees of crank rotation after TDC, in the current crank rotation direction. For crank wheels this is the angle of the first tooth after the big gap.
    // Range of crankOffset is 0.0 to 360.0.
    float32ScaledTo2UnsignedBeBytes(crankOffset, _pg_data, &_pg_byteindex, 0.0f, 182.041667f);

    // The number of teeth on the crank wheel plus the missing teeth. This is the full count, as though no synchronization teeth were removed.
    // Range of totalCount is 0 to 255.
    if(wheelenabled)
    {
        uint8ToBytes(totalCount, _pg_data, &_pg_byteindex);
    }

    // The number of teeth missing in the big gap of the crank wheel. The end of the big gap is the crank angle synchronization point. There must always be a non-zero big gap count.
    // Range of bigGapCount is 0 to 255.
    if(wheelenabled)
    {
        uint8ToBytes(bigGapCount, _pg_data, &_pg_byteindex);
    }

    // The number of teeth missing in the small gap of the crank wheel. The small gap count can be zero, in which case there is no small gap, and no intra-gap.
    // Range of smallGapCount is 0 to 255.
    if(wheelenabled)
    {
        uint8ToBytes(smallGapCount, _pg_data, &_pg_byteindex);
    }

    // The number of teeth between the big gap and the small gap for the current direction of rotation. Zero if there is no small gap.
    // Range of intraGapCount is 0 to 255.
    if(wheelenabled)
    {
        uint8ToBytes(intraGapCount, _pg_data, &_pg_byteindex);
    }

    // Time in milliseconds since the system booted up. This is the reference time for subsequent intervals.
    // Range of time is 0 to -2147483648.
    uint32ToBeBytes(time, _pg_data, &_pg_byteindex);

    // The time difference of each sense event from the previous event in microseconds.
    // Range of intervals is 0 to 65535.
    for(_pg_i = 0; _pg_i < (unsigned)numIntervals && _pg_i < maxCrankSenseIntervals; _pg_i++)
        uint16ToBeBytes(intervals[_pg_i], _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiCrankSenseTiming_t::encode

/*!
 * \brief Decode the efiCrankSenseTiming packet
 *
 * Details of the crank sense timing. To receive this packet you must first
 * send the `RequestCrankSenseTiming` packet. The crank sense timing details
 * simply give the time intervals of crank sense events (active edges). This is
 * most useful for crank wheels, but can be used for once-per-rev sensors.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiCrankSenseTiming_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // If set a single crank sense timing packet was sent.
    onesample = (_pg_data[_pg_byteindex] >> 7);

    // If set crank sense timing packets will be sent continuously.
    continuous = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set this bit to downlink the timing when synchronization is lost.
    onsynclost = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // If set this timing data comes from crank sense 2, otherwise it is from crank sense 1.
    sense2 = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Reserved bits for future expansion.

    // Set if this timing data are for a crank wheel, else it is for a once per rev sensor.
    wheelenabled = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // The number of sense intervals in this packet. For crank wheels this will be a multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500.
    // Range of numIntervals is 0 to 511.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x1);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    numIntervals = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // Angle of the crank sense in degrees of crank rotation after TDC, in the current crank rotation direction. For crank wheels this is the angle of the first tooth after the big gap.
    // Range of crankOffset is 0.0 to 360.0.
    crankOffset = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/182.041667f);

    if(wheelenabled)
    {
        // The number of teeth on the crank wheel plus the missing teeth. This is the full count, as though no synchronization teeth were removed.
        // Range of totalCount is 0 to 255.
        totalCount = uint8FromBytes(_pg_data, &_pg_byteindex);
    }

    if(wheelenabled)
    {
        // The number of teeth missing in the big gap of the crank wheel. The end of the big gap is the crank angle synchronization point. There must always be a non-zero big gap count.
        // Range of bigGapCount is 0 to 255.
        bigGapCount = uint8FromBytes(_pg_data, &_pg_byteindex);
    }

    if(wheelenabled)
    {
        // The number of teeth missing in the small gap of the crank wheel. The small gap count can be zero, in which case there is no small gap, and no intra-gap.
        // Range of smallGapCount is 0 to 255.
        smallGapCount = uint8FromBytes(_pg_data, &_pg_byteindex);
    }

    if(wheelenabled)
    {
        // The number of teeth between the big gap and the small gap for the current direction of rotation. Zero if there is no small gap.
        // Range of intraGapCount is 0 to 255.
        intraGapCount = uint8FromBytes(_pg_data, &_pg_byteindex);
    }

    // Time in milliseconds since the system booted up. This is the reference time for subsequent intervals.
    // Range of time is 0 to -2147483648.
    time = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // The time difference of each sense event from the previous event in microseconds.
    // Range of intervals is 0 to 65535.
    for(_pg_i = 0; _pg_i < (unsigned)numIntervals && _pg_i < maxCrankSenseIntervals; _pg_i++)
        intervals[_pg_i] = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    return true;

}// efiCrankSenseTiming_t::decode


/*!
 * \brief Lookup title for 'interruptIndices' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string title of the given entry (comment if no title given)
 */
const char* interruptIndices_EnumTitle(int value)
{
    switch (value)
    {
    default:
        return "";
    case systickInt:
        return translateeficomms("Systick");
    case timer4Int:
        return translateeficomms("Timer 4");
    case timer1Int:
        return translateeficomms("Timer 1");
    case timer2Int:
        return translateeficomms("Timer 2");
    case timer3Int:
        return translateeficomms("Timer 3");
    case timer5Int:
        return translateeficomms("Timer 5");
    case ext01Int:
        return translateeficomms("Ext0 and Ext1");
    case timer9Int:
        return translateeficomms("Timer 9");
    case uartInt:
        return translateeficomms("UART");
    case i2ceventInt:
        return translateeficomms("I2C event");
    case i2cerrorInt:
        return translateeficomms("I2C error");
    case canrx0Int:
        return translateeficomms("CAN rx0");
    case canrx1Int:
        return translateeficomms("CAN rx1");
    case cantxInt:
        return translateeficomms("CAN tx");
    case sdioInt:
        return translateeficomms("SDIO");
    case fpuInt:
        return translateeficomms("FPU");
    case numInterrupts:
        return translateeficomms("numInterrupts");
    }
}

/*!
 * \brief Create the efiInterruptDetails packet
 *
 * This packet gives data used for interrupt debugging. This packet is sent at
 * the slow telemetry rate, but only if enabled. To enable sending of this
 * packet send this packet with one non-zero byte to the EFI. To stop sending
 * of this packet send this packet with one zero byte.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param intdetails is Interrupt details for all the interrupt sources
 */
void efiInterruptDetails_t::encode(efiPacket_t* _pg_pkt, const efiInterruptDetail_t intdetails[numInterrupts])
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // Interrupt details for all the interrupt sources
    for(_pg_i = 0; _pg_i < numInterrupts; _pg_i++)
        intdetails[_pg_i].encode(_pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiInterruptDetails_t::encode

/*!
 * \brief Decode the efiInterruptDetails packet
 *
 * This packet gives data used for interrupt debugging. This packet is sent at
 * the slow telemetry rate, but only if enabled. To enable sending of this
 * packet send this packet with one non-zero byte to the EFI. To stop sending
 * of this packet send this packet with one zero byte.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param intdetails receives Interrupt details for all the interrupt sources
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiInterruptDetails_t::decode(const efiPacket_t* _pg_pkt, efiInterruptDetail_t intdetails[numInterrupts])
{
    unsigned _pg_i = 0;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Interrupt details for all the interrupt sources
    for(_pg_i = 0; _pg_i < numInterrupts; _pg_i++)
        if(intdetails[_pg_i].decode(_pg_data, &_pg_byteindex) == false)
            return false;

    return 1;

}// efiInterruptDetails_t::decode

/*!
 * \brief Create the efiBootloader packet
 *
 * Packet for bootloader interactions. The bootloader is a separate application
 * within the EFI firmware load; and only the bootloader will send, or respond
 * to, this packet. The bootloader uses fixed communications configurations. On
 * serial the bit rate is always 57600 bits per second. On CAN the bit rate is
 * always 1Mbit, the identifier is always 11-bits, the input ID is always
 * 0x400, and the output ID is always 0x401. Only one device on the CAN bus can
 * be in bootloader mode at a time.
 * 
 * When the bootloader is running it will output this packet on a regular basis
 * as a heartbeat. In order to program the firmware you must watch for the
 * bootloader packet and use the serial number that it contains in any packet
 * sent back to the bootloader. In order to start the bootloader you use the
 * [reset command](#EFI_PKT_RESET) packet.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiBootloader_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // 32-bit serial number of the EFI. When the bootloader packet comes from the EFI this contains the serial number of the EFI. When the bootloader packet goes to the EFI this must have the correct EFI serial number in order for this packet to be obeyed.
    // Range of serialnumber is 0 to -2147483648.
    uint32ToBeBytes(serialnumber, _pg_data, &_pg_byteindex);

    // Starting address for this packet. This is used for erase as well as program. For the heartbeat packet this will be address `0x0801001C`, and the datsize will be at least 16 bytes.
    // Range of startaddress is 0 to -2147483648.
    uint32ToBeBytes(startaddress, _pg_data, &_pg_byteindex);

    // Data size for this packet. This is used for erase as well as program. For the program packet this datasize cannot be more than 256. For the program nack packet this indicates the first byte which failed to program.
    // Range of datasize is 0 to -2147483648.
    uint32ToBeBytes(datasize, _pg_data, &_pg_byteindex);

    // Version of the bootloader from 0 to 255
    // Range of version is 0 to 255.
    uint8ToBytes(version, _pg_data, &_pg_byteindex);

    // Set if this packet includes program data
    _pg_data[_pg_byteindex] = (uint8_t)hasprogramdata << 7;

    // Reserved bits for future expansion

    // The purpose of this bootloader packet
    _pg_data[_pg_byteindex] |= (uint8_t)command;
    _pg_byteindex += 1; // close bit field


    // Program data, starting at startaddress
    // Range of programdata is 0 to 255.
    if(hasprogramdata)
    {
        for(_pg_i = 0; _pg_i < (unsigned)datasize && _pg_i < 256; _pg_i++)
            uint8ToBytes(programdata[_pg_i], _pg_data, &_pg_byteindex);
    }

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiBootloader_t::encode

/*!
 * \brief Decode the efiBootloader packet
 *
 * Packet for bootloader interactions. The bootloader is a separate application
 * within the EFI firmware load; and only the bootloader will send, or respond
 * to, this packet. The bootloader uses fixed communications configurations. On
 * serial the bit rate is always 57600 bits per second. On CAN the bit rate is
 * always 1Mbit, the identifier is always 11-bits, the input ID is always
 * 0x400, and the output ID is always 0x401. Only one device on the CAN bus can
 * be in bootloader mode at a time.
 * 
 * When the bootloader is running it will output this packet on a regular basis
 * as a heartbeat. In order to program the firmware you must watch for the
 * bootloader packet and use the serial number that it contains in any packet
 * sent back to the bootloader. In order to start the bootloader you use the
 * [reset command](#EFI_PKT_RESET) packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiBootloader_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // 32-bit serial number of the EFI. When the bootloader packet comes from the EFI this contains the serial number of the EFI. When the bootloader packet goes to the EFI this must have the correct EFI serial number in order for this packet to be obeyed.
    // Range of serialnumber is 0 to -2147483648.
    serialnumber = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Starting address for this packet. This is used for erase as well as program. For the heartbeat packet this will be address `0x0801001C`, and the datsize will be at least 16 bytes.
    // Range of startaddress is 0 to -2147483648.
    startaddress = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Data size for this packet. This is used for erase as well as program. For the program packet this datasize cannot be more than 256. For the program nack packet this indicates the first byte which failed to program.
    // Range of datasize is 0 to -2147483648.
    datasize = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Version of the bootloader from 0 to 255
    // Range of version is 0 to 255.
    version = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Set if this packet includes program data
    hasprogramdata = (_pg_data[_pg_byteindex] >> 7);

    // Reserved bits for future expansion

    // The purpose of this bootloader packet
    command = (bootloadercmds)((_pg_data[_pg_byteindex]) & 0xF);
    _pg_byteindex += 1; // close bit field

    if(hasprogramdata)
    {
        // Program data, starting at startaddress
        // Range of programdata is 0 to 255.
        for(_pg_i = 0; _pg_i < (unsigned)datasize && _pg_i < 256; _pg_i++)
            programdata[_pg_i] = uint8FromBytes(_pg_data, &_pg_byteindex);
    }

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return false;

    return true;

}// efiBootloader_t::decode

/*!
 * \brief Create the efiSDCardBlockData packet
 *
 * This packet is at the beginning of every valid block of 512 bytes (except
 * the journal) of an SD card. This packet cannot be sent to or from the EFI.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param record is The record number identifies the recording. Consecutive packets from the same recording will have the same record number.
 * \param sequence is SD sequence number, starts at 0 and increasing monotonically. If successive sequence numbers go down the boundary represents a wrap point.
 */
void efiSDCardBlockData_t::encode(efiPacket_t* _pg_pkt, uint16_t record, uint32_t sequence)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes((uint16_t)(0), _pg_data, &_pg_byteindex);

    // The record number identifies the recording. Consecutive packets from the same recording will have the same record number.
    // Range of record is 0 to 65535.
    uint16ToBeBytes(record, _pg_data, &_pg_byteindex);

    // SD sequence number, starts at 0 and increasing monotonically. If successive sequence numbers go down the boundary represents a wrap point.
    // Range of sequence is 0 to -2147483648.
    uint32ToBeBytes(sequence, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiSDCardBlockData_t::encode

/*!
 * \brief Decode the efiSDCardBlockData packet
 *
 * This packet is at the beginning of every valid block of 512 bytes (except
 * the journal) of an SD card. This packet cannot be sent to or from the EFI.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param record receives The record number identifies the recording. Consecutive packets from the same recording will have the same record number.
 * \param sequence receives SD sequence number, starts at 0 and increasing monotonically. If successive sequence numbers go down the boundary represents a wrap point.
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiSDCardBlockData_t::decode(const efiPacket_t* _pg_pkt, uint16_t* record, uint32_t* sequence)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Skip over reserved space
    _pg_byteindex += 2;

    // The record number identifies the recording. Consecutive packets from the same recording will have the same record number.
    // Range of record is 0 to 65535.
    (*record) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // SD sequence number, starts at 0 and increasing monotonically. If successive sequence numbers go down the boundary represents a wrap point.
    // Range of sequence is 0 to -2147483648.
    (*sequence) = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// efiSDCardBlockData_t::decode

/*!
 * \brief Create the efiSensorAutoOffsets packet
 *
 * This packet stores the sensor offset values for sensors that are
 * auto-corrected. It cannot be sent to or from the EFI
 * \param _pg_pkt points to the packet which will be created by this function
 * \param autooffsets is Sensor offset value for those sensors which are auto-corrected. This value will be zero for sensors that are not auto-corrected.
 */
void efiSensorAutoOffsets_t::encode(efiPacket_t* _pg_pkt, const float autooffsets[NUM_EFI_SENSORS])
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // Sensor offset value for those sensors which are auto-corrected. This value will be zero for sensors that are not auto-corrected.
    // Range of autooffsets is -1.0 to 1.0.
    for(_pg_i = 0; _pg_i < NUM_EFI_SENSORS; _pg_i++)
        float32ScaledTo2SignedBeBytes(autooffsets[_pg_i], _pg_data, &_pg_byteindex, 32767.0f);

    for(_pg_i = 0; _pg_i < 4; _pg_i++)
        uint16ToBeBytes((uint16_t)(0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiSensorAutoOffsets_t::encode

/*!
 * \brief Decode the efiSensorAutoOffsets packet
 *
 * This packet stores the sensor offset values for sensors that are
 * auto-corrected. It cannot be sent to or from the EFI
 * \param _pg_pkt points to the packet being decoded by this function
 * \param autooffsets receives Sensor offset value for those sensors which are auto-corrected. This value will be zero for sensors that are not auto-corrected.
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiSensorAutoOffsets_t::decode(const efiPacket_t* _pg_pkt, float autooffsets[NUM_EFI_SENSORS])
{
    unsigned _pg_i = 0;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = geteficommsPacketDataConst(_pg_pkt);
    int _pg_numbytes = geteficommsPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return 0;

    if(_pg_numbytes < minLength())
        return 0;

    // Sensor offset value for those sensors which are auto-corrected. This value will be zero for sensors that are not auto-corrected.
    // Range of autooffsets is -1.0 to 1.0.
    for(_pg_i = 0; _pg_i < NUM_EFI_SENSORS; _pg_i++)
        autooffsets[_pg_i] = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/32767.0f);

    // Skip over reserved space
    _pg_byteindex += 2*4;

    return 1;

}// efiSensorAutoOffsets_t::decode

/*!
 * \brief Create the efiQuickRestart packet
 *
 * This packet provides the minimum amount of data needed to fire the spark and
 * run the injectors, before the entire EFI system and sensors are up and
 * running. This packet is never sent or received; it exists only in backup RAM
 * onboard the EFI.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void efiQuickRestart_t::encode(efiPacket_t* _pg_pkt)
{
    uint8_t* _pg_data = geteficommsPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Set to enable quick start response
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(enablequickrestart, 1) << 7;

    // Global enable based on physical input
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(ioEnable, 1) << 6;

    // User global enable.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(userEnable, 1) << 5;

    // User enable for spark1.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark1UserEnable, 1) << 4;

    // User enable for spark2.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark2UserEnable, 1) << 3;

    // User enable for spark3.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark3UserEnable, 1) << 2;

    // Set if a user throttle command is active.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(userThrottleCmd, 1) << 1;

    // Set if a user rpm command is active.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(userRPMCmd, 1);
    _pg_byteindex += 1; // close bit field


    // The user commanded throttle in percent
    // Range of throttlecmd is 0.0 to 127.5.
    float32ScaledTo1UnsignedBytes(throttlecmd, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Engine speed command in revolutions per minute
    // Range of rpmcmd is 0.0 to 32767.5.
    float32ScaledTo2UnsignedBeBytes(rpmcmd, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Set if ignition is active high
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(ignActiveHigh, 1) << 7;

    // Set if spark 3 is configured enabled
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark3ConfigEnabled, 1) << 6;

    // Set if injector 3 is configured enabled
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(injector3ConfigEnabled, 1) << 5;

    // Direction information for crank 1
    _pg_data[_pg_byteindex] |= (uint8_t)direction1 << 3;

    // Direction information for crank 2
    _pg_data[_pg_byteindex] |= (uint8_t)direction2 << 1;

    // Throttle pwm output time in 4 microseconds
    // Range of pwmOut is 0 to 511.
    _pg_tempbitfield = (unsigned int)limitMax(pwmOut, 511);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field


    // Crank period in 4 microseconds
    // Range of crankPeriod is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(crankPeriod, 65535)), _pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of spark1
    // Range of spark1delay is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(spark1delay, 65535)), _pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of spark2
    // Range of spark2delay is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(spark2delay, 65535)), _pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of spark3
    // Range of spark3delay is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(spark3delay, 65535)), _pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of injector1
    // Range of injector1delay is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(injector1delay, 65535)), _pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of injector2
    // Range of injector2delay is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(injector2delay, 65535)), _pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of injector3
    // Range of injector3delay is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(injector3delay, 65535)), _pg_data, &_pg_byteindex);

    // Injection time in 4 microseconds for injector1
    // Range of injector1period is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(injector1period, 65535)), _pg_data, &_pg_byteindex);

    // Injection time in 4 microseconds for injector2
    // Range of injector2period is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(injector2period, 65535)), _pg_data, &_pg_byteindex);

    // Injection time in 4 microseconds for injector3
    // Range of injector3period is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(injector3period, 65535)), _pg_data, &_pg_byteindex);

    // Spark period in 4 microseconds
    // Range of sparkPeriod is 0 to 65535.
    uint16ToBeBytes((uint16_t)(limitMax(sparkPeriod, 65535)), _pg_data, &_pg_byteindex);

    // Set if spark 1 is being triggered by sense 1
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(spark1usesense1, 1) << 7;

    // Set if spark 2 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark2usesense1, 1) << 6;

    // Set if spark 3 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark3usesense1, 1) << 5;

    // Set if injector 1 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(injector1usesense1, 1) << 4;

    // Set if injector 2 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(injector2usesense1, 1) << 3;

    // Set if injector 3 is being triggered by sense 1
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(injector3usesense1, 1) << 2;

    // Set if spark 1 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark1usesense2, 1) << 1;

    // Set if spark 2 is being triggered by sense 2
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(spark2usesense2, 1);

    // Set if spark 3 is being triggered by sense 2
    _pg_data[_pg_byteindex + 1] = (uint8_t)limitMax(spark3usesense2, 1) << 7;

    // Set if injector 1 is being triggered by sense 2
    _pg_data[_pg_byteindex + 1] |= (uint8_t)limitMax(injector1usesense2, 1) << 6;

    // Set if injector 2 is being triggered by sense 2
    _pg_data[_pg_byteindex + 1] |= (uint8_t)limitMax(injector2usesense2, 1) << 5;

    // Set if injector 3 is being triggered by sense 2
    _pg_data[_pg_byteindex + 1] |= (uint8_t)limitMax(injector3usesense2, 1) << 4;

    // Synchronization status for crank wheel 1
    _pg_data[_pg_byteindex + 1] |= (uint8_t)wheel1SyncStatus << 2;

    // Synchronization status for crank wheel 2
    _pg_data[_pg_byteindex + 1] |= (uint8_t)wheel2SyncStatus;
    _pg_byteindex += 2; // close bit field


    // Details of the crank sense 1 configuration
    crankSense1.encode(_pg_data, &_pg_byteindex);

    // Details of the crank sense 2 configuration
    crankSense2.encode(_pg_data, &_pg_byteindex);

    // The crank wheel tooth, on crank sense 1, that schedules spark1
    // Range of spark1sense1tooth is 0 to 63.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(spark1sense1tooth, 63) << 2;

    // The crank wheel tooth, on crank sense 1, that schedules spark2
    // Range of spark2sense1tooth is 0 to 63.
    _pg_tempbitfield = (unsigned int)limitMax(spark2sense1tooth, 63);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;

    // The crank wheel tooth, on crank sense 1, that schedules spark3
    // Range of spark3sense1tooth is 0 to 63.
    _pg_tempbitfield = (unsigned int)limitMax(spark3sense1tooth, 63);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;

    // The crank wheel tooth, on crank sense 2, that schedules spark1
    // Range of spark1sense2tooth is 0 to 63.
    _pg_data[_pg_byteindex + 2] |= (uint8_t)limitMax(spark1sense2tooth, 63);

    // The crank wheel tooth, on crank sense 2, that schedules spark2
    // Range of spark2sense2tooth is 0 to 63.
    _pg_data[_pg_byteindex + 3] = (uint8_t)limitMax(spark2sense2tooth, 63) << 2;

    // The crank wheel tooth, on crank sense 2, that schedules spark3
    // Range of spark3sense2tooth is 0 to 63.
    _pg_tempbitfield = (unsigned int)limitMax(spark3sense2tooth, 63);
    _pg_data[_pg_byteindex + 4] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_tempbitfield;

    // The crank wheel tooth, on crank sense 1, that schedules injector1
    // Range of injector1sense1tooth is 0 to 63.
    _pg_tempbitfield = (unsigned int)limitMax(injector1sense1tooth, 63);
    _pg_data[_pg_byteindex + 5] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex + 4] |= (uint8_t)_pg_tempbitfield;

    // The crank wheel tooth, on crank sense 1, that schedules injector2
    // Range of injector2sense1tooth is 0 to 63.
    _pg_data[_pg_byteindex + 5] |= (uint8_t)limitMax(injector2sense1tooth, 63);

    // The crank wheel tooth, on crank sense 1, that schedules injector3
    // Range of injector3sense1tooth is 0 to 63.
    _pg_data[_pg_byteindex + 6] = (uint8_t)limitMax(injector3sense1tooth, 63) << 2;

    // The crank wheel tooth, on crank sense 2, that schedules injector1
    // Range of injector1sense2tooth is 0 to 63.
    _pg_tempbitfield = (unsigned int)limitMax(injector1sense2tooth, 63);
    _pg_data[_pg_byteindex + 7] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 6] |= (uint8_t)_pg_tempbitfield;

    // The crank wheel tooth, on crank sense 2, that schedules injector2
    // Range of injector2sense2tooth is 0 to 63.
    _pg_tempbitfield = (unsigned int)limitMax(injector2sense2tooth, 63);
    _pg_data[_pg_byteindex + 8] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex + 7] |= (uint8_t)_pg_tempbitfield;

    // The crank wheel tooth, on crank sense 2, that schedules injector3
    // Range of injector3sense2tooth is 0 to 63.
    _pg_data[_pg_byteindex + 8] |= (uint8_t)limitMax(injector3sense2tooth, 63);
    _pg_byteindex += 9; // close bit field


    // Number of revolutions since the engine started
    // Range of revcountsincestart is 0.0 to 4.2949670400000000e+09.
    float32ScaledTo3UnsignedBeBytes((float)revcountsincestart, _pg_data, &_pg_byteindex, 0.0f, 0.00390625f);

    // Seconds since the engine started
    // Range of secondssincestart is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(secondssincestart, 16777215)), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finisheficommsPacket(_pg_pkt, _pg_byteindex, id());

}// efiQuickRestart_t::encode

/*!
 * \brief Decode the efiQuickRestart packet
 *
 * This packet provides the minimum amount of data needed to fire the spark and
 * run the injectors, before the entire EFI system and sensors are up and
 * running. This packet is never sent or received; it exists only in backup RAM
 * onboard the EFI.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return false is returned if the packet ID or size is wrong, else true
 */
bool efiQuickRestart_t::decode(const efiPacket_t* _pg_pkt)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(geteficommsPacketID(_pg_pkt) != id())
        return false;

    // Verify the packet size
    _pg_numbytes = geteficommsPacketSize(_pg_pkt);
    if(_pg_numbytes < minLength())
        return false;

    // The raw data from the packet
    _pg_data = geteficommsPacketDataConst(_pg_pkt);

    // Set to enable quick start response
    enablequickrestart = (_pg_data[_pg_byteindex] >> 7);

    // Global enable based on physical input
    ioEnable = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // User global enable.
    userEnable = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // User enable for spark1.
    spark1UserEnable = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // User enable for spark2.
    spark2UserEnable = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // User enable for spark3.
    spark3UserEnable = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set if a user throttle command is active.
    userThrottleCmd = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set if a user rpm command is active.
    userRPMCmd = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    // The user commanded throttle in percent
    // Range of throttlecmd is 0.0 to 127.5.
    throttlecmd = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Engine speed command in revolutions per minute
    // Range of rpmcmd is 0.0 to 32767.5.
    rpmcmd = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Set if ignition is active high
    ignActiveHigh = (_pg_data[_pg_byteindex] >> 7);

    // Set if spark 3 is configured enabled
    spark3ConfigEnabled = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if injector 3 is configured enabled
    injector3ConfigEnabled = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Direction information for crank 1
    direction1 = (efiCrankDirection)((_pg_data[_pg_byteindex] >> 3) & 0x3);

    // Direction information for crank 2
    direction2 = (efiCrankDirection)((_pg_data[_pg_byteindex] >> 1) & 0x3);

    // Throttle pwm output time in 4 microseconds
    // Range of pwmOut is 0 to 511.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x1);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    pwmOut = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // Crank period in 4 microseconds
    // Range of crankPeriod is 0 to 65535.
    crankPeriod = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of spark1
    // Range of spark1delay is 0 to 65535.
    spark1delay = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of spark2
    // Range of spark2delay is 0 to 65535.
    spark2delay = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of spark3
    // Range of spark3delay is 0 to 65535.
    spark3delay = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of injector1
    // Range of injector1delay is 0 to 65535.
    injector1delay = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of injector2
    // Range of injector2delay is 0 to 65535.
    injector2delay = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Time delay in 4 microseconds from the sense ISR to output of injector3
    // Range of injector3delay is 0 to 65535.
    injector3delay = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Injection time in 4 microseconds for injector1
    // Range of injector1period is 0 to 65535.
    injector1period = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Injection time in 4 microseconds for injector2
    // Range of injector2period is 0 to 65535.
    injector2period = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Injection time in 4 microseconds for injector3
    // Range of injector3period is 0 to 65535.
    injector3period = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Spark period in 4 microseconds
    // Range of sparkPeriod is 0 to 65535.
    sparkPeriod = (uint32_t)uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Set if spark 1 is being triggered by sense 1
    spark1usesense1 = (_pg_data[_pg_byteindex] >> 7);

    // Set if spark 2 is being triggered by sense 1
    spark2usesense1 = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if spark 3 is being triggered by sense 1
    spark3usesense1 = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if injector 1 is being triggered by sense 1
    injector1usesense1 = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set if injector 2 is being triggered by sense 1
    injector2usesense1 = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set if injector 3 is being triggered by sense 1
    injector3usesense1 = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set if spark 1 is being triggered by sense 2
    spark1usesense2 = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set if spark 2 is being triggered by sense 2
    spark2usesense2 = ((_pg_data[_pg_byteindex]) & 0x1);

    // Set if spark 3 is being triggered by sense 2
    spark3usesense2 = (_pg_data[_pg_byteindex + 1] >> 7);

    // Set if injector 1 is being triggered by sense 2
    injector1usesense2 = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // Set if injector 2 is being triggered by sense 2
    injector2usesense2 = ((_pg_data[_pg_byteindex + 1] >> 5) & 0x1);

    // Set if injector 3 is being triggered by sense 2
    injector3usesense2 = ((_pg_data[_pg_byteindex + 1] >> 4) & 0x1);

    // Synchronization status for crank wheel 1
    wheel1SyncStatus = (efiCrankWheelSyncStatus)((_pg_data[_pg_byteindex + 1] >> 2) & 0x3);

    // Synchronization status for crank wheel 2
    wheel2SyncStatus = (efiCrankWheelSyncStatus)((_pg_data[_pg_byteindex + 1]) & 0x3);
    _pg_byteindex += 2; // close bit field

    // Details of the crank sense 1 configuration
    if(crankSense1.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // Details of the crank sense 2 configuration
    if(crankSense2.decode(_pg_data, &_pg_byteindex) == false)
        return false;

    // The crank wheel tooth, on crank sense 1, that schedules spark1
    // Range of spark1sense1tooth is 0 to 63.
    spark1sense1tooth = (_pg_data[_pg_byteindex] >> 2);

    // The crank wheel tooth, on crank sense 1, that schedules spark2
    // Range of spark2sense1tooth is 0 to 63.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    spark2sense1tooth = _pg_tempbitfield;

    // The crank wheel tooth, on crank sense 1, that schedules spark3
    // Range of spark3sense1tooth is 0 to 63.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0xF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 6);

    spark3sense1tooth = _pg_tempbitfield;

    // The crank wheel tooth, on crank sense 2, that schedules spark1
    // Range of spark1sense2tooth is 0 to 63.
    spark1sense2tooth = ((_pg_data[_pg_byteindex + 2]) & 0x3F);

    // The crank wheel tooth, on crank sense 2, that schedules spark2
    // Range of spark2sense2tooth is 0 to 63.
    spark2sense2tooth = (_pg_data[_pg_byteindex + 3] >> 2);

    // The crank wheel tooth, on crank sense 2, that schedules spark3
    // Range of spark3sense2tooth is 0 to 63.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 3] & 0x3);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 4] >> 4);

    spark3sense2tooth = _pg_tempbitfield;

    // The crank wheel tooth, on crank sense 1, that schedules injector1
    // Range of injector1sense1tooth is 0 to 63.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 4] & 0xF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 5] >> 6);

    injector1sense1tooth = _pg_tempbitfield;

    // The crank wheel tooth, on crank sense 1, that schedules injector2
    // Range of injector2sense1tooth is 0 to 63.
    injector2sense1tooth = ((_pg_data[_pg_byteindex + 5]) & 0x3F);

    // The crank wheel tooth, on crank sense 1, that schedules injector3
    // Range of injector3sense1tooth is 0 to 63.
    injector3sense1tooth = (_pg_data[_pg_byteindex + 6] >> 2);

    // The crank wheel tooth, on crank sense 2, that schedules injector1
    // Range of injector1sense2tooth is 0 to 63.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 6] & 0x3);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 7] >> 4);

    injector1sense2tooth = _pg_tempbitfield;

    // The crank wheel tooth, on crank sense 2, that schedules injector2
    // Range of injector2sense2tooth is 0 to 63.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 7] & 0xF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 8] >> 6);

    injector2sense2tooth = _pg_tempbitfield;

    // The crank wheel tooth, on crank sense 2, that schedules injector3
    // Range of injector3sense2tooth is 0 to 63.
    injector3sense2tooth = ((_pg_data[_pg_byteindex + 8]) & 0x3F);
    _pg_byteindex += 9; // close bit field

    // Number of revolutions since the engine started
    // Range of revcountsincestart is 0.0 to 4.2949670400000000e+09.
    revcountsincestart = (uint32_t)float32ScaledFrom3UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.00390625f);

    // Seconds since the engine started
    // Range of secondssincestart is 0 to 16777215.
    secondssincestart = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    return true;

}// efiQuickRestart_t::decode
# end of eficomms.py
