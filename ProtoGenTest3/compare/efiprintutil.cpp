// efiprintutil.cpp was generated by ProtoGen version 3.1.d

#include "efiprintutil.hpp"
#include <sstream>
#include <iomanip>
#include <cstring>
#include "fieldencode.h"

//! Create a numeric string with a specific number of decimal places
static std::string to_formatted_string(double number, int precision);

/*!
 * Create a numeric string with a specific number of decimal places
 * \param number is the number to convert to string
 * \param precision is the number of decimal places to output
 * \return the number as a string
 */
std::string to_formatted_string(double number, int precision)
{
    // This function exists becuase of a bug in GCC which prevents this from working correctly:
    // string = (std::stringstream() << std::setprecision(7) << _pg_user1->indices[_pg_i]).str()

    std::stringstream stream;
    stream << std::setprecision(precision);
    stream << number;
    return stream.str();

}// to_formatted_string

//! Extract text that is identified by a key
static std::string extractText(const std::string& key, const std::string& source, int* fieldcount);

/*!
 * Extract text that is identified by a key
 * \param key is the key, the text to extract follows the key and is on the same line
 * \param source is the source information to find the key in
 * \param fieldcount is incremented whenever the key is found in the source
 * \return the extracted text, which may be empty
 */
std::string extractText(const std::string& key, const std::string& source, int* fieldcount)
{
    std::string text;

    std::string::size_type index = source.find(key);

    if(index < source.size())
    {
        // This is the location of the first character after the key
        std::string::size_type first = index + key.size();

        // The location of the next linefeed after the key
        std::string::size_type linefeed = source.find("\n", first);

        // This is how many characters until we get to the linefeed
        if((linefeed > first) && (linefeed < source.size()))
        {
            // This is the number of characters to remove
            std::string::size_type length = linefeed - first;

            // Increment our field count
            (*fieldcount)++;

            // Extract the text between the key and the linefeed
            text = source.substr(first, length);

            // Remove the first " '" from the string
            if((text.size() > 1) && (text.at(0) == ' ') && (text.at(1) == '\''))
                text.erase(0, 2);

            // Remove the last "'" from the string
            if((text.size() > 0) && (text.back() == '\''))
                text.erase(text.size()-1, 1);
        }
    }

    return text;

}// extractText

/*!
 * Generate a string that describes the contents of a efiDate_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiDate_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":day" + " '" + std::to_string(day) + "'\n";

    _pg_report += _pg_prename + ":month" + " '" + std::to_string(month) + "'\n";

    _pg_report += _pg_prename + ":year" + " '" + std::to_string(year) + "'\n";

    return _pg_report;

}// efiDate_t::textPrint

/*!
 * Read the contents of a efiDate_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiDate_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":day", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        day = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":month", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        month = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":year", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        year = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// efiDate_t::textRead

/*!
 * Generate a string that describes the contents of a efiDateTime_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiDateTime_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":jiffytime" + " '" + std::to_string(jiffytime) + "'\n";

    _pg_report += _pg_prename + ":day" + " '" + std::to_string(day) + "'\n";

    _pg_report += _pg_prename + ":month" + " '" + std::to_string(month) + "'\n";

    _pg_report += _pg_prename + ":year" + " '" + std::to_string(year) + "'\n";

    return _pg_report;

}// efiDateTime_t::textPrint

/*!
 * Read the contents of a efiDateTime_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiDateTime_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":jiffytime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        jiffytime = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":day", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        day = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":month", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        month = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":year", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        year = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// efiDateTime_t::textRead

/*!
 * Generate a string that describes the contents of a efiCrankSense_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiCrankSense_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":enableWheel" + " '" + std::to_string(enableWheel) + "'\n";

    _pg_report += _pg_prename + ":activeHigh" + " '" + std::to_string(activeHigh) + "'\n";

    _pg_report += _pg_prename + ":disableSensor" + " '" + std::to_string(disableSensor) + "'\n";

    _pg_report += _pg_prename + ":preferThisSensor" + " '" + std::to_string(preferThisSensor) + "'\n";

    _pg_report += _pg_prename + ":senseDelay" + " '" + std::to_string(senseDelay) + "'\n";

    _pg_report += _pg_prename + ":normalOffset" + " '" +  to_formatted_string(normalOffset, 7) + "'\n";

    _pg_report += _pg_prename + ":reverseOffset" + " '" +  to_formatted_string(reverseOffset, 7) + "'\n";

    _pg_report += _pg_prename + ":totalCount" + " '" + std::to_string(totalCount) + "'\n";

    _pg_report += _pg_prename + ":bigGapCount" + " '" + std::to_string(bigGapCount) + "'\n";

    _pg_report += _pg_prename + ":smallGapCount" + " '" + std::to_string(smallGapCount) + "'\n";

    _pg_report += _pg_prename + ":normalIntraGapCount" + " '" + std::to_string(normalIntraGapCount) + "'\n";

    _pg_report += _pg_prename + ":reverseIntraGapCount" + " '" + std::to_string(reverseIntraGapCount) + "'\n";

    return _pg_report;

}// efiCrankSense_t::textPrint

/*!
 * Read the contents of a efiCrankSense_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiCrankSense_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":enableWheel", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableWheel = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":activeHigh", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        activeHigh = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":disableSensor", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        disableSensor = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":preferThisSensor", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        preferThisSensor = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":senseDelay", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        senseDelay = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":normalOffset", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        normalOffset = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":reverseOffset", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        reverseOffset = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":totalCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        totalCount = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":bigGapCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        bigGapCount = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":smallGapCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        smallGapCount = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":normalIntraGapCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        normalIntraGapCount = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":reverseIntraGapCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        reverseIntraGapCount = (uint8_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// efiCrankSense_t::textRead

/*!
 * Generate a string that describes the contents of a efiTable1D_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiTable1D_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    _pg_report += _pg_prename + ":enabled" + " '" + std::to_string(enabled) + "'\n";

    _pg_report += _pg_prename + ":num" + " '" + std::to_string(num) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        _pg_report += _pg_prename + ":indices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(indices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        _pg_report += _pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(data[_pg_i], 7) + "'\n";

    return _pg_report;

}// efiTable1D_t::textPrint

/*!
 * Read the contents of a efiTable1D_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiTable1D_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;

    _pg_text = extractText(_pg_prename + ":enabled", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enabled = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":num", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        num = (unsigned)(std::stoul(_pg_text));

    for(_pg_i = 0; _pg_i < (unsigned)num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":indices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            indices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            data[_pg_i] = std::stof(_pg_text);
    }

    return _pg_fieldcount;

}// efiTable1D_t::textRead

/*!
 * Generate a string that describes the contents of a EngineWear packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiEngineWear_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiEngineWear_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "EngineWear";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiEngineWear_t::textPrint

/*!
 * Generate a string that describes the contents of a efiEngineWear_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiEngineWear_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":hobbs" + " '" + std::to_string(hobbs) + "'\n";

    _pg_report += _pg_prename + ":revcount" + " '" + std::to_string(revcount) + "'\n";

    _pg_report += _pg_prename + ":hotTime" + " '" + std::to_string(hotTime) + "'\n";

    _pg_report += _pg_prename + ":highLoadTime" + " '" + std::to_string(highLoadTime) + "'\n";

    _pg_report += _pg_prename + ":peakCHT" + " '" +  to_formatted_string(peakCHT, 7) + "'\n";

    _pg_report += _pg_prename + ":numStarts" + " '" + std::to_string(numStarts) + "'\n";

    return _pg_report;

}// efiEngineWear_t::textPrint

/*!
 * Read the contents of a efiEngineWear_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiEngineWear_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":hobbs", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        hobbs = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":revcount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        revcount = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":hotTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        hotTime = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":highLoadTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        highLoadTime = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":peakCHT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        peakCHT = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":numStarts", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        numStarts = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// efiEngineWear_t::textRead

/*!
 * Generate a string that describes the contents of a efiMaintenanceItemStatus_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiMaintenanceItemStatus_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":triggered" + " '" + std::to_string(triggered) + "'\n";

    _pg_report += _pg_prename + ":index" + " '" + std::to_string(index) + "'\n";

    _pg_report += servicetime.textPrint(_pg_prename + ":servicetime");

    _pg_report += _pg_prename + ":lastdone" + " '" + std::to_string(lastdone) + "'\n";

    _pg_report += _pg_prename + ":name '" + std::string(name) + "'\n";

    return _pg_report;

}// efiMaintenanceItemStatus_t::textPrint

/*!
 * Read the contents of a efiMaintenanceItemStatus_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiMaintenanceItemStatus_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":triggered", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        triggered = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":index", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        index = (uint8_t)(std::stoul(_pg_text));

    _pg_fieldcount += servicetime.textRead(_pg_prename + ":servicetime", _pg_source);

    _pg_text = extractText(_pg_prename + ":lastdone", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        lastdone = (uint32_t)(std::stoul(_pg_text));

    pgstrncpy(name, extractText(_pg_prename + ":name", _pg_source, &_pg_fieldcount).c_str(), maxNameCharacters);

    return _pg_fieldcount;

}// efiMaintenanceItemStatus_t::textRead

/*!
 * Generate a string that describes the contents of a MaintenanceStatus packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiMaintenanceStatus_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiMaintenanceStatus_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "MaintenanceStatus";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiMaintenanceStatus_t::textPrint

/*!
 * Generate a string that describes the contents of a efiMaintenanceStatus_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiMaintenanceStatus_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    _pg_report += _pg_prename + ":domaintenance" + " '" + std::to_string(domaintenance) + "'\n";

    _pg_report += _pg_prename + ":setEngineSerial" + " '" + std::to_string(setEngineSerial) + "'\n";

    _pg_report += _pg_prename + ":numItems" + " '" + std::to_string(numItems) + "'\n";

    _pg_report += _pg_prename + ":engineSerial" + " '" + std::to_string(engineSerial) + "'\n";

    // List of maintenance item status
    for(_pg_i = 0; _pg_i < (unsigned)numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_report += MaintenanceItemStatus[_pg_i].textPrint(_pg_prename + ":MaintenanceItemStatus" + "[" + std::to_string(_pg_i) + "]");

    return _pg_report;

}// efiMaintenanceStatus_t::textPrint

/*!
 * Read the contents of a efiMaintenanceStatus_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiMaintenanceStatus_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;

    _pg_text = extractText(_pg_prename + ":domaintenance", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        domaintenance = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":setEngineSerial", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        setEngineSerial = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":numItems", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        numItems = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":engineSerial", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        engineSerial = (uint32_t)(std::stoul(_pg_text));

    // List of maintenance item status
    for(_pg_i = 0; _pg_i < (unsigned)numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_fieldcount += MaintenanceItemStatus[_pg_i].textRead(_pg_prename + ":MaintenanceItemStatus" + "[" + std::to_string(_pg_i) + "]", _pg_source);

    return _pg_fieldcount;

}// efiMaintenanceStatus_t::textRead

/*!
 * Generate a string that describes the contents of a LogEntry packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiLogEntry_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiLogEntry_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "LogEntry";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiLogEntry_t::textPrint

/*!
 * Generate a string that describes the contents of a efiLogEntry_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiLogEntry_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":cmd" + " '" + std::to_string(cmd) + "'\n";

    _pg_report += _pg_prename + ":index" + " '" + std::to_string(index) + "'\n";

    _pg_report += time.textPrint(_pg_prename + ":time");

    _pg_report += _pg_prename + ":name '" + std::string(name) + "'\n";

    _pg_report += _pg_prename + ":description '" + std::string(description) + "'\n";

    return _pg_report;

}// efiLogEntry_t::textPrint

/*!
 * Read the contents of a efiLogEntry_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiLogEntry_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":cmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        cmd = (LogEntryCommands)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":index", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        index = (uint16_t)(std::stoul(_pg_text));

    _pg_fieldcount += time.textRead(_pg_prename + ":time", _pg_source);

    pgstrncpy(name, extractText(_pg_prename + ":name", _pg_source, &_pg_fieldcount).c_str(), maxNameCharacters);

    pgstrncpy(description, extractText(_pg_prename + ":description", _pg_source, &_pg_fieldcount).c_str(), EFI_PACKET_SIZE - maxNameCharacters - 7);

    return _pg_fieldcount;

}// efiLogEntry_t::textRead

/*!
 * Generate a string that describes the contents of a File packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiFile_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiFile_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "File";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiFile_t::textPrint

/*!
 * Generate a string that describes the contents of a efiFile_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiFile_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += date.textPrint(_pg_prename + ":date");

    _pg_report += _pg_prename + ":filename '" + std::string(filename) + "'\n";

    return _pg_report;

}// efiFile_t::textPrint

/*!
 * Read the contents of a efiFile_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiFile_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_fieldcount += date.textRead(_pg_prename + ":date", _pg_source);

    pgstrncpy(filename, extractText(_pg_prename + ":filename", _pg_source, &_pg_fieldcount).c_str(), 128);

    return _pg_fieldcount;

}// efiFile_t::textRead

/*!
 * Generate a string that describes the contents of a Comment packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiComment_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiComment_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "Comment";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiComment_t::textPrint

/*!
 * Generate a string that describes the contents of a efiComment_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiComment_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        _pg_report += _pg_prename + ":userdata" + "[" + std::to_string(_pg_i) + "]" + " '" + std::to_string(userdata[_pg_i]) + "'\n";

    _pg_report += _pg_prename + ":comment '" + std::string(comment) + "'\n";

    return _pg_report;

}// efiComment_t::textPrint

/*!
 * Read the contents of a efiComment_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiComment_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;

    for(_pg_i = 0; _pg_i < 8; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":userdata" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            userdata[_pg_i] = (uint8_t)(std::stoul(_pg_text));
    }

    pgstrncpy(comment, extractText(_pg_prename + ":comment", _pg_source, &_pg_fieldcount).c_str(), 512);

    return _pg_fieldcount;

}// efiComment_t::textRead

/*!
 * Generate a string that describes the contents of a LockControl packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiLockControl_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiLockControl_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "LockControl";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiLockControl_t::textPrint

/*!
 * Generate a string that describes the contents of a efiLockControl_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiLockControl_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":tablesProtection" + " '" + std::to_string(tablesProtection) + "'\n";

    _pg_report += _pg_prename + ":governorProtection" + " '" + std::to_string(governorProtection) + "'\n";

    _pg_report += _pg_prename + ":throttleProtection" + " '" + std::to_string(throttleProtection) + "'\n";

    _pg_report += _pg_prename + ":engineProtection" + " '" + std::to_string(engineProtection) + "'\n";

    _pg_report += _pg_prename + ":injectorProtection" + " '" + std::to_string(injectorProtection) + "'\n";

    _pg_report += _pg_prename + ":pumpProtection" + " '" + std::to_string(pumpProtection) + "'\n";

    _pg_report += _pg_prename + ":sensorsProtection" + " '" + std::to_string(sensorsProtection) + "'\n";

    _pg_report += _pg_prename + ":commsProtection" + " '" + std::to_string(commsProtection) + "'\n";

    _pg_report += _pg_prename + ":maintenanceProtection" + " '" + std::to_string(maintenanceProtection) + "'\n";

    _pg_report += _pg_prename + ":coolingProtection" + " '" + std::to_string(coolingProtection) + "'\n";

    _pg_report += _pg_prename + ":password '" + std::string(password) + "'\n";

    return _pg_report;

}// efiLockControl_t::textPrint

/*!
 * Read the contents of a efiLockControl_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiLockControl_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":tablesProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        tablesProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":governorProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        governorProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":throttleProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        throttleProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":engineProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        engineProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":injectorProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        injectorProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":pumpProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        pumpProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":sensorsProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        sensorsProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":commsProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        commsProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":maintenanceProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        maintenanceProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":coolingProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        coolingProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    pgstrncpy(password, extractText(_pg_prename + ":password", _pg_source, &_pg_fieldcount).c_str(), 32);

    return _pg_fieldcount;

}// efiLockControl_t::textRead

/*!
 * Generate a string that describes the contents of a ConfigHash packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiConfigHash_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiConfigHash_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "ConfigHash";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiConfigHash_t::textPrint

/*!
 * Generate a string that describes the contents of a efiConfigHash_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiConfigHash_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":storedParameterHash" + " '" + std::to_string(storedParameterHash) + "'\n";

    _pg_report += _pg_prename + ":actualParameterHash" + " '" + std::to_string(actualParameterHash) + "'\n";

    return _pg_report;

}// efiConfigHash_t::textPrint

/*!
 * Read the contents of a efiConfigHash_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiConfigHash_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":storedParameterHash", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        storedParameterHash = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":actualParameterHash", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        actualParameterHash = (uint32_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// efiConfigHash_t::textRead

/*!
 * Generate a string that describes the contents of a PumpConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiPumpConfiguration_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiPumpConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "PumpConfiguration";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiPumpConfiguration_t::textPrint

/*!
 * Generate a string that describes the contents of a efiPumpConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiPumpConfiguration_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":fuelPressureCmd" + " '" +  to_formatted_string(fuelPressureCmd, 7) + "'\n";

    _pg_report += _pg_prename + ":fuelPressureErrorThreshold" + " '" +  to_formatted_string(fuelPressureErrorThreshold, 7) + "'\n";

    _pg_report += _pg_prename + ":minDutyCycle" + " '" +  to_formatted_string(minDutyCycle, 7) + "'\n";

    _pg_report += _pg_prename + ":maxDutyCycle" + " '" +  to_formatted_string(maxDutyCycle, 7) + "'\n";

    _pg_report += _pg_prename + ":fuelPressureBangBangThreshold" + " '" +  to_formatted_string(fuelPressureBangBangThreshold, 7) + "'\n";

    _pg_report += _pg_prename + ":proGain" + " '" +  to_formatted_string(proGain, 7) + "'\n";

    _pg_report += _pg_prename + ":intGain" + " '" +  to_formatted_string(intGain, 7) + "'\n";

    _pg_report += _pg_prename + ":forGain" + " '" +  to_formatted_string(forGain, 7) + "'\n";

    _pg_report += _pg_prename + ":rpmEnablesPump" + " '" + std::to_string(rpmEnablesPump) + "'\n";

    _pg_report += _pg_prename + ":primeTime" + " '" + std::to_string(primeTime) + "'\n";

    _pg_report += _pg_prename + ":maxIfFailure" + " '" + std::to_string(maxIfFailure) + "'\n";

    _pg_report += _pg_prename + ":positiveRateLimit" + " '" +  to_formatted_string(positiveRateLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":negativeRateLimit" + " '" +  to_formatted_string(negativeRateLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":_outputRateLimit" + " '" +  to_formatted_string(_outputRateLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":pwmPeriod" + " '" + std::to_string(pwmPeriod) + "'\n";

    return _pg_report;

}// efiPumpConfiguration_t::textPrint

/*!
 * Read the contents of a efiPumpConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiPumpConfiguration_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":fuelPressureCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        fuelPressureCmd = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":fuelPressureErrorThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        fuelPressureErrorThreshold = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":minDutyCycle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        minDutyCycle = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":maxDutyCycle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        maxDutyCycle = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":fuelPressureBangBangThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        fuelPressureBangBangThreshold = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":proGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        proGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":intGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        intGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":forGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        forGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":rpmEnablesPump", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        rpmEnablesPump = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":primeTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        primeTime = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":maxIfFailure", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        maxIfFailure = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":positiveRateLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        positiveRateLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":negativeRateLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        negativeRateLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":_outputRateLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _outputRateLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":pwmPeriod", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        pwmPeriod = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// efiPumpConfiguration_t::textRead

/*!
 * Generate a string that describes the contents of a efiCANconfig_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiCANconfig_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":baud" + " '" + std::to_string(baud) + "'\n";

    _pg_report += _pg_prename + ":typeShift" + " '" + std::to_string(typeShift) + "'\n";

    _pg_report += _pg_prename + ":longid" + " '" + std::to_string(longid) + "'\n";

    _pg_report += _pg_prename + ":disableNativeInput" + " '" + std::to_string(disableNativeInput) + "'\n";

    _pg_report += _pg_prename + ":inputBaseId" + " '" + std::to_string(inputBaseId) + "'\n";

    _pg_report += _pg_prename + ":disableNativeOutput" + " '" + std::to_string(disableNativeOutput) + "'\n";

    _pg_report += _pg_prename + ":outputBaseId" + " '" + std::to_string(outputBaseId) + "'\n";

    _pg_report += _pg_prename + ":disableNativeBroadcast" + " '" + std::to_string(disableNativeBroadcast) + "'\n";

    _pg_report += _pg_prename + ":broadcastBaseId" + " '" + std::to_string(broadcastBaseId) + "'\n";

    _pg_report += _pg_prename + ":forcePacketOverCAN" + " '" + std::to_string(forcePacketOverCAN) + "'\n";

    _pg_report += _pg_prename + ":cmdAndTmOnly" + " '" + std::to_string(cmdAndTmOnly) + "'\n";

    _pg_report += _pg_prename + ":enableGCU" + " '" + std::to_string(enableGCU) + "'\n";

    _pg_report += _pg_prename + ":enablePE3ECU" + " '" + std::to_string(enablePE3ECU) + "'\n";

    _pg_report += _pg_prename + ":enableCurrawongECU" + " '" + std::to_string(enableCurrawongECU) + "'\n";

    _pg_report += _pg_prename + ":enablePiccoloECU" + " '" + std::to_string(enablePiccoloECU) + "'\n";

    _pg_report += _pg_prename + ":alternativeProtocolAddress" + " '" + std::to_string(alternativeProtocolAddress) + "'\n";

    return _pg_report;

}// efiCANconfig_t::textPrint

/*!
 * Read the contents of a efiCANconfig_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiCANconfig_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":baud", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        baud = (CANBaudEnums)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":typeShift", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        typeShift = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":longid", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        longid = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":disableNativeInput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        disableNativeInput = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":inputBaseId", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        inputBaseId = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":disableNativeOutput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        disableNativeOutput = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":outputBaseId", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        outputBaseId = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":disableNativeBroadcast", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        disableNativeBroadcast = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":broadcastBaseId", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        broadcastBaseId = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":forcePacketOverCAN", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        forcePacketOverCAN = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":cmdAndTmOnly", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        cmdAndTmOnly = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableGCU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableGCU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enablePE3ECU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enablePE3ECU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableCurrawongECU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableCurrawongECU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enablePiccoloECU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enablePiccoloECU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":alternativeProtocolAddress", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        alternativeProtocolAddress = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// efiCANconfig_t::textRead

/*!
 * Generate a string that describes the contents of a CommConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiCommConfiguration_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiCommConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "CommConfiguration";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiCommConfiguration_t::textPrint

/*!
 * Generate a string that describes the contents of a efiCommConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiCommConfiguration_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":disableSDRecording" + " '" + std::to_string(disableSDRecording) + "'\n";

    _pg_report += _pg_prename + ":fastTelemetrySDRate" + " '" + std::to_string(fastTelemetrySDRate) + "'\n";

    _pg_report += _pg_prename + ":fastTelemetryRate" + " '" + std::to_string(fastTelemetryRate) + "'\n";

    _pg_report += _pg_prename + ":recordSDAlways" + " '" + std::to_string(recordSDAlways) + "'\n";

    _pg_report += _pg_prename + ":slowTelemetrySDRate" + " '" + std::to_string(slowTelemetrySDRate) + "'\n";

    _pg_report += _pg_prename + ":slowTelemetryRate" + " '" + std::to_string(slowTelemetryRate) + "'\n";

    _pg_report += _pg_prename + ":useSummaryPackets" + " '" + std::to_string(useSummaryPackets) + "'\n";

    _pg_report += _pg_prename + ":setToDefault" + " '" + std::to_string(setToDefault) + "'\n";

    _pg_report += _pg_prename + ":enableCurrawongECU" + " '" + std::to_string(enableCurrawongECU) + "'\n";

    _pg_report += _pg_prename + ":uartBaud" + " '" + std::to_string(uartBaud) + "'\n";

    // Configuration data for CAN communciations
    _pg_report += CANconfig.textPrint(_pg_prename + ":CANconfig");

    return _pg_report;

}// efiCommConfiguration_t::textPrint

/*!
 * Read the contents of a efiCommConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiCommConfiguration_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":disableSDRecording", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        disableSDRecording = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":fastTelemetrySDRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        fastTelemetrySDRate = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":fastTelemetryRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        fastTelemetryRate = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":recordSDAlways", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        recordSDAlways = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":slowTelemetrySDRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        slowTelemetrySDRate = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":slowTelemetryRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        slowTelemetryRate = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":useSummaryPackets", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        useSummaryPackets = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":setToDefault", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        setToDefault = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableCurrawongECU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableCurrawongECU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":uartBaud", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        uartBaud = (uint32_t)(std::stoul(_pg_text));

    // Configuration data for CAN communciations
    _pg_fieldcount += CANconfig.textRead(_pg_prename + ":CANconfig", _pg_source);

    return _pg_fieldcount;

}// efiCommConfiguration_t::textRead

/*!
 * Generate a string that describes the contents of a SensorConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiSensorConfiguration_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiSensorConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "SensorConfiguration";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiSensorConfiguration_t::textPrint

/*!
 * Generate a string that describes the contents of a efiSensorConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiSensorConfiguration_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":enabled" + " '" + std::to_string(enabled) + "'\n";

    _pg_report += _pg_prename + ":kty84" + " '" + std::to_string(kty84) + "'\n";

    _pg_report += _pg_prename + ":sealedGauge" + " '" + std::to_string(sealedGauge) + "'\n";

    _pg_report += _pg_prename + ":sensor" + " '" + std::to_string(sensor) + "'\n";

    _pg_report += _pg_prename + ":filterlpf" + " '" +  to_formatted_string(filterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":offset" + " '" +  to_formatted_string(offset, 7) + "'\n";

    _pg_report += _pg_prename + ":gain" + " '" +  to_formatted_string(gain, 7) + "'\n";

    _pg_report += _pg_prename + ":failedvalue" + " '" +  to_formatted_string(failedvalue, 7) + "'\n";

    _pg_report += _pg_prename + ":min" + " '" +  to_formatted_string(min, 7) + "'\n";

    _pg_report += _pg_prename + ":max" + " '" +  to_formatted_string(max, 7) + "'\n";

    _pg_report += _pg_prename + ":kty83" + " '" + std::to_string(kty83) + "'\n";

    _pg_report += _pg_prename + ":setToDefault" + " '" + std::to_string(setToDefault) + "'\n";

    _pg_report += _pg_prename + ":calibrate" + " '" + std::to_string(calibrate) + "'\n";

    _pg_report += _pg_prename + ":calibrateoffset" + " '" + std::to_string(calibrateoffset) + "'\n";

    _pg_report += _pg_prename + ":calibrategain" + " '" + std::to_string(calibrategain) + "'\n";

    _pg_report += _pg_prename + ":enableAutocorrect" + " '" + std::to_string(enableAutocorrect) + "'\n";

    _pg_report += _pg_prename + ":platinum1000rtd" + " '" + std::to_string(platinum1000rtd) + "'\n";

    _pg_report += _pg_prename + ":calibrationvalue" + " '" +  to_formatted_string(calibrationvalue, 7) + "'\n";

    return _pg_report;

}// efiSensorConfiguration_t::textPrint

/*!
 * Read the contents of a efiSensorConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiSensorConfiguration_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":enabled", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enabled = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":kty84", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        kty84 = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":sealedGauge", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        sealedGauge = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":sensor", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        sensor = (efiSensorEnum)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":filterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        filterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":offset", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        offset = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":gain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        gain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":failedvalue", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        failedvalue = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":min", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        min = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":max", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        max = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":kty83", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        kty83 = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":setToDefault", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        setToDefault = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":calibrate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        calibrate = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":calibrateoffset", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        calibrateoffset = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":calibrategain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        calibrategain = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableAutocorrect", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableAutocorrect = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":platinum1000rtd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        platinum1000rtd = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":calibrationvalue", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        calibrationvalue = std::stof(_pg_text);

    return _pg_fieldcount;

}// efiSensorConfiguration_t::textRead

/*!
 * Generate a string that describes the contents of a ThrottleConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiThrottleConfiguration_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiThrottleConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "ThrottleConfiguration";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiThrottleConfiguration_t::textPrint

/*!
 * Generate a string that describes the contents of a efiThrottleConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiThrottleConfiguration_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":closedPWMoutput" + " '" + std::to_string(closedPWMoutput) + "'\n";

    _pg_report += _pg_prename + ":openPWMoutput" + " '" + std::to_string(openPWMoutput) + "'\n";

    _pg_report += _pg_prename + ":inputfilterlpf" + " '" +  to_formatted_string(inputfilterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":outputRateLimit" + " '" +  to_formatted_string(outputRateLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":enableAnalogCmd" + " '" + std::to_string(enableAnalogCmd) + "'\n";

    _pg_report += _pg_prename + ":enablePWMCmd" + " '" + std::to_string(enablePWMCmd) + "'\n";

    _pg_report += _pg_prename + ":efiDrivesThrottle" + " '" + std::to_string(efiDrivesThrottle) + "'\n";

    _pg_report += _pg_prename + ":enableAnalogTPS" + " '" + std::to_string(enableAnalogTPS) + "'\n";

    _pg_report += _pg_prename + ":enablePWMTPS" + " '" + std::to_string(enablePWMTPS) + "'\n";

    _pg_report += _pg_prename + ":_enableCECANServo" + " '" + std::to_string(_enableCECANServo) + "'\n";

    _pg_report += _pg_prename + ":enableCECANTPS" + " '" + std::to_string(enableCECANTPS) + "'\n";

    _pg_report += _pg_prename + ":enableMAPTPS" + " '" + std::to_string(enableMAPTPS) + "'\n";

    _pg_report += curve.textPrint(_pg_prename + ":curve");

    _pg_report += _pg_prename + ":startThrottle" + " '" +  to_formatted_string(startThrottle, 7) + "'\n";

    _pg_report += _pg_prename + ":cecanAddress" + " '" + std::to_string(cecanAddress) + "'\n";

    _pg_report += _pg_prename + ":tpsErrorThreshold" + " '" +  to_formatted_string(tpsErrorThreshold, 7) + "'\n";

    _pg_report += _pg_prename + ":maxStartThrottle" + " '" +  to_formatted_string(maxStartThrottle, 7) + "'\n";

    _pg_report += _pg_prename + ":closedPWMinput" + " '" + std::to_string(closedPWMinput) + "'\n";

    _pg_report += _pg_prename + ":openPWMinput" + " '" + std::to_string(openPWMinput) + "'\n";

    _pg_report += _pg_prename + ":tpsFeedbackIntGain" + " '" +  to_formatted_string(tpsFeedbackIntGain, 7) + "'\n";

    return _pg_report;

}// efiThrottleConfiguration_t::textPrint

/*!
 * Read the contents of a efiThrottleConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiThrottleConfiguration_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":closedPWMoutput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        closedPWMoutput = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":openPWMoutput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        openPWMoutput = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":inputfilterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        inputfilterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":outputRateLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        outputRateLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":enableAnalogCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableAnalogCmd = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enablePWMCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enablePWMCmd = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":efiDrivesThrottle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        efiDrivesThrottle = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableAnalogTPS", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableAnalogTPS = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enablePWMTPS", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enablePWMTPS = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":_enableCECANServo", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _enableCECANServo = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableCECANTPS", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableCECANTPS = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableMAPTPS", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableMAPTPS = (uint8_t)(std::stoul(_pg_text));

    _pg_fieldcount += curve.textRead(_pg_prename + ":curve", _pg_source);

    _pg_text = extractText(_pg_prename + ":startThrottle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        startThrottle = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":cecanAddress", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        cecanAddress = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":tpsErrorThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        tpsErrorThreshold = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":maxStartThrottle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        maxStartThrottle = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":closedPWMinput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        closedPWMinput = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":openPWMinput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        openPWMinput = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":tpsFeedbackIntGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        tpsFeedbackIntGain = std::stof(_pg_text);

    return _pg_fieldcount;

}// efiThrottleConfiguration_t::textRead

/*!
 * Generate a string that describes the contents of a CoolingConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiCoolingConfiguration_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiCoolingConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "CoolingConfiguration";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiCoolingConfiguration_t::textPrint

/*!
 * Generate a string that describes the contents of a efiCoolingConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiCoolingConfiguration_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":chtTooCold" + " '" +  to_formatted_string(chtTooCold, 7) + "'\n";

    _pg_report += _pg_prename + ":chtTooHot" + " '" +  to_formatted_string(chtTooHot, 7) + "'\n";

    _pg_report += _pg_prename + ":chtDesired" + " '" +  to_formatted_string(chtDesired, 7) + "'\n";

    _pg_report += _pg_prename + ":derTime" + " '" +  to_formatted_string(derTime, 7) + "'\n";

    _pg_report += _pg_prename + ":trajGain" + " '" +  to_formatted_string(trajGain, 7) + "'\n";

    _pg_report += _pg_prename + ":forGain" + " '" +  to_formatted_string(forGain, 7) + "'\n";

    _pg_report += _pg_prename + ":proGain" + " '" +  to_formatted_string(proGain, 7) + "'\n";

    _pg_report += _pg_prename + ":intGain" + " '" +  to_formatted_string(intGain, 7) + "'\n";

    _pg_report += _pg_prename + ":derGain" + " '" +  to_formatted_string(derGain, 7) + "'\n";

    _pg_report += _pg_prename + ":enableSplitCooling" + " '" + std::to_string(enableSplitCooling) + "'\n";

    _pg_report += _pg_prename + ":closedPWM1" + " '" + std::to_string(closedPWM1) + "'\n";

    _pg_report += _pg_prename + ":openPWM1" + " '" + std::to_string(openPWM1) + "'\n";

    _pg_report += _pg_prename + ":closedPWM2" + " '" + std::to_string(closedPWM2) + "'\n";

    _pg_report += _pg_prename + ":openPWM2" + " '" + std::to_string(openPWM2) + "'\n";

    _pg_report += _pg_prename + ":cecanAddress1" + " '" + std::to_string(cecanAddress1) + "'\n";

    _pg_report += _pg_prename + ":cecanAddress2" + " '" + std::to_string(cecanAddress2) + "'\n";

    return _pg_report;

}// efiCoolingConfiguration_t::textPrint

/*!
 * Read the contents of a efiCoolingConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiCoolingConfiguration_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":chtTooCold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        chtTooCold = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":chtTooHot", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        chtTooHot = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":chtDesired", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        chtDesired = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":derTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        derTime = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":trajGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        trajGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":forGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        forGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":proGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        proGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":intGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        intGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":derGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        derGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":enableSplitCooling", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableSplitCooling = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":closedPWM1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        closedPWM1 = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":openPWM1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        openPWM1 = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":closedPWM2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        closedPWM2 = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":openPWM2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        openPWM2 = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":cecanAddress1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        cecanAddress1 = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":cecanAddress2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        cecanAddress2 = (uint8_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// efiCoolingConfiguration_t::textRead

/*!
 * Generate a string that describes the contents of a EngineConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiEngineConfiguration_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiEngineConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "EngineConfiguration";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiEngineConfiguration_t::textPrint

/*!
 * Generate a string that describes the contents of a efiEngineConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiEngineConfiguration_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":displacement" + " '" +  to_formatted_string(displacement, 7) + "'\n";

    _pg_report += _pg_prename + ":ignoreInputEnable" + " '" + std::to_string(ignoreInputEnable) + "'\n";

    _pg_report += _pg_prename + ":preventNormalRotation" + " '" + std::to_string(preventNormalRotation) + "'\n";

    _pg_report += _pg_prename + ":preventReverseRotation" + " '" + std::to_string(preventReverseRotation) + "'\n";

    _pg_report += _pg_prename + ":_enableCrank2" + " '" + std::to_string(_enableCrank2) + "'\n";

    _pg_report += _pg_prename + ":enableSpark3" + " '" + std::to_string(enableSpark3) + "'\n";

    _pg_report += _pg_prename + ":ignActiveHigh" + " '" + std::to_string(ignActiveHigh) + "'\n";

    _pg_report += _pg_prename + ":api8" + " '" + std::to_string(api8) + "'\n";

    _pg_report += _pg_prename + ":maxIgnDwellTime" + " '" + std::to_string(maxIgnDwellTime) + "'\n";

    _pg_report += _pg_prename + ":minIgnActiveTime" + " '" + std::to_string(minIgnActiveTime) + "'\n";

    _pg_report += _pg_prename + ":hardRevLimit" + " '" +  to_formatted_string(hardRevLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":softRevLimit" + " '" +  to_formatted_string(softRevLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":rpmfilterlpf" + " '" +  to_formatted_string(rpmfilterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":mapErrorThreshold" + " '" +  to_formatted_string(mapErrorThreshold, 7) + "'\n";

    _pg_report += crankSense1.textPrint(_pg_prename + ":crankSense1");

    _pg_report += crankSense2.textPrint(_pg_prename + ":crankSense2");

    _pg_report += _pg_prename + ":chtReference" + " '" +  to_formatted_string(chtReference, 7) + "'\n";

    return _pg_report;

}// efiEngineConfiguration_t::textPrint

/*!
 * Read the contents of a efiEngineConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiEngineConfiguration_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":displacement", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        displacement = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":ignoreInputEnable", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        ignoreInputEnable = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":preventNormalRotation", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        preventNormalRotation = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":preventReverseRotation", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        preventReverseRotation = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":_enableCrank2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _enableCrank2 = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableSpark3", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableSpark3 = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":ignActiveHigh", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        ignActiveHigh = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":api8", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        api8 = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":maxIgnDwellTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        maxIgnDwellTime = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":minIgnActiveTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        minIgnActiveTime = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":hardRevLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        hardRevLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":softRevLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        softRevLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":rpmfilterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        rpmfilterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":mapErrorThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        mapErrorThreshold = std::stof(_pg_text);

    _pg_fieldcount += crankSense1.textRead(_pg_prename + ":crankSense1", _pg_source);

    _pg_fieldcount += crankSense2.textRead(_pg_prename + ":crankSense2", _pg_source);

    _pg_text = extractText(_pg_prename + ":chtReference", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        chtReference = std::stof(_pg_text);

    return _pg_fieldcount;

}// efiEngineConfiguration_t::textRead

/*!
 * Generate a string that describes the contents of a InjectorConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiInjectorConfiguration_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiInjectorConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "InjectorConfiguration";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiInjectorConfiguration_t::textPrint

/*!
 * Generate a string that describes the contents of a efiInjectorConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiInjectorConfiguration_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":enableInjector2" + " '" + std::to_string(enableInjector2) + "'\n";

    _pg_report += _pg_prename + ":enableInjectorIndependence" + " '" + std::to_string(enableInjectorIndependence) + "'\n";

    _pg_report += _pg_prename + ":spareTempIsCHT" + " '" + std::to_string(spareTempIsCHT) + "'\n";

    _pg_report += _pg_prename + ":spareTempIsMAT" + " '" + std::to_string(spareTempIsMAT) + "'\n";

    _pg_report += _pg_prename + ":enableInjector3" + " '" + std::to_string(enableInjector3) + "'\n";

    _pg_report += _pg_prename + ":injectorsAreRedundant" + " '" + std::to_string(injectorsAreRedundant) + "'\n";

    _pg_report += _pg_prename + ":phaseEdge" + " '" + std::to_string(phaseEdge) + "'\n";

    _pg_report += _pg_prename + ":fuelVolumePercentPerMAT" + " '" +  to_formatted_string(fuelVolumePercentPerMAT, 7) + "'\n";

    _pg_report += _pg_prename + ":multiplier" + " '" +  to_formatted_string(multiplier, 7) + "'\n";

    _pg_report += _pg_prename + ":nominalFuelPressure" + " '" +  to_formatted_string(nominalFuelPressure, 7) + "'\n";

    _pg_report += _pg_prename + ":nominalFlowrate1" + " '" +  to_formatted_string(nominalFlowrate1, 7) + "'\n";

    _pg_report += _pg_prename + ":nominalFlowrate2" + " '" +  to_formatted_string(nominalFlowrate2, 7) + "'\n";

    _pg_report += _pg_prename + ":minOpeningTime1" + " '" + std::to_string(minOpeningTime1) + "'\n";

    _pg_report += _pg_prename + ":minOpeningTime2" + " '" + std::to_string(minOpeningTime2) + "'\n";

    _pg_report += _pg_prename + ":fuelUsedCorrector" + " '" +  to_formatted_string(fuelUsedCorrector, 7) + "'\n";

    _pg_report += _pg_prename + ":nominalFlowrate3" + " '" +  to_formatted_string(nominalFlowrate3, 7) + "'\n";

    _pg_report += _pg_prename + ":minOpeningTime3" + " '" + std::to_string(minOpeningTime3) + "'\n";

    _pg_report += _pg_prename + ":oilPrimingFreq" + " '" +  to_formatted_string(oilPrimingFreq, 7) + "'\n";

    _pg_report += _pg_prename + ":spareTempIsOilT" + " '" + std::to_string(spareTempIsOilT) + "'\n";

    _pg_report += _pg_prename + ":injector2IsOilInj" + " '" + std::to_string(injector2IsOilInj) + "'\n";

    _pg_report += _pg_prename + ":injector3IsOilInj" + " '" + std::to_string(injector3IsOilInj) + "'\n";

    _pg_report += _pg_prename + ":oilForStarting" + " '" +  to_formatted_string(oilForStarting, 7) + "'\n";

    _pg_report += _pg_prename + ":oilUsedCorrector" + " '" +  to_formatted_string(oilUsedCorrector, 7) + "'\n";

    return _pg_report;

}// efiInjectorConfiguration_t::textPrint

/*!
 * Read the contents of a efiInjectorConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiInjectorConfiguration_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":enableInjector2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableInjector2 = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableInjectorIndependence", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableInjectorIndependence = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":spareTempIsCHT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        spareTempIsCHT = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":spareTempIsMAT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        spareTempIsMAT = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableInjector3", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableInjector3 = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":injectorsAreRedundant", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        injectorsAreRedundant = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":phaseEdge", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        phaseEdge = (InjectorPhaseEdge)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":fuelVolumePercentPerMAT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        fuelVolumePercentPerMAT = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":multiplier", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        multiplier = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":nominalFuelPressure", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        nominalFuelPressure = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":nominalFlowrate1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        nominalFlowrate1 = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":nominalFlowrate2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        nominalFlowrate2 = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":minOpeningTime1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        minOpeningTime1 = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":minOpeningTime2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        minOpeningTime2 = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":fuelUsedCorrector", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        fuelUsedCorrector = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":nominalFlowrate3", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        nominalFlowrate3 = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":minOpeningTime3", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        minOpeningTime3 = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":oilPrimingFreq", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        oilPrimingFreq = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":spareTempIsOilT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        spareTempIsOilT = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":injector2IsOilInj", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        injector2IsOilInj = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":injector3IsOilInj", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        injector3IsOilInj = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":oilForStarting", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        oilForStarting = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":oilUsedCorrector", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        oilUsedCorrector = std::stof(_pg_text);

    return _pg_fieldcount;

}// efiInjectorConfiguration_t::textRead

/*!
 * Generate a string that describes the contents of a RPMController packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiRPMController_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiRPMController_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "RPMController";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiRPMController_t::textPrint

/*!
 * Generate a string that describes the contents of a efiRPMController_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiRPMController_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":minRPM" + " '" +  to_formatted_string(minRPM, 7) + "'\n";

    _pg_report += _pg_prename + ":maxRPM" + " '" +  to_formatted_string(maxRPM, 7) + "'\n";

    _pg_report += _pg_prename + ":enableRPMfromThrottleCmd" + " '" + std::to_string(enableRPMfromThrottleCmd) + "'\n";

    _pg_report += _pg_prename + ":enableLowRPMLimiter" + " '" + std::to_string(enableLowRPMLimiter) + "'\n";

    _pg_report += _pg_prename + ":enableHighRPMLimiter" + " '" + std::to_string(enableHighRPMLimiter) + "'\n";

    _pg_report += _pg_prename + ":updateRate" + " '" +  to_formatted_string(updateRate, 7) + "'\n";

    _pg_report += _pg_prename + ":throttleAtMinRPM" + " '" +  to_formatted_string(throttleAtMinRPM, 7) + "'\n";

    _pg_report += _pg_prename + ":rpmToThrottlePower" + " '" +  to_formatted_string(rpmToThrottlePower, 7) + "'\n";

    _pg_report += _pg_prename + ":rpmCmdfilterlpf" + " '" +  to_formatted_string(rpmCmdfilterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":maxRateCmd" + " '" +  to_formatted_string(maxRateCmd, 7) + "'\n";

    _pg_report += _pg_prename + ":trajGain" + " '" +  to_formatted_string(trajGain, 7) + "'\n";

    _pg_report += _pg_prename + ":gainScaler" + " '" +  to_formatted_string(gainScaler, 7) + "'\n";

    _pg_report += _pg_prename + ":forGain" + " '" +  to_formatted_string(forGain, 7) + "'\n";

    _pg_report += _pg_prename + ":proGain" + " '" +  to_formatted_string(proGain, 7) + "'\n";

    _pg_report += _pg_prename + ":intGain" + " '" +  to_formatted_string(intGain, 7) + "'\n";

    _pg_report += _pg_prename + ":derGain" + " '" +  to_formatted_string(derGain, 7) + "'\n";

    _pg_report += _pg_prename + ":derivativeTime" + " '" +  to_formatted_string(derivativeTime, 7) + "'\n";

    _pg_report += _pg_prename + ":outputfilterlpf" + " '" +  to_formatted_string(outputfilterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":outputsoftband" + " '" +  to_formatted_string(outputsoftband, 7) + "'\n";

    return _pg_report;

}// efiRPMController_t::textPrint

/*!
 * Read the contents of a efiRPMController_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiRPMController_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":minRPM", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        minRPM = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":maxRPM", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        maxRPM = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":enableRPMfromThrottleCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableRPMfromThrottleCmd = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableLowRPMLimiter", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableLowRPMLimiter = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableHighRPMLimiter", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enableHighRPMLimiter = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":updateRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        updateRate = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":throttleAtMinRPM", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        throttleAtMinRPM = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":rpmToThrottlePower", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        rpmToThrottlePower = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":rpmCmdfilterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        rpmCmdfilterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":maxRateCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        maxRateCmd = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":trajGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        trajGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":gainScaler", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        gainScaler = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":forGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        forGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":proGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        proGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":intGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        intGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":derGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        derGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":derivativeTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        derivativeTime = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":outputfilterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        outputfilterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":outputsoftband", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        outputsoftband = std::stof(_pg_text);

    return _pg_fieldcount;

}// efiRPMController_t::textRead

/*!
 * Generate a string that describes the contents of a efiMaintenanceItemConfig_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiMaintenanceItemConfig_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":trigger" + " '" + std::to_string(trigger) + "'\n";

    _pg_report += _pg_prename + ":interval" + " '" + std::to_string(interval) + "'\n";

    _pg_report += _pg_prename + ":description '" + std::string(description) + "'\n";

    return _pg_report;

}// efiMaintenanceItemConfig_t::textPrint

/*!
 * Read the contents of a efiMaintenanceItemConfig_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiMaintenanceItemConfig_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":trigger", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        trigger = (MaintenanceTriggers)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":interval", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        interval = (uint32_t)(std::stoul(_pg_text));

    pgstrncpy(description, extractText(_pg_prename + ":description", _pg_source, &_pg_fieldcount).c_str(), 64);

    return _pg_fieldcount;

}// efiMaintenanceItemConfig_t::textRead

/*!
 * Generate a string that describes the contents of a MaintenanceConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiMaintenanceConfiguration_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiMaintenanceConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "MaintenanceConfiguration";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiMaintenanceConfiguration_t::textPrint

/*!
 * Generate a string that describes the contents of a efiMaintenanceConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiMaintenanceConfiguration_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    _pg_report += _pg_prename + ":numItems" + " '" + std::to_string(numItems) + "'\n";

    _pg_report += _pg_prename + ":hotTimeGain" + " '" +  to_formatted_string(hotTimeGain, 7) + "'\n";

    _pg_report += _pg_prename + ":highLoadThreshold" + " '" +  to_formatted_string(highLoadThreshold, 7) + "'\n";

    // List of maintenance item
    for(_pg_i = 0; _pg_i < (unsigned)numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_report += MaintenanceItemConfig[_pg_i].textPrint(_pg_prename + ":MaintenanceItemConfig" + "[" + std::to_string(_pg_i) + "]");

    return _pg_report;

}// efiMaintenanceConfiguration_t::textPrint

/*!
 * Read the contents of a efiMaintenanceConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiMaintenanceConfiguration_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;

    _pg_text = extractText(_pg_prename + ":numItems", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        numItems = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":hotTimeGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        hotTimeGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":highLoadThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        highLoadThreshold = std::stof(_pg_text);

    // List of maintenance item
    for(_pg_i = 0; _pg_i < (unsigned)numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_fieldcount += MaintenanceItemConfig[_pg_i].textRead(_pg_prename + ":MaintenanceItemConfig" + "[" + std::to_string(_pg_i) + "]", _pg_source);

    return _pg_fieldcount;

}// efiMaintenanceConfiguration_t::textRead

/*!
 * Generate a string that describes the contents of a Table2D_1x packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiTable2D_1x_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiTable2D_1x_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "Table2D_1x";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiTable2D_1x_t::textPrint

/*!
 * Generate a string that describes the contents of a efiTable2D_1x_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiTable2D_1x_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    _pg_report += _pg_prename + ":enabled" + " '" + std::to_string(enabled) + "'\n";

    _pg_report += _pg_prename + ":loadfrommap" + " '" + std::to_string(loadfrommap) + "'\n";

    _pg_report += _pg_prename + ":index" + " '" + std::to_string(index) + "'\n";

    _pg_report += _pg_prename + ":numrows" + " '" + std::to_string(numrows) + "'\n";

    _pg_report += _pg_prename + ":numcols" + " '" + std::to_string(numcols) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        _pg_report += _pg_prename + ":rowindices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(rowindices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        _pg_report += _pg_prename + ":colindices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(colindices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            _pg_report += _pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" +  to_formatted_string(data[_pg_i][_pg_j], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            _pg_report += _pg_prename + ":meta" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + std::to_string(meta[_pg_i][_pg_j]) + "'\n";

    return _pg_report;

}// efiTable2D_1x_t::textPrint

/*!
 * Read the contents of a efiTable2D_1x_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiTable2D_1x_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    _pg_text = extractText(_pg_prename + ":enabled", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enabled = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":loadfrommap", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        loadfrommap = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":index", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        index = (efiOldTableList)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":numrows", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        numrows = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":numcols", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        numcols = (uint8_t)(std::stoul(_pg_text));

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":rowindices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            rowindices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":colindices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            colindices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
        {
            _pg_text = extractText(_pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]", _pg_source, &_pg_fieldcount);
            if(!_pg_text.empty())
                data[_pg_i][_pg_j] = std::stof(_pg_text);
        }

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
        {
            _pg_text = extractText(_pg_prename + ":meta" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]", _pg_source, &_pg_fieldcount);
            if(!_pg_text.empty())
                meta[_pg_i][_pg_j] = (uint8_t)(std::stoul(_pg_text));
        }

    return _pg_fieldcount;

}// efiTable2D_1x_t::textRead

/*!
 * Generate a string that describes the contents of a Table2D packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string efiTable2D_t::textPrint(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiTable2D_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "Table2D";

    // Decode packet
    if(!_pg_user.decode(_pg_pkt))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += _pg_user.textPrint(_pg_prename);

    return _pg_report;

}// efiTable2D_t::textPrint

/*!
 * Generate a string that describes the contents of a efiTable2D_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \return a string containing a report of the contents of user
 */
std::string efiTable2D_t::textPrint(const std::string& _pg_prename) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    _pg_report += _pg_prename + ":enabled" + " '" + std::to_string(enabled) + "'\n";

    _pg_report += _pg_prename + ":index" + " '" + std::to_string(index) + "'\n";

    _pg_report += _pg_prename + ":addone" + " '" + std::to_string(addone) + "'\n";

    _pg_report += _pg_prename + ":rowindex" + " '" + std::to_string(rowindex) + "'\n";

    _pg_report += _pg_prename + ":colindex" + " '" + std::to_string(colindex) + "'\n";

    _pg_report += _pg_prename + ":multiplierindex" + " '" + std::to_string(multiplierindex) + "'\n";

    _pg_report += _pg_prename + ":dividerindex" + " '" + std::to_string(dividerindex) + "'\n";

    _pg_report += _pg_prename + ":description '" + std::string(description) + "'\n";

    _pg_report += _pg_prename + ":numrows" + " '" + std::to_string(numrows) + "'\n";

    _pg_report += _pg_prename + ":numcols" + " '" + std::to_string(numcols) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        _pg_report += _pg_prename + ":rowindices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(rowindices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        _pg_report += _pg_prename + ":colindices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(colindices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            _pg_report += _pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" +  to_formatted_string(data[_pg_i][_pg_j], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            _pg_report += _pg_prename + ":meta" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + std::to_string(meta[_pg_i][_pg_j]) + "'\n";

    return _pg_report;

}// efiTable2D_t::textPrint

/*!
 * Read the contents of a efiTable2D_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \return The number of fields that were read from the text source
 */
int efiTable2D_t::textRead(const std::string& _pg_prename, const std::string& _pg_source)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    _pg_text = extractText(_pg_prename + ":enabled", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        enabled = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":index", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        index = (efiTableList)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":addone", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        addone = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":rowindex", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        rowindex = (efiTableIndex)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":colindex", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        colindex = (efiTableIndex)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":multiplierindex", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        multiplierindex = (efiTableIndex)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":dividerindex", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        dividerindex = (efiTableIndex)(std::stoul(_pg_text));

    pgstrncpy(description, extractText(_pg_prename + ":description", _pg_source, &_pg_fieldcount).c_str(), 28);

    _pg_text = extractText(_pg_prename + ":numrows", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        numrows = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":numcols", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        numcols = (uint8_t)(std::stoul(_pg_text));

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":rowindices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            rowindices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":colindices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            colindices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
        {
            _pg_text = extractText(_pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]", _pg_source, &_pg_fieldcount);
            if(!_pg_text.empty())
                data[_pg_i][_pg_j] = std::stof(_pg_text);
        }

    for(_pg_i = 0; _pg_i < (unsigned)numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
        {
            _pg_text = extractText(_pg_prename + ":meta" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]", _pg_source, &_pg_fieldcount);
            if(!_pg_text.empty())
                meta[_pg_i][_pg_j] = (uint8_t)(std::stoul(_pg_text));
        }

    return _pg_fieldcount;

}// efiTable2D_t::textRead

// end of efiprintutil.cpp
