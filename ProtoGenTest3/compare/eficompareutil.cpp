// eficompareutil.cpp was generated by ProtoGen version 3.1.d

#include "eficompareutil.hpp"
#include <sstream>
#include <iomanip>
#include <cstring>

//! Create a numeric string with a specific number of decimal places
static std::string to_formatted_string(double number, int precision);

/*!
 * Create a numeric string with a specific number of decimal places
 * \param number is the number to convert to string
 * \param precision is the number of decimal places to output
 * \return the number as a string
 */
std::string to_formatted_string(double number, int precision)
{
    // This function exists becuase of a bug in GCC which prevents this from working correctly:
    // string = (std::stringstream() << std::setprecision(7) << _pg_user1->indices[_pg_i]).str()

    std::stringstream stream;
    stream << std::setprecision(precision);
    stream << number;
    return stream.str();

}// to_formatted_string

/*!
 * Compare this efiDate_t with another efiDate_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiDate_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiDate_t::compare(const std::string& _pg_prename, const efiDate_t* _pg_user) const
{
    std::string _pg_report;

    if(day != _pg_user->day)
        _pg_report += _pg_prename + ":day"  + " '" + std::to_string(day) + "' '" + std::to_string(_pg_user->day) + "'\n";

    if(month != _pg_user->month)
        _pg_report += _pg_prename + ":month"  + " '" + std::to_string(month) + "' '" + std::to_string(_pg_user->month) + "'\n";

    if(year != _pg_user->year)
        _pg_report += _pg_prename + ":year"  + " '" + std::to_string(year) + "' '" + std::to_string(_pg_user->year) + "'\n";

    return _pg_report;

}// efiDate_t::compare

/*!
 * Compare this efiDateTime_t with another efiDateTime_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiDateTime_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiDateTime_t::compare(const std::string& _pg_prename, const efiDateTime_t* _pg_user) const
{
    std::string _pg_report;

    if(jiffytime != _pg_user->jiffytime)
        _pg_report += _pg_prename + ":jiffytime"  + " '" + std::to_string(jiffytime) + "' '" + std::to_string(_pg_user->jiffytime) + "'\n";

    if(day != _pg_user->day)
        _pg_report += _pg_prename + ":day"  + " '" + std::to_string(day) + "' '" + std::to_string(_pg_user->day) + "'\n";

    if(month != _pg_user->month)
        _pg_report += _pg_prename + ":month"  + " '" + std::to_string(month) + "' '" + std::to_string(_pg_user->month) + "'\n";

    if(year != _pg_user->year)
        _pg_report += _pg_prename + ":year"  + " '" + std::to_string(year) + "' '" + std::to_string(_pg_user->year) + "'\n";

    return _pg_report;

}// efiDateTime_t::compare

/*!
 * Compare this efiCrankSense_t with another efiCrankSense_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiCrankSense_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiCrankSense_t::compare(const std::string& _pg_prename, const efiCrankSense_t* _pg_user) const
{
    std::string _pg_report;

    if(enableWheel != _pg_user->enableWheel)
        _pg_report += _pg_prename + ":enableWheel"  + " '" + std::to_string(enableWheel) + "' '" + std::to_string(_pg_user->enableWheel) + "'\n";

    if(activeHigh != _pg_user->activeHigh)
        _pg_report += _pg_prename + ":activeHigh"  + " '" + std::to_string(activeHigh) + "' '" + std::to_string(_pg_user->activeHigh) + "'\n";

    if(disableSensor != _pg_user->disableSensor)
        _pg_report += _pg_prename + ":disableSensor"  + " '" + std::to_string(disableSensor) + "' '" + std::to_string(_pg_user->disableSensor) + "'\n";

    if(preferThisSensor != _pg_user->preferThisSensor)
        _pg_report += _pg_prename + ":preferThisSensor"  + " '" + std::to_string(preferThisSensor) + "' '" + std::to_string(_pg_user->preferThisSensor) + "'\n";

    if(senseDelay != _pg_user->senseDelay)
        _pg_report += _pg_prename + ":senseDelay"  + " '" + std::to_string(senseDelay) + "' '" + std::to_string(_pg_user->senseDelay) + "'\n";

    if(normalOffset != _pg_user->normalOffset)
        _pg_report += _pg_prename + ":normalOffset"  + " '" + to_formatted_string(normalOffset, 7) + "' '" + to_formatted_string(_pg_user->normalOffset, 7) + "'\n";

    if(reverseOffset != _pg_user->reverseOffset)
        _pg_report += _pg_prename + ":reverseOffset"  + " '" + to_formatted_string(reverseOffset, 7) + "' '" + to_formatted_string(_pg_user->reverseOffset, 7) + "'\n";

    if(totalCount != _pg_user->totalCount)
        _pg_report += _pg_prename + ":totalCount"  + " '" + std::to_string(totalCount) + "' '" + std::to_string(_pg_user->totalCount) + "'\n";

    if(bigGapCount != _pg_user->bigGapCount)
        _pg_report += _pg_prename + ":bigGapCount"  + " '" + std::to_string(bigGapCount) + "' '" + std::to_string(_pg_user->bigGapCount) + "'\n";

    if(smallGapCount != _pg_user->smallGapCount)
        _pg_report += _pg_prename + ":smallGapCount"  + " '" + std::to_string(smallGapCount) + "' '" + std::to_string(_pg_user->smallGapCount) + "'\n";

    if(normalIntraGapCount != _pg_user->normalIntraGapCount)
        _pg_report += _pg_prename + ":normalIntraGapCount"  + " '" + std::to_string(normalIntraGapCount) + "' '" + std::to_string(_pg_user->normalIntraGapCount) + "'\n";

    if(reverseIntraGapCount != _pg_user->reverseIntraGapCount)
        _pg_report += _pg_prename + ":reverseIntraGapCount"  + " '" + std::to_string(reverseIntraGapCount) + "' '" + std::to_string(_pg_user->reverseIntraGapCount) + "'\n";

    return _pg_report;

}// efiCrankSense_t::compare

/*!
 * Compare this efiTable1D_t with another efiTable1D_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiTable1D_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiTable1D_t::compare(const std::string& _pg_prename, const efiTable1D_t* _pg_user) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    if(enabled != _pg_user->enabled)
        _pg_report += _pg_prename + ":enabled"  + " '" + std::to_string(enabled) + "' '" + std::to_string(_pg_user->enabled) + "'\n";

    if(num != _pg_user->num)
        _pg_report += _pg_prename + ":num"  + " '" + std::to_string(num) + "' '" + std::to_string(_pg_user->num) + "'\n";

    if(num == _pg_user->num)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_COLS) && (_pg_i < (unsigned)num); _pg_i++)
        {
            if(indices[_pg_i] != _pg_user->indices[_pg_i])
                _pg_report += _pg_prename + ":indices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(indices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user->indices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":indices array dimension differs, array not compared\n";

    if(num == _pg_user->num)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_COLS) && (_pg_i < (unsigned)num); _pg_i++)
        {
            if(data[_pg_i] != _pg_user->data[_pg_i])
                _pg_report += _pg_prename + ":data"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(data[_pg_i], 7) + "' '" + to_formatted_string(_pg_user->data[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":data array dimension differs, array not compared\n";

    return _pg_report;

}// efiTable1D_t::compare

/*!
 * Compare two EngineWear packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiEngineWear_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiEngineWear_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "EngineWear";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiEngineWear_t::compare

/*!
 * Compare this efiEngineWear_t with another efiEngineWear_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiEngineWear_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiEngineWear_t::compare(const std::string& _pg_prename, const efiEngineWear_t* _pg_user) const
{
    std::string _pg_report;

    if(hobbs != _pg_user->hobbs)
        _pg_report += _pg_prename + ":hobbs"  + " '" + std::to_string(hobbs) + "' '" + std::to_string(_pg_user->hobbs) + "'\n";

    if(revcount != _pg_user->revcount)
        _pg_report += _pg_prename + ":revcount"  + " '" + std::to_string(revcount) + "' '" + std::to_string(_pg_user->revcount) + "'\n";

    if(hotTime != _pg_user->hotTime)
        _pg_report += _pg_prename + ":hotTime"  + " '" + std::to_string(hotTime) + "' '" + std::to_string(_pg_user->hotTime) + "'\n";

    if(highLoadTime != _pg_user->highLoadTime)
        _pg_report += _pg_prename + ":highLoadTime"  + " '" + std::to_string(highLoadTime) + "' '" + std::to_string(_pg_user->highLoadTime) + "'\n";

    if(peakCHT != _pg_user->peakCHT)
        _pg_report += _pg_prename + ":peakCHT"  + " '" + to_formatted_string(peakCHT, 7) + "' '" + to_formatted_string(_pg_user->peakCHT, 7) + "'\n";

    if(numStarts != _pg_user->numStarts)
        _pg_report += _pg_prename + ":numStarts"  + " '" + std::to_string(numStarts) + "' '" + std::to_string(_pg_user->numStarts) + "'\n";

    return _pg_report;

}// efiEngineWear_t::compare

/*!
 * Compare this efiMaintenanceItemStatus_t with another efiMaintenanceItemStatus_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiMaintenanceItemStatus_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiMaintenanceItemStatus_t::compare(const std::string& _pg_prename, const efiMaintenanceItemStatus_t* _pg_user) const
{
    std::string _pg_report;

    if(triggered != _pg_user->triggered)
        _pg_report += _pg_prename + ":triggered"  + " '" + std::to_string(triggered) + "' '" + std::to_string(_pg_user->triggered) + "'\n";

    if(index != _pg_user->index)
        _pg_report += _pg_prename + ":index"  + " '" + std::to_string(index) + "' '" + std::to_string(_pg_user->index) + "'\n";

    _pg_report += servicetime.compare(_pg_prename + ":servicetime", &_pg_user->servicetime);

    if(lastdone != _pg_user->lastdone)
        _pg_report += _pg_prename + ":lastdone"  + " '" + std::to_string(lastdone) + "' '" + std::to_string(_pg_user->lastdone) + "'\n";

    if(std::string(name).compare(_pg_user->name) != 0)
        _pg_report += _pg_prename + ":name strings differ\n";

    return _pg_report;

}// efiMaintenanceItemStatus_t::compare

/*!
 * Compare two MaintenanceStatus packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiMaintenanceStatus_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiMaintenanceStatus_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "MaintenanceStatus";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiMaintenanceStatus_t::compare

/*!
 * Compare this efiMaintenanceStatus_t with another efiMaintenanceStatus_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiMaintenanceStatus_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiMaintenanceStatus_t::compare(const std::string& _pg_prename, const efiMaintenanceStatus_t* _pg_user) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    if(domaintenance != _pg_user->domaintenance)
        _pg_report += _pg_prename + ":domaintenance"  + " '" + std::to_string(domaintenance) + "' '" + std::to_string(_pg_user->domaintenance) + "'\n";

    if(setEngineSerial != _pg_user->setEngineSerial)
        _pg_report += _pg_prename + ":setEngineSerial"  + " '" + std::to_string(setEngineSerial) + "' '" + std::to_string(_pg_user->setEngineSerial) + "'\n";

    if(numItems != _pg_user->numItems)
        _pg_report += _pg_prename + ":numItems"  + " '" + std::to_string(numItems) + "' '" + std::to_string(_pg_user->numItems) + "'\n";

    if(engineSerial != _pg_user->engineSerial)
        _pg_report += _pg_prename + ":engineSerial"  + " '" + std::to_string(engineSerial) + "' '" + std::to_string(_pg_user->engineSerial) + "'\n";

    // List of maintenance item status
    for(_pg_i = 0; _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_report += MaintenanceItemStatus[_pg_i].compare(_pg_prename + ":MaintenanceItemStatus" + "[" + std::to_string(_pg_i) + "]", &_pg_user->MaintenanceItemStatus[_pg_i]);

    return _pg_report;

}// efiMaintenanceStatus_t::compare

/*!
 * Compare two LogEntry packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiLogEntry_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiLogEntry_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "LogEntry";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiLogEntry_t::compare

/*!
 * Compare this efiLogEntry_t with another efiLogEntry_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiLogEntry_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiLogEntry_t::compare(const std::string& _pg_prename, const efiLogEntry_t* _pg_user) const
{
    std::string _pg_report;

    if(cmd != _pg_user->cmd)
        _pg_report += _pg_prename + ":cmd"  + " '" + std::to_string(cmd) + "' '" + std::to_string(_pg_user->cmd) + "'\n";

    if(index != _pg_user->index)
        _pg_report += _pg_prename + ":index"  + " '" + std::to_string(index) + "' '" + std::to_string(_pg_user->index) + "'\n";

    _pg_report += time.compare(_pg_prename + ":time", &_pg_user->time);

    if(std::string(name).compare(_pg_user->name) != 0)
        _pg_report += _pg_prename + ":name strings differ\n";

    if(std::string(description).compare(_pg_user->description) != 0)
        _pg_report += _pg_prename + ":description strings differ\n";

    return _pg_report;

}// efiLogEntry_t::compare

/*!
 * Compare two File packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiFile_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiFile_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "File";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiFile_t::compare

/*!
 * Compare this efiFile_t with another efiFile_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiFile_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiFile_t::compare(const std::string& _pg_prename, const efiFile_t* _pg_user) const
{
    std::string _pg_report;

    _pg_report += date.compare(_pg_prename + ":date", &_pg_user->date);

    if(std::string(filename).compare(_pg_user->filename) != 0)
        _pg_report += _pg_prename + ":filename strings differ\n";

    return _pg_report;

}// efiFile_t::compare

/*!
 * Compare two Comment packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiComment_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiComment_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "Comment";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiComment_t::compare

/*!
 * Compare this efiComment_t with another efiComment_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiComment_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiComment_t::compare(const std::string& _pg_prename, const efiComment_t* _pg_user) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        if(userdata[_pg_i] != _pg_user->userdata[_pg_i])
            _pg_report += _pg_prename + ":userdata"  + "[" + std::to_string(_pg_i) + "]" + " '" + std::to_string(userdata[_pg_i]) + "' '" + std::to_string(_pg_user->userdata[_pg_i]) + "'\n";

    if(std::string(comment).compare(_pg_user->comment) != 0)
        _pg_report += _pg_prename + ":comment strings differ\n";

    return _pg_report;

}// efiComment_t::compare

/*!
 * Compare two LockControl packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiLockControl_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiLockControl_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "LockControl";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiLockControl_t::compare

/*!
 * Compare this efiLockControl_t with another efiLockControl_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiLockControl_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiLockControl_t::compare(const std::string& _pg_prename, const efiLockControl_t* _pg_user) const
{
    std::string _pg_report;

    if(tablesProtection != _pg_user->tablesProtection)
        _pg_report += _pg_prename + ":tablesProtection"  + " '" + std::to_string(tablesProtection) + "' '" + std::to_string(_pg_user->tablesProtection) + "'\n";

    if(governorProtection != _pg_user->governorProtection)
        _pg_report += _pg_prename + ":governorProtection"  + " '" + std::to_string(governorProtection) + "' '" + std::to_string(_pg_user->governorProtection) + "'\n";

    if(throttleProtection != _pg_user->throttleProtection)
        _pg_report += _pg_prename + ":throttleProtection"  + " '" + std::to_string(throttleProtection) + "' '" + std::to_string(_pg_user->throttleProtection) + "'\n";

    if(engineProtection != _pg_user->engineProtection)
        _pg_report += _pg_prename + ":engineProtection"  + " '" + std::to_string(engineProtection) + "' '" + std::to_string(_pg_user->engineProtection) + "'\n";

    if(injectorProtection != _pg_user->injectorProtection)
        _pg_report += _pg_prename + ":injectorProtection"  + " '" + std::to_string(injectorProtection) + "' '" + std::to_string(_pg_user->injectorProtection) + "'\n";

    if(pumpProtection != _pg_user->pumpProtection)
        _pg_report += _pg_prename + ":pumpProtection"  + " '" + std::to_string(pumpProtection) + "' '" + std::to_string(_pg_user->pumpProtection) + "'\n";

    if(sensorsProtection != _pg_user->sensorsProtection)
        _pg_report += _pg_prename + ":sensorsProtection"  + " '" + std::to_string(sensorsProtection) + "' '" + std::to_string(_pg_user->sensorsProtection) + "'\n";

    if(commsProtection != _pg_user->commsProtection)
        _pg_report += _pg_prename + ":commsProtection"  + " '" + std::to_string(commsProtection) + "' '" + std::to_string(_pg_user->commsProtection) + "'\n";

    if(maintenanceProtection != _pg_user->maintenanceProtection)
        _pg_report += _pg_prename + ":maintenanceProtection"  + " '" + std::to_string(maintenanceProtection) + "' '" + std::to_string(_pg_user->maintenanceProtection) + "'\n";

    if(coolingProtection != _pg_user->coolingProtection)
        _pg_report += _pg_prename + ":coolingProtection"  + " '" + std::to_string(coolingProtection) + "' '" + std::to_string(_pg_user->coolingProtection) + "'\n";

    if(std::string(password).compare(_pg_user->password) != 0)
        _pg_report += _pg_prename + ":password strings differ\n";

    return _pg_report;

}// efiLockControl_t::compare

/*!
 * Compare two ConfigHash packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiConfigHash_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiConfigHash_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "ConfigHash";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiConfigHash_t::compare

/*!
 * Compare this efiConfigHash_t with another efiConfigHash_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiConfigHash_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiConfigHash_t::compare(const std::string& _pg_prename, const efiConfigHash_t* _pg_user) const
{
    std::string _pg_report;

    if(storedParameterHash != _pg_user->storedParameterHash)
        _pg_report += _pg_prename + ":storedParameterHash"  + " '" + std::to_string(storedParameterHash) + "' '" + std::to_string(_pg_user->storedParameterHash) + "'\n";

    if(actualParameterHash != _pg_user->actualParameterHash)
        _pg_report += _pg_prename + ":actualParameterHash"  + " '" + std::to_string(actualParameterHash) + "' '" + std::to_string(_pg_user->actualParameterHash) + "'\n";

    return _pg_report;

}// efiConfigHash_t::compare

/*!
 * Compare two PumpConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiPumpConfiguration_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiPumpConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "PumpConfiguration";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiPumpConfiguration_t::compare

/*!
 * Compare this efiPumpConfiguration_t with another efiPumpConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiPumpConfiguration_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiPumpConfiguration_t::compare(const std::string& _pg_prename, const efiPumpConfiguration_t* _pg_user) const
{
    std::string _pg_report;

    if(fuelPressureCmd != _pg_user->fuelPressureCmd)
        _pg_report += _pg_prename + ":fuelPressureCmd"  + " '" + to_formatted_string(fuelPressureCmd, 7) + "' '" + to_formatted_string(_pg_user->fuelPressureCmd, 7) + "'\n";

    if(fuelPressureErrorThreshold != _pg_user->fuelPressureErrorThreshold)
        _pg_report += _pg_prename + ":fuelPressureErrorThreshold"  + " '" + to_formatted_string(fuelPressureErrorThreshold, 7) + "' '" + to_formatted_string(_pg_user->fuelPressureErrorThreshold, 7) + "'\n";

    if(minDutyCycle != _pg_user->minDutyCycle)
        _pg_report += _pg_prename + ":minDutyCycle"  + " '" + to_formatted_string(minDutyCycle, 7) + "' '" + to_formatted_string(_pg_user->minDutyCycle, 7) + "'\n";

    if(maxDutyCycle != _pg_user->maxDutyCycle)
        _pg_report += _pg_prename + ":maxDutyCycle"  + " '" + to_formatted_string(maxDutyCycle, 7) + "' '" + to_formatted_string(_pg_user->maxDutyCycle, 7) + "'\n";

    if(fuelPressureBangBangThreshold != _pg_user->fuelPressureBangBangThreshold)
        _pg_report += _pg_prename + ":fuelPressureBangBangThreshold"  + " '" + to_formatted_string(fuelPressureBangBangThreshold, 7) + "' '" + to_formatted_string(_pg_user->fuelPressureBangBangThreshold, 7) + "'\n";

    if(proGain != _pg_user->proGain)
        _pg_report += _pg_prename + ":proGain"  + " '" + to_formatted_string(proGain, 7) + "' '" + to_formatted_string(_pg_user->proGain, 7) + "'\n";

    if(intGain != _pg_user->intGain)
        _pg_report += _pg_prename + ":intGain"  + " '" + to_formatted_string(intGain, 7) + "' '" + to_formatted_string(_pg_user->intGain, 7) + "'\n";

    if(forGain != _pg_user->forGain)
        _pg_report += _pg_prename + ":forGain"  + " '" + to_formatted_string(forGain, 7) + "' '" + to_formatted_string(_pg_user->forGain, 7) + "'\n";

    if(rpmEnablesPump != _pg_user->rpmEnablesPump)
        _pg_report += _pg_prename + ":rpmEnablesPump"  + " '" + std::to_string(rpmEnablesPump) + "' '" + std::to_string(_pg_user->rpmEnablesPump) + "'\n";

    if(primeTime != _pg_user->primeTime)
        _pg_report += _pg_prename + ":primeTime"  + " '" + std::to_string(primeTime) + "' '" + std::to_string(_pg_user->primeTime) + "'\n";

    if(maxIfFailure != _pg_user->maxIfFailure)
        _pg_report += _pg_prename + ":maxIfFailure"  + " '" + std::to_string(maxIfFailure) + "' '" + std::to_string(_pg_user->maxIfFailure) + "'\n";

    if(positiveRateLimit != _pg_user->positiveRateLimit)
        _pg_report += _pg_prename + ":positiveRateLimit"  + " '" + to_formatted_string(positiveRateLimit, 7) + "' '" + to_formatted_string(_pg_user->positiveRateLimit, 7) + "'\n";

    if(negativeRateLimit != _pg_user->negativeRateLimit)
        _pg_report += _pg_prename + ":negativeRateLimit"  + " '" + to_formatted_string(negativeRateLimit, 7) + "' '" + to_formatted_string(_pg_user->negativeRateLimit, 7) + "'\n";

    if(_outputRateLimit != _pg_user->_outputRateLimit)
        _pg_report += _pg_prename + ":_outputRateLimit"  + " '" + to_formatted_string(_outputRateLimit, 7) + "' '" + to_formatted_string(_pg_user->_outputRateLimit, 7) + "'\n";

    if(pwmPeriod != _pg_user->pwmPeriod)
        _pg_report += _pg_prename + ":pwmPeriod"  + " '" + std::to_string(pwmPeriod) + "' '" + std::to_string(_pg_user->pwmPeriod) + "'\n";

    return _pg_report;

}// efiPumpConfiguration_t::compare

/*!
 * Compare this efiCANconfig_t with another efiCANconfig_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiCANconfig_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiCANconfig_t::compare(const std::string& _pg_prename, const efiCANconfig_t* _pg_user) const
{
    std::string _pg_report;

    if(baud != _pg_user->baud)
        _pg_report += _pg_prename + ":baud"  + " '" + std::to_string(baud) + "' '" + std::to_string(_pg_user->baud) + "'\n";

    if(typeShift != _pg_user->typeShift)
        _pg_report += _pg_prename + ":typeShift"  + " '" + std::to_string(typeShift) + "' '" + std::to_string(_pg_user->typeShift) + "'\n";

    if(longid != _pg_user->longid)
        _pg_report += _pg_prename + ":longid"  + " '" + std::to_string(longid) + "' '" + std::to_string(_pg_user->longid) + "'\n";

    if(disableNativeInput != _pg_user->disableNativeInput)
        _pg_report += _pg_prename + ":disableNativeInput"  + " '" + std::to_string(disableNativeInput) + "' '" + std::to_string(_pg_user->disableNativeInput) + "'\n";

    if(inputBaseId != _pg_user->inputBaseId)
        _pg_report += _pg_prename + ":inputBaseId"  + " '" + std::to_string(inputBaseId) + "' '" + std::to_string(_pg_user->inputBaseId) + "'\n";

    if(disableNativeOutput != _pg_user->disableNativeOutput)
        _pg_report += _pg_prename + ":disableNativeOutput"  + " '" + std::to_string(disableNativeOutput) + "' '" + std::to_string(_pg_user->disableNativeOutput) + "'\n";

    if(outputBaseId != _pg_user->outputBaseId)
        _pg_report += _pg_prename + ":outputBaseId"  + " '" + std::to_string(outputBaseId) + "' '" + std::to_string(_pg_user->outputBaseId) + "'\n";

    if(disableNativeBroadcast != _pg_user->disableNativeBroadcast)
        _pg_report += _pg_prename + ":disableNativeBroadcast"  + " '" + std::to_string(disableNativeBroadcast) + "' '" + std::to_string(_pg_user->disableNativeBroadcast) + "'\n";

    if(broadcastBaseId != _pg_user->broadcastBaseId)
        _pg_report += _pg_prename + ":broadcastBaseId"  + " '" + std::to_string(broadcastBaseId) + "' '" + std::to_string(_pg_user->broadcastBaseId) + "'\n";

    if(forcePacketOverCAN != _pg_user->forcePacketOverCAN)
        _pg_report += _pg_prename + ":forcePacketOverCAN"  + " '" + std::to_string(forcePacketOverCAN) + "' '" + std::to_string(_pg_user->forcePacketOverCAN) + "'\n";

    if(cmdAndTmOnly != _pg_user->cmdAndTmOnly)
        _pg_report += _pg_prename + ":cmdAndTmOnly"  + " '" + std::to_string(cmdAndTmOnly) + "' '" + std::to_string(_pg_user->cmdAndTmOnly) + "'\n";

    if(enableGCU != _pg_user->enableGCU)
        _pg_report += _pg_prename + ":enableGCU"  + " '" + std::to_string(enableGCU) + "' '" + std::to_string(_pg_user->enableGCU) + "'\n";

    if(enablePE3ECU != _pg_user->enablePE3ECU)
        _pg_report += _pg_prename + ":enablePE3ECU"  + " '" + std::to_string(enablePE3ECU) + "' '" + std::to_string(_pg_user->enablePE3ECU) + "'\n";

    if(enableCurrawongECU != _pg_user->enableCurrawongECU)
        _pg_report += _pg_prename + ":enableCurrawongECU"  + " '" + std::to_string(enableCurrawongECU) + "' '" + std::to_string(_pg_user->enableCurrawongECU) + "'\n";

    if(enablePiccoloECU != _pg_user->enablePiccoloECU)
        _pg_report += _pg_prename + ":enablePiccoloECU"  + " '" + std::to_string(enablePiccoloECU) + "' '" + std::to_string(_pg_user->enablePiccoloECU) + "'\n";

    if(alternativeProtocolAddress != _pg_user->alternativeProtocolAddress)
        _pg_report += _pg_prename + ":alternativeProtocolAddress"  + " '" + std::to_string(alternativeProtocolAddress) + "' '" + std::to_string(_pg_user->alternativeProtocolAddress) + "'\n";

    return _pg_report;

}// efiCANconfig_t::compare

/*!
 * Compare two CommConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiCommConfiguration_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiCommConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "CommConfiguration";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiCommConfiguration_t::compare

/*!
 * Compare this efiCommConfiguration_t with another efiCommConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiCommConfiguration_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiCommConfiguration_t::compare(const std::string& _pg_prename, const efiCommConfiguration_t* _pg_user) const
{
    std::string _pg_report;

    if(disableSDRecording != _pg_user->disableSDRecording)
        _pg_report += _pg_prename + ":disableSDRecording"  + " '" + std::to_string(disableSDRecording) + "' '" + std::to_string(_pg_user->disableSDRecording) + "'\n";

    if(fastTelemetrySDRate != _pg_user->fastTelemetrySDRate)
        _pg_report += _pg_prename + ":fastTelemetrySDRate"  + " '" + std::to_string(fastTelemetrySDRate) + "' '" + std::to_string(_pg_user->fastTelemetrySDRate) + "'\n";

    if(fastTelemetryRate != _pg_user->fastTelemetryRate)
        _pg_report += _pg_prename + ":fastTelemetryRate"  + " '" + std::to_string(fastTelemetryRate) + "' '" + std::to_string(_pg_user->fastTelemetryRate) + "'\n";

    if(recordSDAlways != _pg_user->recordSDAlways)
        _pg_report += _pg_prename + ":recordSDAlways"  + " '" + std::to_string(recordSDAlways) + "' '" + std::to_string(_pg_user->recordSDAlways) + "'\n";

    if(slowTelemetrySDRate != _pg_user->slowTelemetrySDRate)
        _pg_report += _pg_prename + ":slowTelemetrySDRate"  + " '" + std::to_string(slowTelemetrySDRate) + "' '" + std::to_string(_pg_user->slowTelemetrySDRate) + "'\n";

    if(slowTelemetryRate != _pg_user->slowTelemetryRate)
        _pg_report += _pg_prename + ":slowTelemetryRate"  + " '" + std::to_string(slowTelemetryRate) + "' '" + std::to_string(_pg_user->slowTelemetryRate) + "'\n";

    if(useSummaryPackets != _pg_user->useSummaryPackets)
        _pg_report += _pg_prename + ":useSummaryPackets"  + " '" + std::to_string(useSummaryPackets) + "' '" + std::to_string(_pg_user->useSummaryPackets) + "'\n";

    if(setToDefault != _pg_user->setToDefault)
        _pg_report += _pg_prename + ":setToDefault"  + " '" + std::to_string(setToDefault) + "' '" + std::to_string(_pg_user->setToDefault) + "'\n";

    if(enableCurrawongECU != _pg_user->enableCurrawongECU)
        _pg_report += _pg_prename + ":enableCurrawongECU"  + " '" + std::to_string(enableCurrawongECU) + "' '" + std::to_string(_pg_user->enableCurrawongECU) + "'\n";

    if(uartBaud != _pg_user->uartBaud)
        _pg_report += _pg_prename + ":uartBaud"  + " '" + std::to_string(uartBaud) + "' '" + std::to_string(_pg_user->uartBaud) + "'\n";

    // Configuration data for CAN communciations
    _pg_report += CANconfig.compare(_pg_prename + ":CANconfig", &_pg_user->CANconfig);

    return _pg_report;

}// efiCommConfiguration_t::compare

/*!
 * Compare two SensorConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiSensorConfiguration_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiSensorConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "SensorConfiguration";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiSensorConfiguration_t::compare

/*!
 * Compare this efiSensorConfiguration_t with another efiSensorConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiSensorConfiguration_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiSensorConfiguration_t::compare(const std::string& _pg_prename, const efiSensorConfiguration_t* _pg_user) const
{
    std::string _pg_report;

    if(enabled != _pg_user->enabled)
        _pg_report += _pg_prename + ":enabled"  + " '" + std::to_string(enabled) + "' '" + std::to_string(_pg_user->enabled) + "'\n";

    if(kty84 != _pg_user->kty84)
        _pg_report += _pg_prename + ":kty84"  + " '" + std::to_string(kty84) + "' '" + std::to_string(_pg_user->kty84) + "'\n";

    if(sealedGauge != _pg_user->sealedGauge)
        _pg_report += _pg_prename + ":sealedGauge"  + " '" + std::to_string(sealedGauge) + "' '" + std::to_string(_pg_user->sealedGauge) + "'\n";

    if(sensor != _pg_user->sensor)
        _pg_report += _pg_prename + ":sensor"  + " '" + std::to_string(sensor) + "' '" + std::to_string(_pg_user->sensor) + "'\n";

    if(filterlpf != _pg_user->filterlpf)
        _pg_report += _pg_prename + ":filterlpf"  + " '" + to_formatted_string(filterlpf, 7) + "' '" + to_formatted_string(_pg_user->filterlpf, 7) + "'\n";

    if(offset != _pg_user->offset)
        _pg_report += _pg_prename + ":offset"  + " '" + to_formatted_string(offset, 7) + "' '" + to_formatted_string(_pg_user->offset, 7) + "'\n";

    if(gain != _pg_user->gain)
        _pg_report += _pg_prename + ":gain"  + " '" + to_formatted_string(gain, 7) + "' '" + to_formatted_string(_pg_user->gain, 7) + "'\n";

    if(failedvalue != _pg_user->failedvalue)
        _pg_report += _pg_prename + ":failedvalue"  + " '" + to_formatted_string(failedvalue, 7) + "' '" + to_formatted_string(_pg_user->failedvalue, 7) + "'\n";

    if(min != _pg_user->min)
        _pg_report += _pg_prename + ":min"  + " '" + to_formatted_string(min, 7) + "' '" + to_formatted_string(_pg_user->min, 7) + "'\n";

    if(max != _pg_user->max)
        _pg_report += _pg_prename + ":max"  + " '" + to_formatted_string(max, 7) + "' '" + to_formatted_string(_pg_user->max, 7) + "'\n";

    if(kty83 != _pg_user->kty83)
        _pg_report += _pg_prename + ":kty83"  + " '" + std::to_string(kty83) + "' '" + std::to_string(_pg_user->kty83) + "'\n";

    if(setToDefault != _pg_user->setToDefault)
        _pg_report += _pg_prename + ":setToDefault"  + " '" + std::to_string(setToDefault) + "' '" + std::to_string(_pg_user->setToDefault) + "'\n";

    if(calibrate != _pg_user->calibrate)
        _pg_report += _pg_prename + ":calibrate"  + " '" + std::to_string(calibrate) + "' '" + std::to_string(_pg_user->calibrate) + "'\n";

    if(calibrateoffset != _pg_user->calibrateoffset)
        _pg_report += _pg_prename + ":calibrateoffset"  + " '" + std::to_string(calibrateoffset) + "' '" + std::to_string(_pg_user->calibrateoffset) + "'\n";

    if(calibrategain != _pg_user->calibrategain)
        _pg_report += _pg_prename + ":calibrategain"  + " '" + std::to_string(calibrategain) + "' '" + std::to_string(_pg_user->calibrategain) + "'\n";

    if(enableAutocorrect != _pg_user->enableAutocorrect)
        _pg_report += _pg_prename + ":enableAutocorrect"  + " '" + std::to_string(enableAutocorrect) + "' '" + std::to_string(_pg_user->enableAutocorrect) + "'\n";

    if(platinum1000rtd != _pg_user->platinum1000rtd)
        _pg_report += _pg_prename + ":platinum1000rtd"  + " '" + std::to_string(platinum1000rtd) + "' '" + std::to_string(_pg_user->platinum1000rtd) + "'\n";

    if(calibrationvalue != _pg_user->calibrationvalue)
        _pg_report += _pg_prename + ":calibrationvalue"  + " '" + to_formatted_string(calibrationvalue, 7) + "' '" + to_formatted_string(_pg_user->calibrationvalue, 7) + "'\n";

    return _pg_report;

}// efiSensorConfiguration_t::compare

/*!
 * Compare two ThrottleConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiThrottleConfiguration_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiThrottleConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "ThrottleConfiguration";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiThrottleConfiguration_t::compare

/*!
 * Compare this efiThrottleConfiguration_t with another efiThrottleConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiThrottleConfiguration_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiThrottleConfiguration_t::compare(const std::string& _pg_prename, const efiThrottleConfiguration_t* _pg_user) const
{
    std::string _pg_report;

    if(closedPWMoutput != _pg_user->closedPWMoutput)
        _pg_report += _pg_prename + ":closedPWMoutput"  + " '" + std::to_string(closedPWMoutput) + "' '" + std::to_string(_pg_user->closedPWMoutput) + "'\n";

    if(openPWMoutput != _pg_user->openPWMoutput)
        _pg_report += _pg_prename + ":openPWMoutput"  + " '" + std::to_string(openPWMoutput) + "' '" + std::to_string(_pg_user->openPWMoutput) + "'\n";

    if(inputfilterlpf != _pg_user->inputfilterlpf)
        _pg_report += _pg_prename + ":inputfilterlpf"  + " '" + to_formatted_string(inputfilterlpf, 7) + "' '" + to_formatted_string(_pg_user->inputfilterlpf, 7) + "'\n";

    if(outputRateLimit != _pg_user->outputRateLimit)
        _pg_report += _pg_prename + ":outputRateLimit"  + " '" + to_formatted_string(outputRateLimit, 7) + "' '" + to_formatted_string(_pg_user->outputRateLimit, 7) + "'\n";

    if(enableAnalogCmd != _pg_user->enableAnalogCmd)
        _pg_report += _pg_prename + ":enableAnalogCmd"  + " '" + std::to_string(enableAnalogCmd) + "' '" + std::to_string(_pg_user->enableAnalogCmd) + "'\n";

    if(enablePWMCmd != _pg_user->enablePWMCmd)
        _pg_report += _pg_prename + ":enablePWMCmd"  + " '" + std::to_string(enablePWMCmd) + "' '" + std::to_string(_pg_user->enablePWMCmd) + "'\n";

    if(efiDrivesThrottle != _pg_user->efiDrivesThrottle)
        _pg_report += _pg_prename + ":efiDrivesThrottle"  + " '" + std::to_string(efiDrivesThrottle) + "' '" + std::to_string(_pg_user->efiDrivesThrottle) + "'\n";

    if(enableAnalogTPS != _pg_user->enableAnalogTPS)
        _pg_report += _pg_prename + ":enableAnalogTPS"  + " '" + std::to_string(enableAnalogTPS) + "' '" + std::to_string(_pg_user->enableAnalogTPS) + "'\n";

    if(enablePWMTPS != _pg_user->enablePWMTPS)
        _pg_report += _pg_prename + ":enablePWMTPS"  + " '" + std::to_string(enablePWMTPS) + "' '" + std::to_string(_pg_user->enablePWMTPS) + "'\n";

    if(_enableCECANServo != _pg_user->_enableCECANServo)
        _pg_report += _pg_prename + ":_enableCECANServo"  + " '" + std::to_string(_enableCECANServo) + "' '" + std::to_string(_pg_user->_enableCECANServo) + "'\n";

    if(enableCECANTPS != _pg_user->enableCECANTPS)
        _pg_report += _pg_prename + ":enableCECANTPS"  + " '" + std::to_string(enableCECANTPS) + "' '" + std::to_string(_pg_user->enableCECANTPS) + "'\n";

    if(enableMAPTPS != _pg_user->enableMAPTPS)
        _pg_report += _pg_prename + ":enableMAPTPS"  + " '" + std::to_string(enableMAPTPS) + "' '" + std::to_string(_pg_user->enableMAPTPS) + "'\n";

    _pg_report += curve.compare(_pg_prename + ":curve", &_pg_user->curve);

    if(startThrottle != _pg_user->startThrottle)
        _pg_report += _pg_prename + ":startThrottle"  + " '" + to_formatted_string(startThrottle, 7) + "' '" + to_formatted_string(_pg_user->startThrottle, 7) + "'\n";

    if(cecanAddress != _pg_user->cecanAddress)
        _pg_report += _pg_prename + ":cecanAddress"  + " '" + std::to_string(cecanAddress) + "' '" + std::to_string(_pg_user->cecanAddress) + "'\n";

    if(tpsErrorThreshold != _pg_user->tpsErrorThreshold)
        _pg_report += _pg_prename + ":tpsErrorThreshold"  + " '" + to_formatted_string(tpsErrorThreshold, 7) + "' '" + to_formatted_string(_pg_user->tpsErrorThreshold, 7) + "'\n";

    if(maxStartThrottle != _pg_user->maxStartThrottle)
        _pg_report += _pg_prename + ":maxStartThrottle"  + " '" + to_formatted_string(maxStartThrottle, 7) + "' '" + to_formatted_string(_pg_user->maxStartThrottle, 7) + "'\n";

    if(closedPWMinput != _pg_user->closedPWMinput)
        _pg_report += _pg_prename + ":closedPWMinput"  + " '" + std::to_string(closedPWMinput) + "' '" + std::to_string(_pg_user->closedPWMinput) + "'\n";

    if(openPWMinput != _pg_user->openPWMinput)
        _pg_report += _pg_prename + ":openPWMinput"  + " '" + std::to_string(openPWMinput) + "' '" + std::to_string(_pg_user->openPWMinput) + "'\n";

    if(tpsFeedbackIntGain != _pg_user->tpsFeedbackIntGain)
        _pg_report += _pg_prename + ":tpsFeedbackIntGain"  + " '" + to_formatted_string(tpsFeedbackIntGain, 7) + "' '" + to_formatted_string(_pg_user->tpsFeedbackIntGain, 7) + "'\n";

    return _pg_report;

}// efiThrottleConfiguration_t::compare

/*!
 * Compare two CoolingConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiCoolingConfiguration_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiCoolingConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "CoolingConfiguration";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiCoolingConfiguration_t::compare

/*!
 * Compare this efiCoolingConfiguration_t with another efiCoolingConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiCoolingConfiguration_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiCoolingConfiguration_t::compare(const std::string& _pg_prename, const efiCoolingConfiguration_t* _pg_user) const
{
    std::string _pg_report;

    if(chtTooCold != _pg_user->chtTooCold)
        _pg_report += _pg_prename + ":chtTooCold"  + " '" + to_formatted_string(chtTooCold, 7) + "' '" + to_formatted_string(_pg_user->chtTooCold, 7) + "'\n";

    if(chtTooHot != _pg_user->chtTooHot)
        _pg_report += _pg_prename + ":chtTooHot"  + " '" + to_formatted_string(chtTooHot, 7) + "' '" + to_formatted_string(_pg_user->chtTooHot, 7) + "'\n";

    if(chtDesired != _pg_user->chtDesired)
        _pg_report += _pg_prename + ":chtDesired"  + " '" + to_formatted_string(chtDesired, 7) + "' '" + to_formatted_string(_pg_user->chtDesired, 7) + "'\n";

    if(derTime != _pg_user->derTime)
        _pg_report += _pg_prename + ":derTime"  + " '" + to_formatted_string(derTime, 7) + "' '" + to_formatted_string(_pg_user->derTime, 7) + "'\n";

    if(trajGain != _pg_user->trajGain)
        _pg_report += _pg_prename + ":trajGain"  + " '" + to_formatted_string(trajGain, 7) + "' '" + to_formatted_string(_pg_user->trajGain, 7) + "'\n";

    if(forGain != _pg_user->forGain)
        _pg_report += _pg_prename + ":forGain"  + " '" + to_formatted_string(forGain, 7) + "' '" + to_formatted_string(_pg_user->forGain, 7) + "'\n";

    if(proGain != _pg_user->proGain)
        _pg_report += _pg_prename + ":proGain"  + " '" + to_formatted_string(proGain, 7) + "' '" + to_formatted_string(_pg_user->proGain, 7) + "'\n";

    if(intGain != _pg_user->intGain)
        _pg_report += _pg_prename + ":intGain"  + " '" + to_formatted_string(intGain, 7) + "' '" + to_formatted_string(_pg_user->intGain, 7) + "'\n";

    if(derGain != _pg_user->derGain)
        _pg_report += _pg_prename + ":derGain"  + " '" + to_formatted_string(derGain, 7) + "' '" + to_formatted_string(_pg_user->derGain, 7) + "'\n";

    if(enableSplitCooling != _pg_user->enableSplitCooling)
        _pg_report += _pg_prename + ":enableSplitCooling"  + " '" + std::to_string(enableSplitCooling) + "' '" + std::to_string(_pg_user->enableSplitCooling) + "'\n";

    if(closedPWM1 != _pg_user->closedPWM1)
        _pg_report += _pg_prename + ":closedPWM1"  + " '" + std::to_string(closedPWM1) + "' '" + std::to_string(_pg_user->closedPWM1) + "'\n";

    if(openPWM1 != _pg_user->openPWM1)
        _pg_report += _pg_prename + ":openPWM1"  + " '" + std::to_string(openPWM1) + "' '" + std::to_string(_pg_user->openPWM1) + "'\n";

    if(closedPWM2 != _pg_user->closedPWM2)
        _pg_report += _pg_prename + ":closedPWM2"  + " '" + std::to_string(closedPWM2) + "' '" + std::to_string(_pg_user->closedPWM2) + "'\n";

    if(openPWM2 != _pg_user->openPWM2)
        _pg_report += _pg_prename + ":openPWM2"  + " '" + std::to_string(openPWM2) + "' '" + std::to_string(_pg_user->openPWM2) + "'\n";

    if(cecanAddress1 != _pg_user->cecanAddress1)
        _pg_report += _pg_prename + ":cecanAddress1"  + " '" + std::to_string(cecanAddress1) + "' '" + std::to_string(_pg_user->cecanAddress1) + "'\n";

    if(cecanAddress2 != _pg_user->cecanAddress2)
        _pg_report += _pg_prename + ":cecanAddress2"  + " '" + std::to_string(cecanAddress2) + "' '" + std::to_string(_pg_user->cecanAddress2) + "'\n";

    return _pg_report;

}// efiCoolingConfiguration_t::compare

/*!
 * Compare two EngineConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiEngineConfiguration_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiEngineConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "EngineConfiguration";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiEngineConfiguration_t::compare

/*!
 * Compare this efiEngineConfiguration_t with another efiEngineConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiEngineConfiguration_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiEngineConfiguration_t::compare(const std::string& _pg_prename, const efiEngineConfiguration_t* _pg_user) const
{
    std::string _pg_report;

    if(displacement != _pg_user->displacement)
        _pg_report += _pg_prename + ":displacement"  + " '" + to_formatted_string(displacement, 7) + "' '" + to_formatted_string(_pg_user->displacement, 7) + "'\n";

    if(ignoreInputEnable != _pg_user->ignoreInputEnable)
        _pg_report += _pg_prename + ":ignoreInputEnable"  + " '" + std::to_string(ignoreInputEnable) + "' '" + std::to_string(_pg_user->ignoreInputEnable) + "'\n";

    if(preventNormalRotation != _pg_user->preventNormalRotation)
        _pg_report += _pg_prename + ":preventNormalRotation"  + " '" + std::to_string(preventNormalRotation) + "' '" + std::to_string(_pg_user->preventNormalRotation) + "'\n";

    if(preventReverseRotation != _pg_user->preventReverseRotation)
        _pg_report += _pg_prename + ":preventReverseRotation"  + " '" + std::to_string(preventReverseRotation) + "' '" + std::to_string(_pg_user->preventReverseRotation) + "'\n";

    if(_enableCrank2 != _pg_user->_enableCrank2)
        _pg_report += _pg_prename + ":_enableCrank2"  + " '" + std::to_string(_enableCrank2) + "' '" + std::to_string(_pg_user->_enableCrank2) + "'\n";

    if(enableSpark3 != _pg_user->enableSpark3)
        _pg_report += _pg_prename + ":enableSpark3"  + " '" + std::to_string(enableSpark3) + "' '" + std::to_string(_pg_user->enableSpark3) + "'\n";

    if(ignActiveHigh != _pg_user->ignActiveHigh)
        _pg_report += _pg_prename + ":ignActiveHigh"  + " '" + std::to_string(ignActiveHigh) + "' '" + std::to_string(_pg_user->ignActiveHigh) + "'\n";

    if(api8 != _pg_user->api8)
        _pg_report += _pg_prename + ":api8"  + " '" + std::to_string(api8) + "' '" + std::to_string(_pg_user->api8) + "'\n";

    if(maxIgnDwellTime != _pg_user->maxIgnDwellTime)
        _pg_report += _pg_prename + ":maxIgnDwellTime"  + " '" + std::to_string(maxIgnDwellTime) + "' '" + std::to_string(_pg_user->maxIgnDwellTime) + "'\n";

    if(minIgnActiveTime != _pg_user->minIgnActiveTime)
        _pg_report += _pg_prename + ":minIgnActiveTime"  + " '" + std::to_string(minIgnActiveTime) + "' '" + std::to_string(_pg_user->minIgnActiveTime) + "'\n";

    if(hardRevLimit != _pg_user->hardRevLimit)
        _pg_report += _pg_prename + ":hardRevLimit"  + " '" + to_formatted_string(hardRevLimit, 7) + "' '" + to_formatted_string(_pg_user->hardRevLimit, 7) + "'\n";

    if(softRevLimit != _pg_user->softRevLimit)
        _pg_report += _pg_prename + ":softRevLimit"  + " '" + to_formatted_string(softRevLimit, 7) + "' '" + to_formatted_string(_pg_user->softRevLimit, 7) + "'\n";

    if(rpmfilterlpf != _pg_user->rpmfilterlpf)
        _pg_report += _pg_prename + ":rpmfilterlpf"  + " '" + to_formatted_string(rpmfilterlpf, 7) + "' '" + to_formatted_string(_pg_user->rpmfilterlpf, 7) + "'\n";

    if(mapErrorThreshold != _pg_user->mapErrorThreshold)
        _pg_report += _pg_prename + ":mapErrorThreshold"  + " '" + to_formatted_string(mapErrorThreshold, 7) + "' '" + to_formatted_string(_pg_user->mapErrorThreshold, 7) + "'\n";

    _pg_report += crankSense1.compare(_pg_prename + ":crankSense1", &_pg_user->crankSense1);

    _pg_report += crankSense2.compare(_pg_prename + ":crankSense2", &_pg_user->crankSense2);

    if(chtReference != _pg_user->chtReference)
        _pg_report += _pg_prename + ":chtReference"  + " '" + to_formatted_string(chtReference, 7) + "' '" + to_formatted_string(_pg_user->chtReference, 7) + "'\n";

    return _pg_report;

}// efiEngineConfiguration_t::compare

/*!
 * Compare two InjectorConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiInjectorConfiguration_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiInjectorConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "InjectorConfiguration";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiInjectorConfiguration_t::compare

/*!
 * Compare this efiInjectorConfiguration_t with another efiInjectorConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiInjectorConfiguration_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiInjectorConfiguration_t::compare(const std::string& _pg_prename, const efiInjectorConfiguration_t* _pg_user) const
{
    std::string _pg_report;

    if(enableInjector2 != _pg_user->enableInjector2)
        _pg_report += _pg_prename + ":enableInjector2"  + " '" + std::to_string(enableInjector2) + "' '" + std::to_string(_pg_user->enableInjector2) + "'\n";

    if(enableInjectorIndependence != _pg_user->enableInjectorIndependence)
        _pg_report += _pg_prename + ":enableInjectorIndependence"  + " '" + std::to_string(enableInjectorIndependence) + "' '" + std::to_string(_pg_user->enableInjectorIndependence) + "'\n";

    if(spareTempIsCHT != _pg_user->spareTempIsCHT)
        _pg_report += _pg_prename + ":spareTempIsCHT"  + " '" + std::to_string(spareTempIsCHT) + "' '" + std::to_string(_pg_user->spareTempIsCHT) + "'\n";

    if(spareTempIsMAT != _pg_user->spareTempIsMAT)
        _pg_report += _pg_prename + ":spareTempIsMAT"  + " '" + std::to_string(spareTempIsMAT) + "' '" + std::to_string(_pg_user->spareTempIsMAT) + "'\n";

    if(enableInjector3 != _pg_user->enableInjector3)
        _pg_report += _pg_prename + ":enableInjector3"  + " '" + std::to_string(enableInjector3) + "' '" + std::to_string(_pg_user->enableInjector3) + "'\n";

    if(injectorsAreRedundant != _pg_user->injectorsAreRedundant)
        _pg_report += _pg_prename + ":injectorsAreRedundant"  + " '" + std::to_string(injectorsAreRedundant) + "' '" + std::to_string(_pg_user->injectorsAreRedundant) + "'\n";

    if(phaseEdge != _pg_user->phaseEdge)
        _pg_report += _pg_prename + ":phaseEdge"  + " '" + std::to_string(phaseEdge) + "' '" + std::to_string(_pg_user->phaseEdge) + "'\n";

    if(fuelVolumePercentPerMAT != _pg_user->fuelVolumePercentPerMAT)
        _pg_report += _pg_prename + ":fuelVolumePercentPerMAT"  + " '" + to_formatted_string(fuelVolumePercentPerMAT, 7) + "' '" + to_formatted_string(_pg_user->fuelVolumePercentPerMAT, 7) + "'\n";

    if(multiplier != _pg_user->multiplier)
        _pg_report += _pg_prename + ":multiplier"  + " '" + to_formatted_string(multiplier, 7) + "' '" + to_formatted_string(_pg_user->multiplier, 7) + "'\n";

    if(nominalFuelPressure != _pg_user->nominalFuelPressure)
        _pg_report += _pg_prename + ":nominalFuelPressure"  + " '" + to_formatted_string(nominalFuelPressure, 7) + "' '" + to_formatted_string(_pg_user->nominalFuelPressure, 7) + "'\n";

    if(nominalFlowrate1 != _pg_user->nominalFlowrate1)
        _pg_report += _pg_prename + ":nominalFlowrate1"  + " '" + to_formatted_string(nominalFlowrate1, 7) + "' '" + to_formatted_string(_pg_user->nominalFlowrate1, 7) + "'\n";

    if(nominalFlowrate2 != _pg_user->nominalFlowrate2)
        _pg_report += _pg_prename + ":nominalFlowrate2"  + " '" + to_formatted_string(nominalFlowrate2, 7) + "' '" + to_formatted_string(_pg_user->nominalFlowrate2, 7) + "'\n";

    if(minOpeningTime1 != _pg_user->minOpeningTime1)
        _pg_report += _pg_prename + ":minOpeningTime1"  + " '" + std::to_string(minOpeningTime1) + "' '" + std::to_string(_pg_user->minOpeningTime1) + "'\n";

    if(minOpeningTime2 != _pg_user->minOpeningTime2)
        _pg_report += _pg_prename + ":minOpeningTime2"  + " '" + std::to_string(minOpeningTime2) + "' '" + std::to_string(_pg_user->minOpeningTime2) + "'\n";

    if(fuelUsedCorrector != _pg_user->fuelUsedCorrector)
        _pg_report += _pg_prename + ":fuelUsedCorrector"  + " '" + to_formatted_string(fuelUsedCorrector, 7) + "' '" + to_formatted_string(_pg_user->fuelUsedCorrector, 7) + "'\n";

    if(nominalFlowrate3 != _pg_user->nominalFlowrate3)
        _pg_report += _pg_prename + ":nominalFlowrate3"  + " '" + to_formatted_string(nominalFlowrate3, 7) + "' '" + to_formatted_string(_pg_user->nominalFlowrate3, 7) + "'\n";

    if(minOpeningTime3 != _pg_user->minOpeningTime3)
        _pg_report += _pg_prename + ":minOpeningTime3"  + " '" + std::to_string(minOpeningTime3) + "' '" + std::to_string(_pg_user->minOpeningTime3) + "'\n";

    if(oilPrimingFreq != _pg_user->oilPrimingFreq)
        _pg_report += _pg_prename + ":oilPrimingFreq"  + " '" + to_formatted_string(oilPrimingFreq, 7) + "' '" + to_formatted_string(_pg_user->oilPrimingFreq, 7) + "'\n";

    if(spareTempIsOilT != _pg_user->spareTempIsOilT)
        _pg_report += _pg_prename + ":spareTempIsOilT"  + " '" + std::to_string(spareTempIsOilT) + "' '" + std::to_string(_pg_user->spareTempIsOilT) + "'\n";

    if(injector2IsOilInj != _pg_user->injector2IsOilInj)
        _pg_report += _pg_prename + ":injector2IsOilInj"  + " '" + std::to_string(injector2IsOilInj) + "' '" + std::to_string(_pg_user->injector2IsOilInj) + "'\n";

    if(injector3IsOilInj != _pg_user->injector3IsOilInj)
        _pg_report += _pg_prename + ":injector3IsOilInj"  + " '" + std::to_string(injector3IsOilInj) + "' '" + std::to_string(_pg_user->injector3IsOilInj) + "'\n";

    if(oilForStarting != _pg_user->oilForStarting)
        _pg_report += _pg_prename + ":oilForStarting"  + " '" + to_formatted_string(oilForStarting, 7) + "' '" + to_formatted_string(_pg_user->oilForStarting, 7) + "'\n";

    if(oilUsedCorrector != _pg_user->oilUsedCorrector)
        _pg_report += _pg_prename + ":oilUsedCorrector"  + " '" + to_formatted_string(oilUsedCorrector, 7) + "' '" + to_formatted_string(_pg_user->oilUsedCorrector, 7) + "'\n";

    return _pg_report;

}// efiInjectorConfiguration_t::compare

/*!
 * Compare two RPMController packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiRPMController_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiRPMController_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "RPMController";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiRPMController_t::compare

/*!
 * Compare this efiRPMController_t with another efiRPMController_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiRPMController_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiRPMController_t::compare(const std::string& _pg_prename, const efiRPMController_t* _pg_user) const
{
    std::string _pg_report;

    if(minRPM != _pg_user->minRPM)
        _pg_report += _pg_prename + ":minRPM"  + " '" + to_formatted_string(minRPM, 7) + "' '" + to_formatted_string(_pg_user->minRPM, 7) + "'\n";

    if(maxRPM != _pg_user->maxRPM)
        _pg_report += _pg_prename + ":maxRPM"  + " '" + to_formatted_string(maxRPM, 7) + "' '" + to_formatted_string(_pg_user->maxRPM, 7) + "'\n";

    if(enableRPMfromThrottleCmd != _pg_user->enableRPMfromThrottleCmd)
        _pg_report += _pg_prename + ":enableRPMfromThrottleCmd"  + " '" + std::to_string(enableRPMfromThrottleCmd) + "' '" + std::to_string(_pg_user->enableRPMfromThrottleCmd) + "'\n";

    if(enableLowRPMLimiter != _pg_user->enableLowRPMLimiter)
        _pg_report += _pg_prename + ":enableLowRPMLimiter"  + " '" + std::to_string(enableLowRPMLimiter) + "' '" + std::to_string(_pg_user->enableLowRPMLimiter) + "'\n";

    if(enableHighRPMLimiter != _pg_user->enableHighRPMLimiter)
        _pg_report += _pg_prename + ":enableHighRPMLimiter"  + " '" + std::to_string(enableHighRPMLimiter) + "' '" + std::to_string(_pg_user->enableHighRPMLimiter) + "'\n";

    if(updateRate != _pg_user->updateRate)
        _pg_report += _pg_prename + ":updateRate"  + " '" + to_formatted_string(updateRate, 7) + "' '" + to_formatted_string(_pg_user->updateRate, 7) + "'\n";

    if(throttleAtMinRPM != _pg_user->throttleAtMinRPM)
        _pg_report += _pg_prename + ":throttleAtMinRPM"  + " '" + to_formatted_string(throttleAtMinRPM, 7) + "' '" + to_formatted_string(_pg_user->throttleAtMinRPM, 7) + "'\n";

    if(rpmToThrottlePower != _pg_user->rpmToThrottlePower)
        _pg_report += _pg_prename + ":rpmToThrottlePower"  + " '" + to_formatted_string(rpmToThrottlePower, 7) + "' '" + to_formatted_string(_pg_user->rpmToThrottlePower, 7) + "'\n";

    if(rpmCmdfilterlpf != _pg_user->rpmCmdfilterlpf)
        _pg_report += _pg_prename + ":rpmCmdfilterlpf"  + " '" + to_formatted_string(rpmCmdfilterlpf, 7) + "' '" + to_formatted_string(_pg_user->rpmCmdfilterlpf, 7) + "'\n";

    if(maxRateCmd != _pg_user->maxRateCmd)
        _pg_report += _pg_prename + ":maxRateCmd"  + " '" + to_formatted_string(maxRateCmd, 7) + "' '" + to_formatted_string(_pg_user->maxRateCmd, 7) + "'\n";

    if(trajGain != _pg_user->trajGain)
        _pg_report += _pg_prename + ":trajGain"  + " '" + to_formatted_string(trajGain, 7) + "' '" + to_formatted_string(_pg_user->trajGain, 7) + "'\n";

    if(gainScaler != _pg_user->gainScaler)
        _pg_report += _pg_prename + ":gainScaler"  + " '" + to_formatted_string(gainScaler, 7) + "' '" + to_formatted_string(_pg_user->gainScaler, 7) + "'\n";

    if(forGain != _pg_user->forGain)
        _pg_report += _pg_prename + ":forGain"  + " '" + to_formatted_string(forGain, 7) + "' '" + to_formatted_string(_pg_user->forGain, 7) + "'\n";

    if(proGain != _pg_user->proGain)
        _pg_report += _pg_prename + ":proGain"  + " '" + to_formatted_string(proGain, 7) + "' '" + to_formatted_string(_pg_user->proGain, 7) + "'\n";

    if(intGain != _pg_user->intGain)
        _pg_report += _pg_prename + ":intGain"  + " '" + to_formatted_string(intGain, 7) + "' '" + to_formatted_string(_pg_user->intGain, 7) + "'\n";

    if(derGain != _pg_user->derGain)
        _pg_report += _pg_prename + ":derGain"  + " '" + to_formatted_string(derGain, 7) + "' '" + to_formatted_string(_pg_user->derGain, 7) + "'\n";

    if(derivativeTime != _pg_user->derivativeTime)
        _pg_report += _pg_prename + ":derivativeTime"  + " '" + to_formatted_string(derivativeTime, 7) + "' '" + to_formatted_string(_pg_user->derivativeTime, 7) + "'\n";

    if(outputfilterlpf != _pg_user->outputfilterlpf)
        _pg_report += _pg_prename + ":outputfilterlpf"  + " '" + to_formatted_string(outputfilterlpf, 7) + "' '" + to_formatted_string(_pg_user->outputfilterlpf, 7) + "'\n";

    if(outputsoftband != _pg_user->outputsoftband)
        _pg_report += _pg_prename + ":outputsoftband"  + " '" + to_formatted_string(outputsoftband, 7) + "' '" + to_formatted_string(_pg_user->outputsoftband, 7) + "'\n";

    return _pg_report;

}// efiRPMController_t::compare

/*!
 * Compare this efiMaintenanceItemConfig_t with another efiMaintenanceItemConfig_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiMaintenanceItemConfig_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiMaintenanceItemConfig_t::compare(const std::string& _pg_prename, const efiMaintenanceItemConfig_t* _pg_user) const
{
    std::string _pg_report;

    if(trigger != _pg_user->trigger)
        _pg_report += _pg_prename + ":trigger"  + " '" + std::to_string(trigger) + "' '" + std::to_string(_pg_user->trigger) + "'\n";

    if(interval != _pg_user->interval)
        _pg_report += _pg_prename + ":interval"  + " '" + std::to_string(interval) + "' '" + std::to_string(_pg_user->interval) + "'\n";

    if(std::string(description).compare(_pg_user->description) != 0)
        _pg_report += _pg_prename + ":description strings differ\n";

    return _pg_report;

}// efiMaintenanceItemConfig_t::compare

/*!
 * Compare two MaintenanceConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiMaintenanceConfiguration_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiMaintenanceConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "MaintenanceConfiguration";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiMaintenanceConfiguration_t::compare

/*!
 * Compare this efiMaintenanceConfiguration_t with another efiMaintenanceConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiMaintenanceConfiguration_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiMaintenanceConfiguration_t::compare(const std::string& _pg_prename, const efiMaintenanceConfiguration_t* _pg_user) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    if(numItems != _pg_user->numItems)
        _pg_report += _pg_prename + ":numItems"  + " '" + std::to_string(numItems) + "' '" + std::to_string(_pg_user->numItems) + "'\n";

    if(hotTimeGain != _pg_user->hotTimeGain)
        _pg_report += _pg_prename + ":hotTimeGain"  + " '" + to_formatted_string(hotTimeGain, 7) + "' '" + to_formatted_string(_pg_user->hotTimeGain, 7) + "'\n";

    if(highLoadThreshold != _pg_user->highLoadThreshold)
        _pg_report += _pg_prename + ":highLoadThreshold"  + " '" + to_formatted_string(highLoadThreshold, 7) + "' '" + to_formatted_string(_pg_user->highLoadThreshold, 7) + "'\n";

    // List of maintenance item
    for(_pg_i = 0; _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_report += MaintenanceItemConfig[_pg_i].compare(_pg_prename + ":MaintenanceItemConfig" + "[" + std::to_string(_pg_i) + "]", &_pg_user->MaintenanceItemConfig[_pg_i]);

    return _pg_report;

}// efiMaintenanceConfiguration_t::compare

/*!
 * Compare two Table2D_1x packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiTable2D_1x_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiTable2D_1x_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "Table2D_1x";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiTable2D_1x_t::compare

/*!
 * Compare this efiTable2D_1x_t with another efiTable2D_1x_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiTable2D_1x_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiTable2D_1x_t::compare(const std::string& _pg_prename, const efiTable2D_1x_t* _pg_user) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    if(enabled != _pg_user->enabled)
        _pg_report += _pg_prename + ":enabled"  + " '" + std::to_string(enabled) + "' '" + std::to_string(_pg_user->enabled) + "'\n";

    if(loadfrommap != _pg_user->loadfrommap)
        _pg_report += _pg_prename + ":loadfrommap"  + " '" + std::to_string(loadfrommap) + "' '" + std::to_string(_pg_user->loadfrommap) + "'\n";

    if(index != _pg_user->index)
        _pg_report += _pg_prename + ":index"  + " '" + std::to_string(index) + "' '" + std::to_string(_pg_user->index) + "'\n";

    if(numrows != _pg_user->numrows)
        _pg_report += _pg_prename + ":numrows"  + " '" + std::to_string(numrows) + "' '" + std::to_string(_pg_user->numrows) + "'\n";

    if(numcols != _pg_user->numcols)
        _pg_report += _pg_prename + ":numcols"  + " '" + std::to_string(numcols) + "' '" + std::to_string(_pg_user->numcols) + "'\n";

    if(numrows == _pg_user->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)numrows); _pg_i++)
        {
            if(rowindices[_pg_i] != _pg_user->rowindices[_pg_i])
                _pg_report += _pg_prename + ":rowindices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(rowindices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user->rowindices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":rowindices array dimension differs, array not compared\n";

    if(numcols == _pg_user->numcols)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_COLS) && (_pg_i < (unsigned)numcols); _pg_i++)
        {
            if(colindices[_pg_i] != _pg_user->colindices[_pg_i])
                _pg_report += _pg_prename + ":colindices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(colindices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user->colindices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":colindices array dimension differs, array not compared\n";

    if(numrows == _pg_user->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)numrows); _pg_i++)
        {
            if(numcols == _pg_user->numcols)
            {
                for(_pg_j = 0; (_pg_j < EFI_TABLE_MAX_COLS) && (_pg_j < (unsigned)numcols); _pg_j++)
                {
                    if(data[_pg_i][_pg_j] != _pg_user->data[_pg_i][_pg_j])
                        _pg_report += _pg_prename + ":data"  + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + to_formatted_string(data[_pg_i][_pg_j], 7) + "' '" + to_formatted_string(_pg_user->data[_pg_i][_pg_j], 7) + "'\n";
                }
            }
            else
                _pg_report += _pg_prename + ":data 2nd array dimension differs, array not compared\n";
        }
    }
    else
        _pg_report += _pg_prename + ":data array dimension differs, array not compared\n";

    if(numrows == _pg_user->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)numrows); _pg_i++)
        {
            if(numcols == _pg_user->numcols)
            {
                for(_pg_j = 0; (_pg_j < EFI_TABLE_MAX_COLS) && (_pg_j < (unsigned)numcols); _pg_j++)
                {
                    if(meta[_pg_i][_pg_j] != _pg_user->meta[_pg_i][_pg_j])
                        _pg_report += _pg_prename + ":meta"  + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + std::to_string(meta[_pg_i][_pg_j]) + "' '" + std::to_string(_pg_user->meta[_pg_i][_pg_j]) + "'\n";
                }
            }
            else
                _pg_report += _pg_prename + ":meta 2nd array dimension differs, array not compared\n";
        }
    }
    else
        _pg_report += _pg_prename + ":meta array dimension differs, array not compared\n";

    return _pg_report;

}// efiTable2D_1x_t::compare

/*!
 * Compare two Table2D packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string efiTable2D_t::compare(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiTable2D_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "Table2D";

    // Decode each packet
    if(!_pg_struct1.decode(_pg_pkt1) || !_pg_struct2.decode(_pg_pkt2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += _pg_struct1.compare(_pg_prename, &_pg_struct2);

    return _pg_report;

}// efiTable2D_t::compare

/*!
 * Compare this efiTable2D_t with another efiTable2D_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user is the data to compare
 * \return a string describing any differences between this efiTable2D_t and `_pg_user`. The string will be empty if there are no differences
 */
std::string efiTable2D_t::compare(const std::string& _pg_prename, const efiTable2D_t* _pg_user) const
{
    std::string _pg_report;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    if(enabled != _pg_user->enabled)
        _pg_report += _pg_prename + ":enabled"  + " '" + std::to_string(enabled) + "' '" + std::to_string(_pg_user->enabled) + "'\n";

    if(index != _pg_user->index)
        _pg_report += _pg_prename + ":index"  + " '" + std::to_string(index) + "' '" + std::to_string(_pg_user->index) + "'\n";

    if(addone != _pg_user->addone)
        _pg_report += _pg_prename + ":addone"  + " '" + std::to_string(addone) + "' '" + std::to_string(_pg_user->addone) + "'\n";

    if(rowindex != _pg_user->rowindex)
        _pg_report += _pg_prename + ":rowindex"  + " '" + std::to_string(rowindex) + "' '" + std::to_string(_pg_user->rowindex) + "'\n";

    if(colindex != _pg_user->colindex)
        _pg_report += _pg_prename + ":colindex"  + " '" + std::to_string(colindex) + "' '" + std::to_string(_pg_user->colindex) + "'\n";

    if(multiplierindex != _pg_user->multiplierindex)
        _pg_report += _pg_prename + ":multiplierindex"  + " '" + std::to_string(multiplierindex) + "' '" + std::to_string(_pg_user->multiplierindex) + "'\n";

    if(dividerindex != _pg_user->dividerindex)
        _pg_report += _pg_prename + ":dividerindex"  + " '" + std::to_string(dividerindex) + "' '" + std::to_string(_pg_user->dividerindex) + "'\n";

    if(std::string(description).compare(_pg_user->description) != 0)
        _pg_report += _pg_prename + ":description strings differ\n";

    if(numrows != _pg_user->numrows)
        _pg_report += _pg_prename + ":numrows"  + " '" + std::to_string(numrows) + "' '" + std::to_string(_pg_user->numrows) + "'\n";

    if(numcols != _pg_user->numcols)
        _pg_report += _pg_prename + ":numcols"  + " '" + std::to_string(numcols) + "' '" + std::to_string(_pg_user->numcols) + "'\n";

    if(numrows == _pg_user->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)numrows); _pg_i++)
        {
            if(rowindices[_pg_i] != _pg_user->rowindices[_pg_i])
                _pg_report += _pg_prename + ":rowindices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(rowindices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user->rowindices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":rowindices array dimension differs, array not compared\n";

    if(numcols == _pg_user->numcols)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_COLS) && (_pg_i < (unsigned)numcols); _pg_i++)
        {
            if(colindices[_pg_i] != _pg_user->colindices[_pg_i])
                _pg_report += _pg_prename + ":colindices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(colindices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user->colindices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":colindices array dimension differs, array not compared\n";

    if(numrows == _pg_user->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)numrows); _pg_i++)
        {
            if(numcols == _pg_user->numcols)
            {
                for(_pg_j = 0; (_pg_j < EFI_TABLE_MAX_COLS) && (_pg_j < (unsigned)numcols); _pg_j++)
                {
                    if(data[_pg_i][_pg_j] != _pg_user->data[_pg_i][_pg_j])
                        _pg_report += _pg_prename + ":data"  + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + to_formatted_string(data[_pg_i][_pg_j], 7) + "' '" + to_formatted_string(_pg_user->data[_pg_i][_pg_j], 7) + "'\n";
                }
            }
            else
                _pg_report += _pg_prename + ":data 2nd array dimension differs, array not compared\n";
        }
    }
    else
        _pg_report += _pg_prename + ":data array dimension differs, array not compared\n";

    if(numrows == _pg_user->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)numrows); _pg_i++)
        {
            if(numcols == _pg_user->numcols)
            {
                for(_pg_j = 0; (_pg_j < EFI_TABLE_MAX_COLS) && (_pg_j < (unsigned)numcols); _pg_j++)
                {
                    if(meta[_pg_i][_pg_j] != _pg_user->meta[_pg_i][_pg_j])
                        _pg_report += _pg_prename + ":meta"  + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + std::to_string(meta[_pg_i][_pg_j]) + "' '" + std::to_string(_pg_user->meta[_pg_i][_pg_j]) + "'\n";
                }
            }
            else
                _pg_report += _pg_prename + ":meta 2nd array dimension differs, array not compared\n";
        }
    }
    else
        _pg_report += _pg_prename + ":meta array dimension differs, array not compared\n";

    return _pg_report;

}// efiTable2D_t::compare

// end of eficompareutil.cpp
