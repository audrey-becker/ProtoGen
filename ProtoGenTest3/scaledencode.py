# scaledencode.py was generated by ProtoGen version 3.1.d

from scaledencode import *
from fieldencode import *


#ifdef UINT64_MAX

def float64ScaledTo8UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 8 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 18446744073709551615:
        number = 18446744073709551615
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ulonglong(round(scaledvalue))
    index = uint64ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo8UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 8 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 18446744073709551615:
        number = 18446744073709551615
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ulonglong(round(scaledvalue))
    index = uint64ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo8SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 8 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 9223372036854775807:
            number = 9223372036854775807
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -9223372036854775808:
            number = -9223372036854775808
        else:
            number = scaledvalue

    number = c_longlong(round(scaledvalue))
    index = int64ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo8SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 8 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 9223372036854775807:
            number = 9223372036854775807
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -9223372036854775808:
            number = -9223372036854775808
        else:
            number = scaledvalue

    number = c_longlong(round(scaledvalue))
    index = int64ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo7UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 7 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 72057594037927935:
        number = 72057594037927935
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ulonglong(round(scaledvalue))
    index = uint56ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo7UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 7 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 72057594037927935:
        number = 72057594037927935
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ulonglong(round(scaledvalue))
    index = uint56ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo7SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 7 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 36028797018963967:
            number = 36028797018963967
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -36028797018963968:
            number = -36028797018963968
        else:
            number = scaledvalue

    number = c_longlong(round(scaledvalue))
    index = int56ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo7SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 7 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 36028797018963967:
            number = 36028797018963967
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -36028797018963968:
            number = -36028797018963968
        else:
            number = scaledvalue

    number = c_longlong(round(scaledvalue))
    index = int56ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo6UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 6 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 281474976710655:
        number = 281474976710655
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ulonglong(round(scaledvalue))
    index = uint48ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo6UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 6 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 281474976710655:
        number = 281474976710655
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ulonglong(round(scaledvalue))
    index = uint48ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo6SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 6 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 140737488355327:
            number = 140737488355327
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -140737488355328:
            number = -140737488355328
        else:
            number = scaledvalue

    number = c_longlong(round(scaledvalue))
    index = int48ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo6SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 6 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 140737488355327:
            number = 140737488355327
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -140737488355328:
            number = -140737488355328
        else:
            number = scaledvalue

    number = c_longlong(round(scaledvalue))
    index = int48ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo5UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 5 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 1099511627775:
        number = 1099511627775
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ulonglong(round(scaledvalue))
    index = uint40ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo5UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 5 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 1099511627775:
        number = 1099511627775
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ulonglong(round(scaledvalue))
    index = uint40ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo5SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 5 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 549755813887:
            number = 549755813887
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -549755813888:
            number = -549755813888
        else:
            number = scaledvalue

    number = c_longlong(round(scaledvalue))
    index = int40ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo5SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 5 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 549755813887:
            number = 549755813887
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -549755813888:
            number = -549755813888
        else:
            number = scaledvalue

    number = c_longlong(round(scaledvalue))
    index = int40ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledToBitfield(value: int, minimum: float, scaler: float, bits: int) -> int:
    """Scale a double using floating point scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def float64ScaledTo4UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 4 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 4294967295:
        number = 4294967295
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_uint(round(scaledvalue))
    index = uint32ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo4UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 4 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 4294967295:
        number = 4294967295
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_uint(round(scaledvalue))
    index = uint32ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo4SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 4 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 2147483647:
            number = 2147483647
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -2147483648:
            number = -2147483648
        else:
            number = scaledvalue

    number = c_int(round(scaledvalue))
    index = int32ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo4SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 4 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 2147483647:
            number = 2147483647
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -2147483648:
            number = -2147483648
        else:
            number = scaledvalue

    number = c_int(round(scaledvalue))
    index = int32ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo3UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 3 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 16777215:
        number = 16777215
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_uint(round(scaledvalue))
    index = uint24ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo3UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 3 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 16777215:
        number = 16777215
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_uint(round(scaledvalue))
    index = uint24ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo3SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 3 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 8388607:
            number = 8388607
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -8388608:
            number = -8388608
        else:
            number = scaledvalue

    number = c_int(round(scaledvalue))
    index = int24ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo3SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 3 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 8388607:
            number = 8388607
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -8388608:
            number = -8388608
        else:
            number = scaledvalue

    number = c_int(round(scaledvalue))
    index = int24ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo2UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 2 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 65535:
        number = 65535
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ushort(round(scaledvalue))
    index = uint16ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo2UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 2 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 65535:
        number = 65535
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ushort(round(scaledvalue))
    index = uint16ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo2SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 2 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 32767:
            number = 32767
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -32768:
            number = -32768
        else:
            number = scaledvalue

    number = c_short(round(scaledvalue))
    index = int16ToBeBytes(byteA, index, number.value);
    return index



def float64ScaledTo2SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 2 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 32767:
            number = 32767
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -32768:
            number = -32768
        else:
            number = scaledvalue

    number = c_short(round(scaledvalue))
    index = int16ToLeBytes(byteA, index, number.value);
    return index



def float64ScaledTo1UnsignedByte(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 255:
        number = 255
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ubyte(round(scaledvalue))
    index = uint8ToBytes(byteA, index, number.value);
    return index



def float64ScaledTo1SignedByte(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a double on a byte stream by floating point scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 127:
            number = 127
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -128:
            number = -128
        else:
            number = scaledvalue

    number = c_byte(round(scaledvalue))
    index = int8ToBytes(byteA, index, number.value);
    return index



def uint64ScaledTo8UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 8 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))

        index = uint64ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint64ToBeBytes(byteA, index, number)
        return index



def uint64ScaledTo8UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 8 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))

        index = uint64ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint64ToLeBytes(byteA, index, number)
        return index



def uint64ScaledTo8SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 8 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))
    index = int64ToBeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo8SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 8 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))
    index = int64ToLeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo7UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 7 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 72057594037927935:
            number.value = 72057594037927935

        index = uint56ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint56ToBeBytes(byteA, index, number)
        return index



def uint64ScaledTo7UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 7 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 72057594037927935:
            number.value = 72057594037927935

        index = uint56ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint56ToLeBytes(byteA, index, number)
        return index



def uint64ScaledTo7SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 7 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 36028797018963967:
        number.value = 36028797018963967

    elif number.value < -36028797018963968:
        number.value = -36028797018963968

    index = int56ToBeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo7SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 7 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 36028797018963967:
        number.value = 36028797018963967

    elif number.value < -36028797018963968:
        number.value = -36028797018963968

    index = int56ToLeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo6UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 6 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 281474976710655:
            number.value = 281474976710655

        index = uint48ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint48ToBeBytes(byteA, index, number)
        return index



def uint64ScaledTo6UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 6 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 281474976710655:
            number.value = 281474976710655

        index = uint48ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint48ToLeBytes(byteA, index, number)
        return index



def uint64ScaledTo6SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 6 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 140737488355327:
        number.value = 140737488355327

    elif number.value < -140737488355328:
        number.value = -140737488355328

    index = int48ToBeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo6SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 6 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 140737488355327:
        number.value = 140737488355327

    elif number.value < -140737488355328:
        number.value = -140737488355328

    index = int48ToLeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo5UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 5 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 1099511627775:
            number.value = 1099511627775

        index = uint40ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint40ToBeBytes(byteA, index, number)
        return index



def uint64ScaledTo5UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 5 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 1099511627775:
            number.value = 1099511627775

        index = uint40ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint40ToLeBytes(byteA, index, number)
        return index



def uint64ScaledTo5SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 5 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 549755813887:
        number.value = 549755813887

    elif number.value < -549755813888:
        number.value = -549755813888

    index = int40ToBeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo5SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 5 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 549755813887:
        number.value = 549755813887

    elif number.value < -549755813888:
        number.value = -549755813888

    index = int40ToLeBytes(byteA, index, number.value)
    return index



def uint64ScaledToBitfield(value: int, minimum: float, scaler: float, bits: int) -> int:
    """Scale a uint64_t using integer scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def uint64ScaledTo4UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 4 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 4294967295:
            number.value = 4294967295

        index = uint32ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint32ToBeBytes(byteA, index, number)
        return index



def uint64ScaledTo4UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 4 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 4294967295:
            number.value = 4294967295

        index = uint32ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint32ToLeBytes(byteA, index, number)
        return index



def uint64ScaledTo4SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 4 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 2147483647:
        number.value = 2147483647

    elif number.value < -2147483648:
        number.value = -2147483648

    index = int32ToBeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo4SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 4 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 2147483647:
        number.value = 2147483647

    elif number.value < -2147483648:
        number.value = -2147483648

    index = int32ToLeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo3UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 3 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 16777215:
            number.value = 16777215

        index = uint24ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint24ToBeBytes(byteA, index, number)
        return index



def uint64ScaledTo3UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 3 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 16777215:
            number.value = 16777215

        index = uint24ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint24ToLeBytes(byteA, index, number)
        return index



def uint64ScaledTo3SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 3 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 8388607:
        number.value = 8388607

    elif number.value < -8388608:
        number.value = -8388608

    index = int24ToBeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo3SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 3 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 8388607:
        number.value = 8388607

    elif number.value < -8388608:
        number.value = -8388608

    index = int24ToLeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo2UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))
        if number.value > 65535:
            number.value = 65535

        index = uint16ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToBeBytes(byteA, index, number)
        return index



def uint64ScaledTo2UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))
        if number.value > 65535:
            number.value = 65535

        index = uint16ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToLeBytes(byteA, index, number)
        return index



def uint64ScaledTo2SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 32767:
        number.value = 32767

    elif number.value < -32768:
        number.value = -32768

    index = int16ToBeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo2SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 32767:
        number.value = 32767

    elif number.value < -32768:
        number.value = -32768

    index = int16ToLeBytes(byteA, index, number.value)
    return index



def uint64ScaledTo1UnsignedByte(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ubyte(round((value - minimum) * scaler))
        if number.value > 255:
            number.value = 255

        index = uint8ToBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint8ToBytes(byteA, index, number)
        return index



def uint64ScaledTo1SignedByte(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint64_t on a byte stream by integer scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_byte(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 127:
        number.value = 127

    elif number.value < -128:
        number.value = -128

    index = int8ToBytes(byteA, index, number.value)
    return index



def int64ScaledTo8UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 8 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))

        index = uint64ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint64ToBeBytes(byteA, index, number)
        return index



def int64ScaledTo8UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 8 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))

        index = uint64ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint64ToLeBytes(byteA, index, number)
        return index



def int64ScaledTo8SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 8 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))
    index = int64ToBeBytes(byteA, index, number.value)
    return index



def int64ScaledTo8SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 8 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))
    index = int64ToLeBytes(byteA, index, number.value)
    return index



def int64ScaledTo7UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 7 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 72057594037927935:
            number.value = 72057594037927935

        index = uint56ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint56ToBeBytes(byteA, index, number)
        return index



def int64ScaledTo7UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 7 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 72057594037927935:
            number.value = 72057594037927935

        index = uint56ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint56ToLeBytes(byteA, index, number)
        return index



def int64ScaledTo7SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 7 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 36028797018963967:
        number.value = 36028797018963967

    elif number.value < -36028797018963968:
        number.value = -36028797018963968

    index = int56ToBeBytes(byteA, index, number.value)
    return index



def int64ScaledTo7SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 7 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 36028797018963967:
        number.value = 36028797018963967

    elif number.value < -36028797018963968:
        number.value = -36028797018963968

    index = int56ToLeBytes(byteA, index, number.value)
    return index



def int64ScaledTo6UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 6 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 281474976710655:
            number.value = 281474976710655

        index = uint48ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint48ToBeBytes(byteA, index, number)
        return index



def int64ScaledTo6UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 6 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 281474976710655:
            number.value = 281474976710655

        index = uint48ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint48ToLeBytes(byteA, index, number)
        return index



def int64ScaledTo6SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 6 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 140737488355327:
        number.value = 140737488355327

    elif number.value < -140737488355328:
        number.value = -140737488355328

    index = int48ToBeBytes(byteA, index, number.value)
    return index



def int64ScaledTo6SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 6 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 140737488355327:
        number.value = 140737488355327

    elif number.value < -140737488355328:
        number.value = -140737488355328

    index = int48ToLeBytes(byteA, index, number.value)
    return index



def int64ScaledTo5UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 5 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 1099511627775:
            number.value = 1099511627775

        index = uint40ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint40ToBeBytes(byteA, index, number)
        return index



def int64ScaledTo5UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 5 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ulonglong(round((value - minimum) * scaler))
        if number.value > 1099511627775:
            number.value = 1099511627775

        index = uint40ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint40ToLeBytes(byteA, index, number)
        return index



def int64ScaledTo5SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 5 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 549755813887:
        number.value = 549755813887

    elif number.value < -549755813888:
        number.value = -549755813888

    index = int40ToBeBytes(byteA, index, number.value)
    return index



def int64ScaledTo5SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 5 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_longlong(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 549755813887:
        number.value = 549755813887

    elif number.value < -549755813888:
        number.value = -549755813888

    index = int40ToLeBytes(byteA, index, number.value)
    return index



def int64ScaledToBitfield(value: int, minimum: float, scaler: float, bits: int) -> int:
    """Scale a int64_t using integer scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def int64ScaledTo4UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 4 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 4294967295:
            number.value = 4294967295

        index = uint32ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint32ToBeBytes(byteA, index, number)
        return index



def int64ScaledTo4UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 4 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 4294967295:
            number.value = 4294967295

        index = uint32ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint32ToLeBytes(byteA, index, number)
        return index



def int64ScaledTo4SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 4 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 2147483647:
        number.value = 2147483647

    elif number.value < -2147483648:
        number.value = -2147483648

    index = int32ToBeBytes(byteA, index, number.value)
    return index



def int64ScaledTo4SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 4 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 2147483647:
        number.value = 2147483647

    elif number.value < -2147483648:
        number.value = -2147483648

    index = int32ToLeBytes(byteA, index, number.value)
    return index



def int64ScaledTo3UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 3 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 16777215:
            number.value = 16777215

        index = uint24ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint24ToBeBytes(byteA, index, number)
        return index



def int64ScaledTo3UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 3 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 16777215:
            number.value = 16777215

        index = uint24ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint24ToLeBytes(byteA, index, number)
        return index



def int64ScaledTo3SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 3 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 8388607:
        number.value = 8388607

    elif number.value < -8388608:
        number.value = -8388608

    index = int24ToBeBytes(byteA, index, number.value)
    return index



def int64ScaledTo3SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 3 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 8388607:
        number.value = 8388607

    elif number.value < -8388608:
        number.value = -8388608

    index = int24ToLeBytes(byteA, index, number.value)
    return index



def int64ScaledTo2UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))
        if number.value > 65535:
            number.value = 65535

        index = uint16ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToBeBytes(byteA, index, number)
        return index



def int64ScaledTo2UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))
        if number.value > 65535:
            number.value = 65535

        index = uint16ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToLeBytes(byteA, index, number)
        return index



def int64ScaledTo2SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 32767:
        number.value = 32767

    elif number.value < -32768:
        number.value = -32768

    index = int16ToBeBytes(byteA, index, number.value)
    return index



def int64ScaledTo2SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 32767:
        number.value = 32767

    elif number.value < -32768:
        number.value = -32768

    index = int16ToLeBytes(byteA, index, number.value)
    return index



def int64ScaledTo1UnsignedByte(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ubyte(round((value - minimum) * scaler))
        if number.value > 255:
            number.value = 255

        index = uint8ToBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint8ToBytes(byteA, index, number)
        return index



def int64ScaledTo1SignedByte(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int64_t on a byte stream by integer scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_byte(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 127:
        number.value = 127

    elif number.value < -128:
        number.value = -128

    index = int8ToBytes(byteA, index, number.value)
    return index



#endif // UINT64_MAX

def float32ScaledToBitfield(value: float, minimum: float, scaler: float, bits: int) -> int:
    """Scale a float using floating point scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def float32ScaledTo4UnsignedBeBytes(value: float, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 4 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 4294967295:
        number = 4294967295
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_uint(round(scaledvalue))
    index = uint32ToBeBytes(byteA, index, number.value);
    return index



def float32ScaledTo4UnsignedLeBytes(value: float, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 4 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 4294967295:
        number = 4294967295
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_uint(round(scaledvalue))
    index = uint32ToLeBytes(byteA, index, number.value);
    return index



def float32ScaledTo4SignedBeBytes(value: float, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 4 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 2147483647:
            number = 2147483647
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -2147483648:
            number = -2147483648
        else:
            number = scaledvalue

    number = c_int(round(scaledvalue))
    index = int32ToBeBytes(byteA, index, number.value);
    return index



def float32ScaledTo4SignedLeBytes(value: float, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 4 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 2147483647:
            number = 2147483647
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -2147483648:
            number = -2147483648
        else:
            number = scaledvalue

    number = c_int(round(scaledvalue))
    index = int32ToLeBytes(byteA, index, number.value);
    return index



def float32ScaledTo3UnsignedBeBytes(value: float, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 3 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 16777215:
        number = 16777215
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_uint(round(scaledvalue))
    index = uint24ToBeBytes(byteA, index, number.value);
    return index



def float32ScaledTo3UnsignedLeBytes(value: float, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 3 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 16777215:
        number = 16777215
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_uint(round(scaledvalue))
    index = uint24ToLeBytes(byteA, index, number.value);
    return index



def float32ScaledTo3SignedBeBytes(value: float, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 3 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 8388607:
            number = 8388607
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -8388608:
            number = -8388608
        else:
            number = scaledvalue

    number = c_int(round(scaledvalue))
    index = int24ToBeBytes(byteA, index, number.value);
    return index



def float32ScaledTo3SignedLeBytes(value: float, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 3 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 8388607:
            number = 8388607
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -8388608:
            number = -8388608
        else:
            number = scaledvalue

    number = c_int(round(scaledvalue))
    index = int24ToLeBytes(byteA, index, number.value);
    return index



def float32ScaledTo2UnsignedBeBytes(value: float, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 2 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 65535:
        number = 65535
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ushort(round(scaledvalue))
    index = uint16ToBeBytes(byteA, index, number.value);
    return index



def float32ScaledTo2UnsignedLeBytes(value: float, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 2 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 65535:
        number = 65535
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ushort(round(scaledvalue))
    index = uint16ToLeBytes(byteA, index, number.value);
    return index



def float32ScaledTo2SignedBeBytes(value: float, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 2 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 32767:
            number = 32767
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -32768:
            number = -32768
        else:
            number = scaledvalue

    number = c_short(round(scaledvalue))
    index = int16ToBeBytes(byteA, index, number.value);
    return index



def float32ScaledTo2SignedLeBytes(value: float, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 2 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 32767:
            number = 32767
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -32768:
            number = -32768
        else:
            number = scaledvalue

    number = c_short(round(scaledvalue))
    index = int16ToLeBytes(byteA, index, number.value);
    return index



def float32ScaledTo1UnsignedByte(value: float, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = (value - minimum) * scaler

    # Make sure number fits in the range
    if scaledvalue >= 255:
        number = 255
    elif scaledvalue <= 0:
        number = 0
    else:
        number = scaledvalue


    number = c_ubyte(round(scaledvalue))
    index = uint8ToBytes(byteA, index, number.value);
    return index



def float32ScaledTo1SignedByte(value: float, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a float on a byte stream by floating point scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    scaledvalue = value * scaler

    # Make sure number fits in the range
    if scaledvalue >= 0:
        if scaledvalue >= 127:
            number = 127
        else:
            number = scaledvalue

    else:
        if scaledvalue <= -128:
            number = -128
        else:
            number = scaledvalue

    number = c_byte(round(scaledvalue))
    index = int8ToBytes(byteA, index, number.value);
    return index



def uint32ScaledToBitfield(value: int, minimum: float, scaler: float, bits: int) -> int:
    """Scale a uint32_t using integer scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def uint32ScaledTo4UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))

        index = uint32ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint32ToBeBytes(byteA, index, number)
        return index



def uint32ScaledTo4UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))

        index = uint32ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint32ToLeBytes(byteA, index, number)
        return index



def uint32ScaledTo4SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))
    index = int32ToBeBytes(byteA, index, number.value)
    return index



def uint32ScaledTo4SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))
    index = int32ToLeBytes(byteA, index, number.value)
    return index



def uint32ScaledTo3UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 16777215:
            number.value = 16777215

        index = uint24ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint24ToBeBytes(byteA, index, number)
        return index



def uint32ScaledTo3UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 16777215:
            number.value = 16777215

        index = uint24ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint24ToLeBytes(byteA, index, number)
        return index



def uint32ScaledTo3SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 8388607:
        number.value = 8388607

    elif number.value < -8388608:
        number.value = -8388608

    index = int24ToBeBytes(byteA, index, number.value)
    return index



def uint32ScaledTo3SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 8388607:
        number.value = 8388607

    elif number.value < -8388608:
        number.value = -8388608

    index = int24ToLeBytes(byteA, index, number.value)
    return index



def uint32ScaledTo2UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))
        if number.value > 65535:
            number.value = 65535

        index = uint16ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToBeBytes(byteA, index, number)
        return index



def uint32ScaledTo2UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))
        if number.value > 65535:
            number.value = 65535

        index = uint16ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToLeBytes(byteA, index, number)
        return index



def uint32ScaledTo2SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 32767:
        number.value = 32767

    elif number.value < -32768:
        number.value = -32768

    index = int16ToBeBytes(byteA, index, number.value)
    return index



def uint32ScaledTo2SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 32767:
        number.value = 32767

    elif number.value < -32768:
        number.value = -32768

    index = int16ToLeBytes(byteA, index, number.value)
    return index



def uint32ScaledTo1UnsignedByte(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ubyte(round((value - minimum) * scaler))
        if number.value > 255:
            number.value = 255

        index = uint8ToBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint8ToBytes(byteA, index, number)
        return index



def uint32ScaledTo1SignedByte(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint32_t on a byte stream by integer scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_byte(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 127:
        number.value = 127

    elif number.value < -128:
        number.value = -128

    index = int8ToBytes(byteA, index, number.value)
    return index



def int32ScaledToBitfield(value: int, minimum: float, scaler: float, bits: int) -> int:
    """Scale a int32_t using integer scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def int32ScaledTo4UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))

        index = uint32ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint32ToBeBytes(byteA, index, number)
        return index



def int32ScaledTo4UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))

        index = uint32ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint32ToLeBytes(byteA, index, number)
        return index



def int32ScaledTo4SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 4 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))
    index = int32ToBeBytes(byteA, index, number.value)
    return index



def int32ScaledTo4SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 4 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))
    index = int32ToLeBytes(byteA, index, number.value)
    return index



def int32ScaledTo3UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 16777215:
            number.value = 16777215

        index = uint24ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint24ToBeBytes(byteA, index, number)
        return index



def int32ScaledTo3UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_uint(round((value - minimum) * scaler))
        if number.value > 16777215:
            number.value = 16777215

        index = uint24ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint24ToLeBytes(byteA, index, number)
        return index



def int32ScaledTo3SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 3 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 8388607:
        number.value = 8388607

    elif number.value < -8388608:
        number.value = -8388608

    index = int24ToBeBytes(byteA, index, number.value)
    return index



def int32ScaledTo3SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 3 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_int(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 8388607:
        number.value = 8388607

    elif number.value < -8388608:
        number.value = -8388608

    index = int24ToLeBytes(byteA, index, number.value)
    return index



def int32ScaledTo2UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))
        if number.value > 65535:
            number.value = 65535

        index = uint16ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToBeBytes(byteA, index, number)
        return index



def int32ScaledTo2UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))
        if number.value > 65535:
            number.value = 65535

        index = uint16ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToLeBytes(byteA, index, number)
        return index



def int32ScaledTo2SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 32767:
        number.value = 32767

    elif number.value < -32768:
        number.value = -32768

    index = int16ToBeBytes(byteA, index, number.value)
    return index



def int32ScaledTo2SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 32767:
        number.value = 32767

    elif number.value < -32768:
        number.value = -32768

    index = int16ToLeBytes(byteA, index, number.value)
    return index



def int32ScaledTo1UnsignedByte(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ubyte(round((value - minimum) * scaler))
        if number.value > 255:
            number.value = 255

        index = uint8ToBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint8ToBytes(byteA, index, number)
        return index



def int32ScaledTo1SignedByte(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int32_t on a byte stream by integer scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_byte(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 127:
        number.value = 127

    elif number.value < -128:
        number.value = -128

    index = int8ToBytes(byteA, index, number.value)
    return index



def uint16ScaledToBitfield(value: int, minimum: float, scaler: float, bits: int) -> int:
    """Scale a uint16_t using integer scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def uint16ScaledTo2UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))

        index = uint16ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToBeBytes(byteA, index, number)
        return index



def uint16ScaledTo2UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))

        index = uint16ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToLeBytes(byteA, index, number)
        return index



def uint16ScaledTo2SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))
    index = int16ToBeBytes(byteA, index, number.value)
    return index



def uint16ScaledTo2SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))
    index = int16ToLeBytes(byteA, index, number.value)
    return index



def uint16ScaledTo1UnsignedByte(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint16_t on a byte stream by integer scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ubyte(round((value - minimum) * scaler))
        if number.value > 255:
            number.value = 255

        index = uint8ToBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint8ToBytes(byteA, index, number)
        return index



def uint16ScaledTo1SignedByte(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint16_t on a byte stream by integer scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_byte(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 127:
        number.value = 127

    elif number.value < -128:
        number.value = -128

    index = int8ToBytes(byteA, index, number.value)
    return index



def int16ScaledToBitfield(value: int, minimum: float, scaler: float, bits: int) -> int:
    """Scale a int16_t using integer scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def int16ScaledTo2UnsignedBeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))

        index = uint16ToBeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToBeBytes(byteA, index, number)
        return index



def int16ScaledTo2UnsignedLeBytes(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ushort(round((value - minimum) * scaler))

        index = uint16ToLeBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint16ToLeBytes(byteA, index, number)
        return index



def int16ScaledTo2SignedBeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int16_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))
    index = int16ToBeBytes(byteA, index, number.value)
    return index



def int16ScaledTo2SignedLeBytes(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int16_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_short(round(value * scaler))
    index = int16ToLeBytes(byteA, index, number.value)
    return index



def int16ScaledTo1UnsignedByte(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int16_t on a byte stream by integer scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ubyte(round((value - minimum) * scaler))
        if number.value > 255:
            number.value = 255

        index = uint8ToBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint8ToBytes(byteA, index, number)
        return index



def int16ScaledTo1SignedByte(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int16_t on a byte stream by integer scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_byte(round(value * scaler))

    # Make sure number fits in the range
    if number.value > 127:
        number.value = 127

    elif number.value < -128:
        number.value = -128

    index = int8ToBytes(byteA, index, number.value)
    return index



def uint8ScaledToBitfield(value: int, minimum: float, scaler: float, bits: int) -> int:
    """Scale a uint8_t using integer scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def uint8ScaledTo1UnsignedByte(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a uint8_t on a byte stream by integer scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ubyte(round((value - minimum) * scaler))

        index = uint8ToBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint8ToBytes(byteA, index, number)
        return index



def uint8ScaledTo1SignedByte(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a uint8_t on a byte stream by integer scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_byte(round(value * scaler))
    index = int8ToBytes(byteA, index, number.value)
    return index



def int8ScaledToBitfield(value: int, minimum: float, scaler: float, bits: int) -> int:
    """Scale a int8_t using integer scaling to the base integer type used for bitfields.    Args:
        value (?): the number to scale.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value creates the encoded integer.
        bits (int): the number of bits in the bitfield, used to limit the returned value.
    Return:
        (value-min)*scaler.
    """
    return



def int8ScaledTo1UnsignedByte(value: int, byteA: bytearray, index: int, minimum: float, scaler: float) -> int:
    """Encode a int8_t on a byte stream by integer scaling to fit in 1 unsigned byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        minimum (float): the minimum value that can be encoded.
        scaler (float): when multiplied by value createss the encoded integer: encoded = (value-min)*scaler.
    Return:
        index (int): the updated index
    """
    if value > minimum:
        number = c_ubyte(round((value - minimum) * scaler))

        index = uint8ToBytes(byteA, index, number.value)
        return index

    else:
        number = 0
        index = uint8ToBytes(byteA, index, number)
        return index



def int8ScaledTo1SignedByte(value: int, byteA: bytearray, index: int, scaler: float) -> int:
    """Encode a int8_t on a byte stream by integer scaling to fit in 1 signed byte.    Args:
        value (int): the number to encode.
        byteA (bytearray): the byte stream which receives the encoded data.
        index (int): gives the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
        scaler (float): when multiplied by value creates the encoded integer: encoded = value*scaler.
    Return:
        index (int): the updated index
    """
    # scale the number
    number = c_byte(round(value * scaler))
    index = int8ToBytes(byteA, index, number.value)
    return index



# end of scaledencode.py
