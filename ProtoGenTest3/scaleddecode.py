# scaleddecode.py was generated by ProtoGen version 3.1.d

from scaleddecode import *
from fielddecode import *


#ifdef UINT64_MAX

def float64ScaledFrom8UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 8 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint64FromBeBytes(byteA, index))



def float64ScaledFrom8UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 8 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint64FromLeBytes(byteA, index))



def float64ScaledFrom8SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 8 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int64FromBeBytes(byteA, index)



def float64ScaledFrom8SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 8 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int64FromLeBytes(byteA, index)



def float64ScaledFrom7UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 7 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint56FromBeBytes(byteA, index))



def float64ScaledFrom7UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 7 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint56FromLeBytes(byteA, index))



def float64ScaledFrom7SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 7 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int56FromBeBytes(byteA, index)



def float64ScaledFrom7SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 7 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int56FromLeBytes(byteA, index)



def float64ScaledFrom6UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 6 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint48FromBeBytes(byteA, index))



def float64ScaledFrom6UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 6 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint48FromLeBytes(byteA, index))



def float64ScaledFrom6SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 6 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int48FromBeBytes(byteA, index)



def float64ScaledFrom6SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 6 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int48FromLeBytes(byteA, index)



def float64ScaledFrom5UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 5 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint40FromBeBytes(byteA, index))



def float64ScaledFrom5UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 5 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint40FromLeBytes(byteA, index))



def float64ScaledFrom5SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 5 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int40FromBeBytes(byteA, index)



def float64ScaledFrom5SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 5 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int40FromLeBytes(byteA, index)



def float64ScaledFromBitfield(value: int, minimum: float, invscaler: float) -> float:
    """Compute a double using inverse floating point scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            invscaler (float): is multiplied by the integer to create the return value.
                Invscaler should be the inverse of the scaler given to the scaling function.
        Return:
            The correctly scaled decoded value: return = min + value*invscaler.
    """
    return minimum + (invscaler * value)



def float64ScaledFrom4UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 4 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint32FromBeBytes(byteA, index))



def float64ScaledFrom4UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 4 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint32FromLeBytes(byteA, index))



def float64ScaledFrom4SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 4 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int32FromBeBytes(byteA, index)



def float64ScaledFrom4SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 4 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int32FromLeBytes(byteA, index)



def float64ScaledFrom3UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 3 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint24FromBeBytes(byteA, index))



def float64ScaledFrom3UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 3 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint24FromLeBytes(byteA, index))



def float64ScaledFrom3SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 3 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int24FromBeBytes(byteA, index)



def float64ScaledFrom3SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 3 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int24FromLeBytes(byteA, index)



def float64ScaledFrom2UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 2 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint16FromBeBytes(byteA, index))



def float64ScaledFrom2UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 2 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint16FromLeBytes(byteA, index))



def float64ScaledFrom2SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 2 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int16FromBeBytes(byteA, index)



def float64ScaledFrom2SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 2 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int16FromLeBytes(byteA, index)



def float64ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint8FromBytes(byteA, index))



def float64ScaledFrom1SignedBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a double from a byte stream by inverse floating point scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int8FromBytes(byteA, index)



def uint64ScaledFrom8UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 8 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint64FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom8UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 8 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint64FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom8SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 8 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int64FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom8SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 8 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int64FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom7UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 7 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint56FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom7UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 7 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint56FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom7SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 7 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int56FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom7SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 7 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int56FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom6UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 6 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint48FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom6UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 6 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint48FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom6SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 6 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int48FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom6SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 6 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int48FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom5UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 5 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint40FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom5UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 5 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint40FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom5SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 5 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int40FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom5SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 5 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int40FromLeBytes(byteA, index) // divisor



def uint64ScaledFromBitfield(value: int, minimum: float,  divisor:int) -> int:
    """Compute a uint64_t using inverse integer scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + (value // divisor)



def uint64ScaledFrom4UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint32FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom4UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint32FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom4SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int32FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom4SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int32FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom3UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint24FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom3UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint24FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom3SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int24FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom3SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int24FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom2UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom2UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom2SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromBeBytes(byteA, index) // divisor



def uint64ScaledFrom2SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromLeBytes(byteA, index) // divisor



def uint64ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint8FromBytes(byteA, index) // divisor



def uint64ScaledFrom1SignedBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint64_t from a byte stream by inverse integer scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int8FromBytes(byteA, index) // divisor



def int64ScaledFrom8UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 8 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint64FromBeBytes(byteA, index) // divisor



def int64ScaledFrom8UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 8 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint64FromLeBytes(byteA, index) // divisor



def int64ScaledFrom8SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 8 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int64FromBeBytes(byteA, index) // divisor



def int64ScaledFrom8SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 8 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 8 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int64FromLeBytes(byteA, index) // divisor



def int64ScaledFrom7UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 7 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint56FromBeBytes(byteA, index) // divisor



def int64ScaledFrom7UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 7 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint56FromLeBytes(byteA, index) // divisor



def int64ScaledFrom7SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 7 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int56FromBeBytes(byteA, index) // divisor



def int64ScaledFrom7SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 7 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 7 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int56FromLeBytes(byteA, index) // divisor



def int64ScaledFrom6UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 6 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint48FromBeBytes(byteA, index) // divisor



def int64ScaledFrom6UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 6 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint48FromLeBytes(byteA, index) // divisor



def int64ScaledFrom6SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 6 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int48FromBeBytes(byteA, index) // divisor



def int64ScaledFrom6SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 6 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 6 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int48FromLeBytes(byteA, index) // divisor



def int64ScaledFrom5UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 5 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint40FromBeBytes(byteA, index) // divisor



def int64ScaledFrom5UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 5 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint40FromLeBytes(byteA, index) // divisor



def int64ScaledFrom5SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 5 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int40FromBeBytes(byteA, index) // divisor



def int64ScaledFrom5SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 5 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 5 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int40FromLeBytes(byteA, index) // divisor



def int64ScaledFromBitfield(value: int, minimum: float,  divisor:int) -> int:
    """Compute a int64_t using inverse integer scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + (value // divisor)



def int64ScaledFrom4UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint32FromBeBytes(byteA, index) // divisor



def int64ScaledFrom4UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint32FromLeBytes(byteA, index) // divisor



def int64ScaledFrom4SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int32FromBeBytes(byteA, index) // divisor



def int64ScaledFrom4SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int32FromLeBytes(byteA, index) // divisor



def int64ScaledFrom3UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint24FromBeBytes(byteA, index) // divisor



def int64ScaledFrom3UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint24FromLeBytes(byteA, index) // divisor



def int64ScaledFrom3SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int24FromBeBytes(byteA, index) // divisor



def int64ScaledFrom3SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int24FromLeBytes(byteA, index) // divisor



def int64ScaledFrom2UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromBeBytes(byteA, index) // divisor



def int64ScaledFrom2UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromLeBytes(byteA, index) // divisor



def int64ScaledFrom2SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromBeBytes(byteA, index) // divisor



def int64ScaledFrom2SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromLeBytes(byteA, index) // divisor



def int64ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint8FromBytes(byteA, index) // divisor



def int64ScaledFrom1SignedBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int64_t from a byte stream by inverse integer scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int8FromBytes(byteA, index) // divisor



#endif // UINT64_MAX

def float32ScaledFromBitfield(value: int, minimum: float, invscaler: float) -> float:
    """Compute a float using inverse floating point scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            invscaler (float): is multiplied by the integer to create the return value.
                Invscaler should be the inverse of the scaler given to the scaling function.
        Return:
            The correctly scaled decoded value: return = min + value*invscaler.
    """
    return minimum + (invscaler * value)



def float32ScaledFrom4UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 4 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint32FromBeBytes(byteA, index))



def float32ScaledFrom4UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 4 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint32FromLeBytes(byteA, index))



def float32ScaledFrom4SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 4 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int32FromBeBytes(byteA, index)



def float32ScaledFrom4SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 4 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int32FromLeBytes(byteA, index)



def float32ScaledFrom3UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 3 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint24FromBeBytes(byteA, index))



def float32ScaledFrom3UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 3 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint24FromLeBytes(byteA, index))



def float32ScaledFrom3SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 3 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int24FromBeBytes(byteA, index)



def float32ScaledFrom3SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 3 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int24FromLeBytes(byteA, index)



def float32ScaledFrom2UnsignedBeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 2 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint16FromBeBytes(byteA, index))



def float32ScaledFrom2UnsignedLeBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 2 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint16FromLeBytes(byteA, index))



def float32ScaledFrom2SignedBeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 2 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int16FromBeBytes(byteA, index)



def float32ScaledFrom2SignedLeBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 2 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int16FromLeBytes(byteA, index)



def float32ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: float, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = encoded*invscaler.
    """
    return minimum + (invscaler * uint8FromBytes(byteA, index))



def float32ScaledFrom1SignedBytes(byteA: bytearray, index: list, invscaler: float) -> float:
    """Decode a float from a byte stream by inverse floating point scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (float): is the minimum value that can be decoded.
            invscaler (float): is multiplied by the decoded integer to create the return value.
                invscaler should be the inverse of the scaler given to the encode function.
        Return:
            The correctly scaled decoded value: return = min + encoded*invscaler.
    """
    return invscaler * int8FromBytes(byteA, index)



def uint32ScaledFromBitfield(value: int, minimum: float,  divisor:int) -> int:
    """Compute a uint32_t using inverse integer scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + (value // divisor)



def uint32ScaledFrom4UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint32FromBeBytes(byteA, index) // divisor



def uint32ScaledFrom4UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint32FromLeBytes(byteA, index) // divisor



def uint32ScaledFrom4SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int32FromBeBytes(byteA, index) // divisor



def uint32ScaledFrom4SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int32FromLeBytes(byteA, index) // divisor



def uint32ScaledFrom3UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint24FromBeBytes(byteA, index) // divisor



def uint32ScaledFrom3UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint24FromLeBytes(byteA, index) // divisor



def uint32ScaledFrom3SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int24FromBeBytes(byteA, index) // divisor



def uint32ScaledFrom3SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int24FromLeBytes(byteA, index) // divisor



def uint32ScaledFrom2UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromBeBytes(byteA, index) // divisor



def uint32ScaledFrom2UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromLeBytes(byteA, index) // divisor



def uint32ScaledFrom2SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromBeBytes(byteA, index) // divisor



def uint32ScaledFrom2SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromLeBytes(byteA, index) // divisor



def uint32ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint8FromBytes(byteA, index) // divisor



def uint32ScaledFrom1SignedBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint32_t from a byte stream by inverse integer scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int8FromBytes(byteA, index) // divisor



def int32ScaledFromBitfield(value: int, minimum: float,  divisor:int) -> int:
    """Compute a int32_t using inverse integer scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + (value // divisor)



def int32ScaledFrom4UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint32FromBeBytes(byteA, index) // divisor



def int32ScaledFrom4UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 4 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint32FromLeBytes(byteA, index) // divisor



def int32ScaledFrom4SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 4 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int32FromBeBytes(byteA, index) // divisor



def int32ScaledFrom4SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 4 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 4 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int32FromLeBytes(byteA, index) // divisor



def int32ScaledFrom3UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint24FromBeBytes(byteA, index) // divisor



def int32ScaledFrom3UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 3 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint24FromLeBytes(byteA, index) // divisor



def int32ScaledFrom3SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 3 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int24FromBeBytes(byteA, index) // divisor



def int32ScaledFrom3SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 3 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 3 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int24FromLeBytes(byteA, index) // divisor



def int32ScaledFrom2UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromBeBytes(byteA, index) // divisor



def int32ScaledFrom2UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromLeBytes(byteA, index) // divisor



def int32ScaledFrom2SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromBeBytes(byteA, index) // divisor



def int32ScaledFrom2SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromLeBytes(byteA, index) // divisor



def int32ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint8FromBytes(byteA, index) // divisor



def int32ScaledFrom1SignedBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int32_t from a byte stream by inverse integer scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int8FromBytes(byteA, index) // divisor



def uint16ScaledFromBitfield(value: int, minimum: float,  divisor:int) -> int:
    """Compute a uint16_t using inverse integer scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + (value // divisor)



def uint16ScaledFrom2UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromBeBytes(byteA, index) // divisor



def uint16ScaledFrom2UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromLeBytes(byteA, index) // divisor



def uint16ScaledFrom2SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint16_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromBeBytes(byteA, index) // divisor



def uint16ScaledFrom2SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint16_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromLeBytes(byteA, index) // divisor



def uint16ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint16_t from a byte stream by inverse integer scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint8FromBytes(byteA, index) // divisor



def uint16ScaledFrom1SignedBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint16_t from a byte stream by inverse integer scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int8FromBytes(byteA, index) // divisor



def int16ScaledFromBitfield(value: int, minimum: float,  divisor:int) -> int:
    """Compute a int16_t using inverse integer scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + (value // divisor)



def int16ScaledFrom2UnsignedBeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromBeBytes(byteA, index) // divisor



def int16ScaledFrom2UnsignedLeBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int16_t from a byte stream by inverse integer scaling from 2 unsigned bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint16FromLeBytes(byteA, index) // divisor



def int16ScaledFrom2SignedBeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int16_t from a byte stream by inverse integer scaling from 2 signed bytes in big endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromBeBytes(byteA, index) // divisor



def int16ScaledFrom2SignedLeBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int16_t from a byte stream by inverse integer scaling from 2 signed bytes in little endian order.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 2 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int16FromLeBytes(byteA, index) // divisor



def int16ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int16_t from a byte stream by inverse integer scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint8FromBytes(byteA, index) // divisor



def int16ScaledFrom1SignedBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int16_t from a byte stream by inverse integer scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int8FromBytes(byteA, index) // divisor



def uint8ScaledFromBitfield(value: int, minimum: float,  divisor:int) -> int:
    """Compute a uint8_t using inverse integer scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + (value // divisor)



def uint8ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a uint8_t from a byte stream by inverse integer scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint8FromBytes(byteA, index) // divisor



def uint8ScaledFrom1SignedBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a uint8_t from a byte stream by inverse integer scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int8FromBytes(byteA, index) // divisor



def int8ScaledFromBitfield(value: int, minimum: float,  divisor:int) -> int:
    """Compute a int8_t using inverse integer scaling from the base integer type used for bitfields.
        Args:
            value (float): the number to scale.
            minimum (float): the minimum value that can be encoded.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + (value // divisor)



def int8ScaledFrom1UnsignedBytes(byteA: bytearray, index: list, minimum: int, divisor: int) -> int:
    """Decode a int8_t from a byte stream by inverse integer scaling from 1 unsigned byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            minimum (int) is the minimum value that can be decoded.
            divisor(int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = min + encoded/divisor.
    """
    return minimum + uint8FromBytes(byteA, index) // divisor



def int8ScaledFrom1SignedBytes(byteA: bytearray, index: list, divisor: int) -> int:
    """Decode a int8_t from a byte stream by inverse integer scaling from 1 signed byte.
        Args:
            byteA (bytearray): the byte stream to decode.
            index (list): the first element of the list is the location of the first byte in the byte stream, and
                will be incremented by 1 when this function is complete.
            divisor (int): is divided into the encoded integer to create the return value.
        Return:
            The correctly scaled decoded value: return = encoded/divisor.
    """
    return int8FromBytes(byteA, index) // divisor



# end of scaleddecode.py
