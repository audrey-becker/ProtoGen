// scaleddecode.c was generated by ProtoGen version 3.1.d

#include "scaleddecode.h"
#include "fielddecode.h"


#ifdef UINT64_MAX

/*!
 * Decode a double from a byte stream by inverse floating point scaling from 8
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom8UnsignedBeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint64FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 8
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom8UnsignedLeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint64FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 8
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom8SignedBeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int64FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 8
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom8SignedLeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int64FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 7
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom7UnsignedBeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint56FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 7
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom7UnsignedLeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint56FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 7
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom7SignedBeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int56FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 7
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom7SignedLeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int56FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 6
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom6UnsignedBeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint48FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 6
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom6UnsignedLeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint48FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 6
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom6SignedBeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int48FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 6
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom6SignedLeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int48FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 5
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom5UnsignedBeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint40FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 5
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom5UnsignedLeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint40FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 5
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom5SignedBeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int40FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 5
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom5SignedLeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int40FromLeBytes(bytes, index));
}


/*!
 * Compute a double using inverse floating point scaling from the base integer
 * type used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param invscaler is multiplied by the integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the scaling function.
 * \return the correctly scaled decoded value: return = min + value*invscaler.
 */
double float64ScaledFromBitfield(unsigned int value, double min, double invscaler)
{
    return (double)(min + invscaler*value);
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 4
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom4UnsignedBeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint32FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 4
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom4UnsignedLeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint32FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 4
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom4SignedBeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int32FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 4
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom4SignedLeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int32FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 3
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom3UnsignedBeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint24FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 3
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom3UnsignedLeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint24FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 3
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom3SignedBeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int24FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 3
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom3SignedLeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int24FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint16FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint16FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 2
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int16FromBeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 2
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int16FromLeBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
double float64ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, double min, double invscaler)
{
    return (double)(min + invscaler*uint8FromBytes(bytes, index));
}


/*!
 * Decode a double from a byte stream by inverse floating point scaling from 1
 * signed byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
double float64ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, double invscaler)
{
    return (double)(invscaler*int8FromBytes(bytes, index));
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 8
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom8UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint64FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 8
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom8UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint64FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 8
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom8SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int64FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 8
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom8SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int64FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 7
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom7UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint56FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 7
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom7UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint56FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 7
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom7SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int56FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 7
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom7SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int56FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 6
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom6UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint48FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 6
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom6UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint48FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 6
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom6SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int48FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 6
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom6SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int48FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 5
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom5UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint40FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 5
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom5UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint40FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 5
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom5SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int40FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 5
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom5SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int40FromLeBytes(bytes, index)/divisor);
}


/*!
 * Compute a uint64_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFromBitfield(unsigned int value, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + value/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom4UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom4UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 4
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom4SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 4
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom4SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom3UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom3UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 3
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom3SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 3
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom3SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 2
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 2
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint64_t uint64ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (uint64_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint64_t from a byte stream by inverse integer scaling from 1
 * signed byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint64_t uint64ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (uint64_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 8
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom8UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint64FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 8
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom8UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint64FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 8 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom8SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int64FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 8 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom8SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int64FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 7
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom7UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint56FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 7
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom7UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint56FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 7 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom7SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int56FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 7 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom7SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int56FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 6
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom6UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint48FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 6
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom6UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint48FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 6 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom6SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int48FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 6 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom6SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int48FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 5
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom5UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint40FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 5
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom5UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint40FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 5 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom5SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int40FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 5 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom5SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int40FromLeBytes(bytes, index)/divisor);
}


/*!
 * Compute a int64_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFromBitfield(unsigned int value, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + value/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom4UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom4UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 4 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom4SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 4 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom4SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom3UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom3UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 3 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom3SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 3 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom3SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int64_t int64ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int64_t min, uint64_t divisor)
{
    return (int64_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a int64_t from a byte stream by inverse integer scaling from 1 signed
 * byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int64_t int64ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint64_t divisor)
{
    return (int64_t)(int8FromBytes(bytes, index)/divisor);
}


#endif // UINT64_MAX

/*!
 * Compute a float using inverse floating point scaling from the base integer
 * type used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param invscaler is multiplied by the integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the scaling function.
 * \return the correctly scaled decoded value: return = min + value*invscaler.
 */
float float32ScaledFromBitfield(unsigned int value, float min, float invscaler)
{
    return (float)(min + invscaler*value);
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 4
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom4UnsignedBeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint32FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 4
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom4UnsignedLeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint32FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 4
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom4SignedBeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int32FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 4
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom4SignedLeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int32FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 3
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom3UnsignedBeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint24FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 3
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom3UnsignedLeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint24FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 3
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom3SignedBeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int24FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 3
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom3SignedLeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int24FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint16FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint16FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 2
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int16FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 2
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int16FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint8FromBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 1
 * signed byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int8FromBytes(bytes, index));
}


/*!
 * Compute a uint32_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFromBitfield(unsigned int value, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + value/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom4UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom4UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 4
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom4SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 4
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom4SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom3UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom3UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 3
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom3SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 3
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom3SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 2
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 2
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 1
 * signed byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a int32_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFromBitfield(unsigned int value, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + value/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom4UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom4UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 4 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom4SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 4 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom4SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom3UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom3UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 3 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom3SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 3 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom3SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 1 signed
 * byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a uint16_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint16_t uint16ScaledFromBitfield(unsigned int value, int16_t min, uint16_t divisor)
{
    return (uint16_t)(min + value/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint16_t uint16ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (uint16_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint16_t uint16ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (uint16_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 2
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint16_t uint16ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (uint16_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 2
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint16_t uint16ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (uint16_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint16_t uint16ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (uint16_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 1
 * signed byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint16_t uint16ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (uint16_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a int16_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int16_t int16ScaledFromBitfield(unsigned int value, int16_t min, uint16_t divisor)
{
    return (int16_t)(min + value/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int16_t int16ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (int16_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int16_t int16ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (int16_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int16_t int16ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (int16_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int16_t int16ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (int16_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int16_t int16ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (int16_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 1 signed
 * byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int16_t int16ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (int16_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a uint8_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint8_t uint8ScaledFromBitfield(unsigned int value, int8_t min, uint8_t divisor)
{
    return (uint8_t)(min + value/divisor);
}


/*!
 * Decode a uint8_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint8_t uint8ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int8_t min, uint8_t divisor)
{
    return (uint8_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint8_t from a byte stream by inverse integer scaling from 1 signed
 * byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint8_t uint8ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint8_t divisor)
{
    return (uint8_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a int8_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int8_t int8ScaledFromBitfield(unsigned int value, int8_t min, uint8_t divisor)
{
    return (int8_t)(min + value/divisor);
}


/*!
 * Decode a int8_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int8_t int8ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int8_t min, uint8_t divisor)
{
    return (int8_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a int8_t from a byte stream by inverse integer scaling from 1 signed
 * byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int8_t int8ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint8_t divisor)
{
    return (int8_t)(int8FromBytes(bytes, index)/divisor);
}


// end of scaleddecode.c
