// eficomms.h was generated by ProtoGen version 3.1.d

#ifndef _EFICOMMS_H
#define _EFICOMMS_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 */

#include "eficommsProtocol.h"

/*!
 * Calendar date information
 */
typedef struct
{
    uint8_t  day;   //!< The day of the month from 1 to 31
    uint8_t  month; //!< The month of the year from 1 (January) to 12 (December)
    uint16_t year;  //!< The year (AD) of the date
}efiDate_t;

//! return the minimum encoded length for the efiDate_t structure
#define getMinLengthOfefiDate_t() (2)

//! return the maximum encoded length for the efiDate_t structure
#define getMaxLengthOfefiDate_t() (2)

//! Encode a efiDate_t into a byte array
void encodeefiDate_t(uint8_t* data, int* bytecount, const efiDate_t* user);

//! Decode a efiDate_t from a byte array
int decodeefiDate_t(const uint8_t* data, int* bytecount, efiDate_t* user);

/*!
 * Date and time information
 */
typedef struct
{
    uint32_t jiffytime; //!< 10s of milliseconds of the day from 0 to 8640000
    uint8_t  day;       //!< The day of the month from 1 to 31
    uint8_t  month;     //!< The month of the year from 1 (January) to 12 (December)
    uint16_t year;      //!< The year (AD) of the date
}efiDateTime_t;

//! return the minimum encoded length for the efiDateTime_t structure
#define getMinLengthOfefiDateTime_t() (5)

//! return the maximum encoded length for the efiDateTime_t structure
#define getMaxLengthOfefiDateTime_t() (5)

//! Encode a efiDateTime_t into a byte array
void encodeefiDateTime_t(uint8_t* data, int* bytecount, const efiDateTime_t* user);

//! Decode a efiDateTime_t from a byte array
int decodeefiDateTime_t(const uint8_t* data, int* bytecount, efiDateTime_t* user);

/*!
 * One bit for every configuration packet that can be sent, requested, or
 * stored.
 */
typedef struct
{
    unsigned sensors : 16;          //!< One bit for each of the sensors. The least significant bit is the first sensor.
    unsigned reservedbits : 3;      //!< Remaining bits for future expansion
    unsigned cooling : 1;           //!< The cooling configuration
    unsigned newengine : 1;         //!< The new engine configuration
    unsigned sdjournal : 1;         //!< The SD Card journal data
    unsigned wear : 1;              //!< The engine wear data
    unsigned logbook : 1;           //!< The logbook data
    unsigned maintenancestatus : 1; //!< The maintenance status data
    unsigned maintenanceconfig : 1; //!< The maintenance configuration data
    unsigned scopesetup : 1;        //!< The oscilloscope setup data
    unsigned confighash : 1;        //!< The configuration hash data
    unsigned pump : 1;              //!< The fuel pump configuration
    unsigned comms : 1;             //!< The communications configuration
    unsigned throttle : 1;          //!< The throttle configuration
    unsigned reservedbit : 1;       //!< A reserved bit for future expansion
    unsigned injector : 1;          //!< The injector configuration
    unsigned rpmcontroller : 1;     //!< The rpm controller configuration
    unsigned lockcontrol : 1;       //!< The lock control information
    unsigned softwareinfo : 1;      //!< The software information data
    unsigned resetinfo : 1;         //!< The reset report data
    unsigned file : 1;              //!< The file data
    unsigned comment : 1;           //!< The comment data
    unsigned hardwareinfo : 1;      //!< The hardware information data
    unsigned tables : 24;           //!< One bit for each of the tables. The least significant bit is the first table.
    unsigned reservedbits2 : 19;    //!< More bits for future expansion
    unsigned tables2 : 13;          //!< One bit for each of the tables above table 23. The least significant bit is table 24.
}efiConfigBits_t;

//! return the minimum encoded length for the efiConfigBits_t structure
#define getMinLengthOfefiConfigBits_t() (12)

//! return the maximum encoded length for the efiConfigBits_t structure
#define getMaxLengthOfefiConfigBits_t() (12)

//! Encode a efiConfigBits_t into a byte array
void encodeefiConfigBits_t(uint8_t* data, int* bytecount, const efiConfigBits_t* user);

//! Decode a efiConfigBits_t from a byte array
int decodeefiConfigBits_t(const uint8_t* data, int* bytecount, efiConfigBits_t* user);

/*!
 * Details of a crank sense for either once-per-rev or crank wheel sensors.
 * Crank wheels provide higher resolution crank angle sensing than a typical
 * once-per-rev hall sensor arrangement. In order to use the crank wheel you
 * must specify the tooth count of the crank wheel, and the size of the
 * sychronization gap. It is possible to have a directional crank wheel which
 * uses two gaps of different size (a big gap and a small gap). Directional
 * crank wheel sensors make it possible to prevent the engine from running in
 * the wrong direction, or to enable it to run in either direction. Engine
 * rotation is defined from the persective of looking at the output end of the
 * engine (the end with the flywheel, propeller, transmission, etc.). From this
 * perspective the rotation is normal if the rotation direction is clockwise
 */
typedef struct
{
    uint8_t  enableWheel;          //!< Set to enable crank wheel sensing. The `totalCount` and `bigGapCount` must be set correctly. If they are not then enable will be cleared.
    uint8_t  activeHigh;           //!< Set if the crank sense occurs on the rising edge, else crank sense is on the falling edge
    uint8_t  disableSensor;        //!< Set to disable this sensor.
    uint8_t  preferThisSensor;     //!< Set to prefer this sensor over the other one.
    uint16_t senseDelay;           //!< Time delay from crank sensor signal to detection of the crank sense signal, in microseconds. This time is subtracted from the clock time of the crank sense.
    float    normalOffset;         //!< Angle of the active sense event in degrees of crank rotation after TDC. For directional crank wheel sensors this is the offset for clockwise (normal) rotation.
    float    reverseOffset;        //!< Angle of the active sense event in degrees of crank rotation after TDC, for directional crank wheels in the reversed rotation direction.
    uint8_t  totalCount;           //!< The number of teeth on the crank wheel plus the missing teeth. This is the full count, as though no synchronization teeth were removed.
    uint8_t  bigGapCount;          //!< The number of teeth missing in the big gap of the crank wheel. The end of the big gap is the crank angle synchronization point. There must always be a non-zero big gap count.
    uint8_t  smallGapCount;        //!< The number of teeth missing in the small gap of the crank wheel. The small gap count can be zero, in which case there is no small gap; and therefore no ability to detect direction of rotation. The small gap count must be less than the big gap count for a functioning crank wheel.
    uint8_t  normalIntraGapCount;  //!< The number of teeth between the big gap and the small gap for normal rotation. Zero if there is no small gap.
    uint8_t  reverseIntraGapCount; //!< The number of teeth between the big gap and the small gap for reverse rotation. Zero if there is no small gap. The intra gap count for reversed rotation should be the same as `totalCount` - `bigGapCount` - `smallGapCount` - `normalIntraGapCount`
}efiCrankSense_t;

//! return the minimum encoded length for the efiCrankSense_t structure
#define getMinLengthOfefiCrankSense_t() (11)

//! return the maximum encoded length for the efiCrankSense_t structure
#define getMaxLengthOfefiCrankSense_t() (11)

//! Encode a efiCrankSense_t into a byte array
void encodeefiCrankSense_t(uint8_t* data, int* bytecount, const efiCrankSense_t* user);

//! Decode a efiCrankSense_t from a byte array
int decodeefiCrankSense_t(const uint8_t* data, int* bytecount, efiCrankSense_t* user);

/*!
 * One dimensional table
 */
typedef struct
{
    unsigned enabled : 1;                 //!< Table enable. If clear then this table is not used
    unsigned num : 7;                     //!< Number of entries in this table
    float    indices[EFI_TABLE_MAX_COLS]; //!< List of independent variables
    float    data[EFI_TABLE_MAX_COLS];    //!< List of dependent variables
}efiTable1D_t;

//! return the minimum encoded length for the efiTable1D_t structure
#define getMinLengthOfefiTable1D_t() (1)

//! return the maximum encoded length for the efiTable1D_t structure
#define getMaxLengthOfefiTable1D_t() (4*EFI_TABLE_MAX_COLS+1)

//! Encode a efiTable1D_t into a byte array
void encodeefiTable1D_t(uint8_t* data, int* bytecount, const efiTable1D_t* user);

//! Decode a efiTable1D_t from a byte array
int decodeefiTable1D_t(const uint8_t* data, int* bytecount, efiTable1D_t* user);

/*!
 * Details about the timing of an interrupt
 */
typedef struct
{
    uint16_t count;        //!< Number of times this interrupt fired during the reporting period
    uint16_t totaltime;    //!< Total amount of time used by this interrupt during the reporting period
    uint8_t  preemptcount; //!< Number of times this interrupt was preempted
    uint8_t  maxtime;      //!< Maximum amount of time in microseconds this interrupt took during this reporting period
}efiInterruptDetail_t;

//! return the minimum encoded length for the efiInterruptDetail_t structure
#define getMinLengthOfefiInterruptDetail_t() (6)

//! return the maximum encoded length for the efiInterruptDetail_t structure
#define getMaxLengthOfefiInterruptDetail_t() (6)

//! Encode a efiInterruptDetail_t into a byte array
void encodeefiInterruptDetail_t(uint8_t* data, int* bytecount, const efiInterruptDetail_t* user);

//! Decode a efiInterruptDetail_t from a byte array
int decodeefiInterruptDetail_t(const uint8_t* data, int* bytecount, efiInterruptDetail_t* user);

/*!
 * Time information for telemetry. The telemetry time packet is always output
 * immediately before the telemetry fast packet, and before the slow telemetry
 * packets. If fast and slow telemetry are output on the same epoch then only a
 * single time packet is output.
 */
typedef struct
{
    uint32_t time;         //!< Time in milliseconds since the system booted up.
    unsigned fasttime : 1; //!< If set this time packet applies to fast telemetry data that immediately follows this packet.
    unsigned slowtime : 1; //!< If set this time packet applies to slow telemetry data that follows this packet.
    uint32_t revcount;     //!< Number of engine revolutions since the engine was last started.
}efiTelemetryTime_t;

//! Create the efiTelemetryTime packet
void encodeefiTelemetryTimePkt(efiPacket_t* pkt, const efiTelemetryTime_t* user);

//! Decode the efiTelemetryTime packet
int decodeefiTelemetryTimePkt(const efiPacket_t* pkt, efiTelemetryTime_t* user);

//! Encode a efiTelemetryTime_t into a byte array
void encodeefiTelemetryTime_t(uint8_t* data, int* bytecount, const efiTelemetryTime_t* user);

//! Decode a efiTelemetryTime_t from a byte array
int decodeefiTelemetryTime_t(const uint8_t* data, int* bytecount, efiTelemetryTime_t* user);

//! return the packet ID for the efiTelemetryTime packet
#define getefiTelemetryTimePktID() (EFI_PKT_TELEMETRYTIME)

//! return the minimum encoded length for the efiTelemetryTime packet
#define getefiTelemetryTimeMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryTime packet
#define getefiTelemetryTimeMaxDataLength() (8)

/*!
 * Fast telemetry, output at the fast telemetry rate.
 */
typedef struct
{
    float             rpm;              //!< Engine speed in revolutions per minute
    unsigned          ioEnable : 1;     //!< Global enable based on physical input
    unsigned          userEnable : 1;   //!< User global enable.
    unsigned          spark1Enable : 1; //!< User enable for spark1.
    unsigned          spark2Enable : 1; //!< User enable for spark2.
    unsigned          spark3Enable : 1; //!< User enable for spark3.
    efiThrottleSource throttleCmdSrc;   //!< Source of the throttle command information. If the EFI is driving the throttle this is the command source. If the EFI is not driving the throttle this is the source of throttle position data.
    float             throttleCmd;      //!< Throttle command (0 to 100%) going in.
    float             throttlePos;      //!< Throttle position (0 to 100%) this may be different from the throttleCmd if a curve is applied, or if the governor is interpreting the throttle command.
    float             injector3Duty;    //!< The third injector duty cycle in percent
    float             injector1Duty;    //!< The first injector duty cycle in percent
    float             injector2Duty;    //!< The second injector duty cycle in percent
}efiTelemetryFast_t;

//! Create the efiTelemetryFast packet
void encodeefiTelemetryFastPkt(efiPacket_t* pkt, const efiTelemetryFast_t* user);

//! Decode the efiTelemetryFast packet
int decodeefiTelemetryFastPkt(const efiPacket_t* pkt, efiTelemetryFast_t* user);

//! Encode a efiTelemetryFast_t into a byte array
void encodeefiTelemetryFast_t(uint8_t* data, int* bytecount, const efiTelemetryFast_t* user);

//! Decode a efiTelemetryFast_t from a byte array
int decodeefiTelemetryFast_t(const uint8_t* data, int* bytecount, efiTelemetryFast_t* user);

//! return the packet ID for the efiTelemetryFast packet
#define getefiTelemetryFastPktID() (EFI_PKT_TELEMETRYFAST)

//! return the minimum encoded length for the efiTelemetryFast packet
#define getefiTelemetryFastMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryFast packet
#define getefiTelemetryFastMaxDataLength() (8)

/*!
 * First set of sensor telemetry, output at slow telemetry rate.
 */
typedef struct
{
    float             _cht;                //!< Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    efiThrottleSource throttlePosSrc;      //!< Source of throttle position information used for table lookups
    unsigned          spareTempIsCHT3 : 1; //!< This bit is set if spare temperature is configured to act as the third CHT
    unsigned          spareTempIsMAT2 : 1; //!< This bit is set if spare temperature is configured to act as the second MAT
    unsigned          spareTempIsOilT : 1; //!< This bit is set if spare temperature is configured to act as oil temperature
    float             sparetemp;           //!< Spare temperature in C
    float             mat;                 //!< Manifold air temperature in C
    float             map;                 //!< Manifold air pressure in kiloPascals.
    float             baro;                //!< Baro air pressure in kiloPascals.
    float             oat;                 //!< Outside air temperature (as measured by the digital barometer) in C.
}efiTelemetrySensors_t;

//! Create the efiTelemetrySensors packet
void encodeefiTelemetrySensorsPkt(efiPacket_t* pkt, const efiTelemetrySensors_t* user);

//! Decode the efiTelemetrySensors packet
int decodeefiTelemetrySensorsPkt(const efiPacket_t* pkt, efiTelemetrySensors_t* user);

//! Encode a efiTelemetrySensors_t into a byte array
void encodeefiTelemetrySensors_t(uint8_t* data, int* bytecount, const efiTelemetrySensors_t* user);

//! Decode a efiTelemetrySensors_t from a byte array
int decodeefiTelemetrySensors_t(const uint8_t* data, int* bytecount, efiTelemetrySensors_t* user);

//! return the packet ID for the efiTelemetrySensors packet
#define getefiTelemetrySensorsPktID() (EFI_PKT_TELEMETRYSENSORS)

//! return the minimum encoded length for the efiTelemetrySensors packet
#define getefiTelemetrySensorsMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetrySensors packet
#define getefiTelemetrySensorsMaxDataLength() (8)

/*!
 * First set of sensor telemetry, output at slow telemetry rate.
 */
typedef struct
{
    float _cht;      //!< Combined cylinder head temperature in C, used for table lookups. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    float _cht1;     //!< First cylinder head temperature in C. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    float sparetemp; //!< Spare temperature in C
    float mat;       //!< Manifold air temperature in C
    float map;       //!< Manifold air pressure in kiloPascals.
    float baro;      //!< Baro air pressure in kiloPascals.
    float oat;       //!< Outside air temperature (as measured by the digital barometer) in C.
}efiTelemetrySensorsapi7_t;

//! Decode the efiTelemetrySensorsapi7 packet
int decodeefiTelemetrySensorsapi7Pkt(const efiPacket_t* pkt, efiTelemetrySensorsapi7_t* user);

//! Decode a efiTelemetrySensorsapi7_t from a byte array
int decodeefiTelemetrySensorsapi7_t(const uint8_t* data, int* bytecount, efiTelemetrySensorsapi7_t* user);

//! return the packet ID for the efiTelemetrySensorsapi7 packet
#define getefiTelemetrySensorsapi7PktID() (EFI_PKT_TELEMETRYSENSORS)

//! return the minimum encoded length for the efiTelemetrySensorsapi7 packet
#define getefiTelemetrySensorsapi7MinDataLength() (8)

//! return the maximum encoded length for the efiTelemetrySensorsapi7 packet
#define getefiTelemetrySensorsapi7MaxDataLength() (8)

/*!
 * Second set of sensor telemetry, output at slow telemetry rate. The crank
 * sense active signals will be set if the crank sense input is in the active
 * state when this message is generated. This is useful only for measuring the
 * crank sense timing, but not for determining anything when the engine is
 * running.
 */
typedef struct
{
    float    measuredCrank2Angle;   //!< Measured synchronization angle of crank sense 2, as determined by crank sense 1.
    float    devCrank2Angle;        //!< Standard deviation of the measured synchronization angle of crank sense 2, as determined by crank sense 1.
    float    _density;              //!< Estimated air density in kilogram per cubic meter, deprecated in api 10.
    unsigned expectSensors4 : 1;    //!< If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used.. Field is encoded constant.
    unsigned api8 : 1;              //!< Set if this packet comes from API 8 or later. Field is encoded constant.
    unsigned crankSense1Active : 1; //!< Set if the first crank sense signal is in the active state.
    unsigned crankSense2Active : 1; //!< Set if the second crank sense signal is in the active state
    float    cooling2;              //!< Second cooling output in percent
    float    tpsError;              //!< Error in percent between throttle output and TPS measurement
    float    analogTPS;             //!< Analog throttle position sensor in percent
    float    pwmTPS;                //!< PWM throttle position sensor in percent
}efiTelemetrySensors2_t;

//! Create the efiTelemetrySensors2 packet
void encodeefiTelemetrySensors2Pkt(efiPacket_t* pkt, const efiTelemetrySensors2_t* user);

//! Decode the efiTelemetrySensors2 packet
int decodeefiTelemetrySensors2Pkt(const efiPacket_t* pkt, efiTelemetrySensors2_t* user);

//! Encode a efiTelemetrySensors2_t into a byte array
void encodeefiTelemetrySensors2_t(uint8_t* data, int* bytecount, const efiTelemetrySensors2_t* user);

//! Decode a efiTelemetrySensors2_t from a byte array
int decodeefiTelemetrySensors2_t(const uint8_t* data, int* bytecount, efiTelemetrySensors2_t* user);

//! return the packet ID for the efiTelemetrySensors2 packet
#define getefiTelemetrySensors2PktID() (EFI_PKT_TELEMETRYSENSORS2)

//! return the minimum encoded length for the efiTelemetrySensors2 packet
#define getefiTelemetrySensors2MinDataLength() (8)

//! return the maximum encoded length for the efiTelemetrySensors2 packet
#define getefiTelemetrySensors2MaxDataLength() (8)

/*!
 * Second set of sensor telemetry, output at slow telemetry rate. The crank
 * sense active signals will be set if the crank sense input is in the active
 * state when this message is generated. This is useful only for measuring the
 * crank sense timing, but not for determining anything when the engine is
 * running.
 */
typedef struct
{
    float    _fuelp;                //!< Fuel pressure in kiloPascals. This is a deprecated field, prefer the field in Telemetry Sensors 4.
    float    density;               //!< Estimated air density in kilogram per cubic meter.
    unsigned expectSensors4 : 1;    //!< If this bit is set the receiver can expect that sensors4 data will be sent from the EFI, otherwise the EFI is older and the deprecated fields in TelemetrySensors and TelemetrySensors2 should be used.
    unsigned api8 : 1;              //!< Clear if this packet comes from before API 8. Field is encoded constant.
    unsigned crankSense1Active : 1; //!< Set if the first crank sense signal is in the active state.
    unsigned crankSense2Active : 1; //!< Set if the second crank sense signal is in the active state
    float    cooling2;              //!< Second cooling output in percent
    float    tpsError;              //!< Error in percent between throttle output and TPS measurement
    float    analogTPS;             //!< Analog throttle position sensor in percent
    float    pwmTPS;                //!< PWM throttle position sensor in percent
}efiTelemetrySensors2api7_t;

//! Decode the efiTelemetrySensors2api7 packet
int decodeefiTelemetrySensors2api7Pkt(const efiPacket_t* pkt, efiTelemetrySensors2api7_t* user);

//! Decode a efiTelemetrySensors2api7_t from a byte array
int decodeefiTelemetrySensors2api7_t(const uint8_t* data, int* bytecount, efiTelemetrySensors2api7_t* user);

//! return the packet ID for the efiTelemetrySensors2api7 packet
#define getefiTelemetrySensors2api7PktID() (EFI_PKT_TELEMETRYSENSORS2)

//! return the minimum encoded length for the efiTelemetrySensors2api7 packet
#define getefiTelemetrySensors2api7MinDataLength() (8)

//! return the maximum encoded length for the efiTelemetrySensors2api7 packet
#define getefiTelemetrySensors2api7MaxDataLength() (8)

/*!
 * Third set of sensor telemetry, output at slow telemetry rate.
 */
typedef struct
{
    float inputVolts;   //!< Input voltage in Volts.
    float inputCurrent; //!< Input current in Amps.
    float volts12;      //!< 12V rail voltage in Volts.
    float current12;    //!< 12V rail current in Amps.
}efiTelemetrySensors3api0_t;

//! Decode the efiTelemetrySensors3api0 packet
int decodeefiTelemetrySensors3api0Pkt(const efiPacket_t* pkt, efiTelemetrySensors3api0_t* user);

//! Decode a efiTelemetrySensors3api0_t from a byte array
int decodeefiTelemetrySensors3api0_t(const uint8_t* data, int* bytecount, efiTelemetrySensors3api0_t* user);

//! return the packet ID for the efiTelemetrySensors3api0 packet
#define getefiTelemetrySensors3api0PktID() (EFI_PKT_TELEMETRYSENSORS3)

//! return the minimum encoded length for the efiTelemetrySensors3api0 packet
#define getefiTelemetrySensors3api0MinDataLength() (4)

//! return the maximum encoded length for the efiTelemetrySensors3api0 packet
#define getefiTelemetrySensors3api0MaxDataLength() (4)

/*!
 * Third set of sensor telemetry, output at slow telemetry rate.
 */
typedef struct
{
    float inputVolts;   //!< Input voltage in Volts.
    float inputCurrent; //!< Input current in Amps.
    float volts12;      //!< 12V rail voltage in Volts.
    float current12;    //!< 12V rail current in Amps.
    float baroDigital;  //!< Baro air pressure in kiloPascals from the digital barometer.
    float baroAnalog;   //!< Baro air pressure in kiloPascals from the analog barometer.
}efiTelemetrySensors3_t;

//! Create the efiTelemetrySensors3 packet
void encodeefiTelemetrySensors3Pkt(efiPacket_t* pkt, const efiTelemetrySensors3_t* user);

//! Decode the efiTelemetrySensors3 packet
int decodeefiTelemetrySensors3Pkt(const efiPacket_t* pkt, efiTelemetrySensors3_t* user);

//! Encode a efiTelemetrySensors3_t into a byte array
void encodeefiTelemetrySensors3_t(uint8_t* data, int* bytecount, const efiTelemetrySensors3_t* user);

//! Decode a efiTelemetrySensors3_t from a byte array
int decodeefiTelemetrySensors3_t(const uint8_t* data, int* bytecount, efiTelemetrySensors3_t* user);

//! return the packet ID for the efiTelemetrySensors3 packet
#define getefiTelemetrySensors3PktID() (EFI_PKT_TELEMETRYSENSORS3)

//! return the minimum encoded length for the efiTelemetrySensors3 packet
#define getefiTelemetrySensors3MinDataLength() (8)

//! return the maximum encoded length for the efiTelemetrySensors3 packet
#define getefiTelemetrySensors3MaxDataLength() (8)

/*!
 * Fourth set of sensor telemetry, output at slow telemetry rate.
 */
typedef struct
{
    float             cht;            //!< Average cylinder head temperature in C.
    float             cht1;           //!< First cylinder head temperature in C.
    float             cht2;           //!< Second cylinder head temperature in C.
    efiCrankDirection crankdirection; //!< The direction of rotation measured by the crank wheel(s) or by the once-per-rev sensors.
    float             chargeTempCoef; //!< Charge temperature coefficient from 0 to 1 that determines how much CHT is used in the computation of charge temperature.
    float             _fmHeadTemp2;   //!< Deprecated in API 10, do not use.. Field is encoded constant.
    float             fuelp;          //!< Fuel pressure in kiloPascals.
}efiTelemetrySensors4_t;

//! Create the efiTelemetrySensors4 packet
void encodeefiTelemetrySensors4Pkt(efiPacket_t* pkt, const efiTelemetrySensors4_t* user);

//! Decode the efiTelemetrySensors4 packet
int decodeefiTelemetrySensors4Pkt(const efiPacket_t* pkt, efiTelemetrySensors4_t* user);

//! Encode a efiTelemetrySensors4_t into a byte array
void encodeefiTelemetrySensors4_t(uint8_t* data, int* bytecount, const efiTelemetrySensors4_t* user);

//! Decode a efiTelemetrySensors4_t from a byte array
int decodeefiTelemetrySensors4_t(const uint8_t* data, int* bytecount, efiTelemetrySensors4_t* user);

//! return the packet ID for the efiTelemetrySensors4 packet
#define getefiTelemetrySensors4PktID() (EFI_PKT_TELEMETRYSENSORS4)

//! return the minimum encoded length for the efiTelemetrySensors4 packet
#define getefiTelemetrySensors4MinDataLength() (8)

//! return the maximum encoded length for the efiTelemetrySensors4 packet
#define getefiTelemetrySensors4MaxDataLength() (8)

/*!
 * Fueling telemetry, output at the slow telemetry rate
 */
typedef struct
{
    float fuelFlowRate;    //!< Fuel flow rate in grams per minute.
    float fuelConsumption; //!< Fuel consumption in grams since the system turned on.
    float fmInjector1;     //!< Total fuel multiplier for injector 1, including the main fuel multiplier.
    float fmInjector2;     //!< Total fuel multiplier for injector 2, including the main fuel multiplier.
    float fmInjector3;     //!< Total fuel multiplier for injector 3, including the main fuel multiplier.
}efiTelemetryFuel_t;

//! Create the efiTelemetryFuel packet
void encodeefiTelemetryFuelPkt(efiPacket_t* pkt, const efiTelemetryFuel_t* user);

//! Decode the efiTelemetryFuel packet
int decodeefiTelemetryFuelPkt(const efiPacket_t* pkt, efiTelemetryFuel_t* user);

//! Encode a efiTelemetryFuel_t into a byte array
void encodeefiTelemetryFuel_t(uint8_t* data, int* bytecount, const efiTelemetryFuel_t* user);

//! Decode a efiTelemetryFuel_t from a byte array
int decodeefiTelemetryFuel_t(const uint8_t* data, int* bytecount, efiTelemetryFuel_t* user);

//! return the packet ID for the efiTelemetryFuel packet
#define getefiTelemetryFuelPktID() (EFI_PKT_TELEMETRYFUEL)

//! return the minimum encoded length for the efiTelemetryFuel packet
#define getefiTelemetryFuelMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryFuel packet
#define getefiTelemetryFuelMaxDataLength() (8)

/*!
 * Operational details for injectors 1 and 2
 */
typedef struct
{
    unsigned injector1usesense1 : 1; //!< Set if injector 1 is being triggered by sense 1
    unsigned injector1usesense2 : 1; //!< Set if injector 1 is being triggered by sense 2
    float    injector1Time;          //!< First injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    float    injection1Angle;        //!< Crank angle of the first injection.
    unsigned injector2usesense1 : 1; //!< Set if injector 2 is being triggered by sense 1
    unsigned injector2usesense2 : 1; //!< Set if injector 2 is being triggered by sense 2
    float    injector2Time;          //!< Second injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    float    injection2Angle;        //!< Crank angle of the second injection.
    unsigned injector3usesense1 : 1; //!< Set if injector 3 is being triggered by sense 1
    unsigned injector3usesense2 : 1; //!< Set if injector 3 is being triggered by sense 2
}efiTelemetryInjector_t;

//! Create the efiTelemetryInjector packet
void encodeefiTelemetryInjectorPkt(efiPacket_t* pkt, const efiTelemetryInjector_t* user);

//! Decode the efiTelemetryInjector packet
int decodeefiTelemetryInjectorPkt(const efiPacket_t* pkt, efiTelemetryInjector_t* user);

//! Encode a efiTelemetryInjector_t into a byte array
void encodeefiTelemetryInjector_t(uint8_t* data, int* bytecount, const efiTelemetryInjector_t* user);

//! Decode a efiTelemetryInjector_t from a byte array
int decodeefiTelemetryInjector_t(const uint8_t* data, int* bytecount, efiTelemetryInjector_t* user);

//! return the packet ID for the efiTelemetryInjector packet
#define getefiTelemetryInjectorPktID() (EFI_PKT_TELEMETRYINJECTOR)

//! return the minimum encoded length for the efiTelemetryInjector packet
#define getefiTelemetryInjectorMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryInjector packet
#define getefiTelemetryInjectorMaxDataLength() (8)

/*!
 * Operational details for the third injector and second and third spark
 */
typedef struct
{
    float sparkAdvance2;   //!< Spark advance in degrees for the second spark output.
    float sparkAdvance3;   //!< Spark advance in degrees for the third spark output.
    float injection3Angle; //!< Crank angle of the third injection.
    float injector3Time;   //!< third injector on time for each engine cycle in microseconds. This does not include the injector trim time.
    float _fmChargeTemp3;  //!< Deprecated in API 10, do not use. Field is encoded constant.
    float _fmHeadTemp3;    //!< Deprecated in API 10, do not use. Field is encoded constant.
}efiTelemetryExtendedOutputs_t;

//! Create the efiTelemetryExtendedOutputs packet
void encodeefiTelemetryExtendedOutputsPkt(efiPacket_t* pkt, const efiTelemetryExtendedOutputs_t* user);

//! Decode the efiTelemetryExtendedOutputs packet
int decodeefiTelemetryExtendedOutputsPkt(const efiPacket_t* pkt, efiTelemetryExtendedOutputs_t* user);

//! Encode a efiTelemetryExtendedOutputs_t into a byte array
void encodeefiTelemetryExtendedOutputs_t(uint8_t* data, int* bytecount, const efiTelemetryExtendedOutputs_t* user);

//! Decode a efiTelemetryExtendedOutputs_t from a byte array
int decodeefiTelemetryExtendedOutputs_t(const uint8_t* data, int* bytecount, efiTelemetryExtendedOutputs_t* user);

//! return the packet ID for the efiTelemetryExtendedOutputs packet
#define getefiTelemetryExtendedOutputsPktID() (EFI_PKT_TELEMETRYEXTENDEDOUTPUTS)

//! return the minimum encoded length for the efiTelemetryExtendedOutputs packet
#define getefiTelemetryExtendedOutputsMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryExtendedOutputs packet
#define getefiTelemetryExtendedOutputsMaxDataLength() (8)

/*!
 * Miscellanious telemetry, output at the slow telemetry rate. For any slow
 * output epoch this is always the last packet. Therefore you should trigger
 * display of slow packet data on receipt of this packet (or the slow summary
 * packet).
 */
typedef struct
{
    float    sparkAdvance1;                 //!< Spark advance in degrees for the first spark output.
    unsigned spark1usesense1 : 1;           //!< Set if spark 1 is being triggered by sense 1
    unsigned spark1usesense2 : 1;           //!< Set if spark 1 is being triggered by sense 2
    unsigned spark2usesense1 : 1;           //!< Set if spark 2 is being triggered by sense 1
    unsigned spark2usesense2 : 1;           //!< Set if spark 2 is being triggered by sense 2
    unsigned spark3usesense1 : 1;           //!< Set if spark 3 is being triggered by sense 1
    unsigned spark3usesense2 : 1;           //!< Set if spark 3 is being triggered by sense 2
    float    power;                         //!< Estimated engine shaft power in Watts.
    unsigned rpmControllerFromUser : 1;     //!< Set if the RPM controller is running and gettings its command from the user.
    unsigned rpmControllerFromThrottle : 1; //!< Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter.
    float    rpmcmd;                        //!< Engine speed command in revolutions per minute.
    float    pumpduty;                      //!< Fuel pump duty cycle in percent
    float    cooling1;                      //!< First cooling output in percent
}efiTelemetrySlow_t;

//! Create the efiTelemetrySlow packet
void encodeefiTelemetrySlowPkt(efiPacket_t* pkt, const efiTelemetrySlow_t* user);

//! Decode the efiTelemetrySlow packet
int decodeefiTelemetrySlowPkt(const efiPacket_t* pkt, efiTelemetrySlow_t* user);

//! Encode a efiTelemetrySlow_t into a byte array
void encodeefiTelemetrySlow_t(uint8_t* data, int* bytecount, const efiTelemetrySlow_t* user);

//! Decode a efiTelemetrySlow_t from a byte array
int decodeefiTelemetrySlow_t(const uint8_t* data, int* bytecount, efiTelemetrySlow_t* user);

//! return the packet ID for the efiTelemetrySlow packet
#define getefiTelemetrySlowPktID() (EFI_PKT_TELEMETRYSLOW)

//! return the minimum encoded length for the efiTelemetrySlow packet
#define getefiTelemetrySlowMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetrySlow packet
#define getefiTelemetrySlowMaxDataLength() (8)

/*!
 * Miscellanious telemetry, output at the slow telemetry rate. For any slow
 * output epoch this is always the last packet. Therefore you should trigger
 * display of slow packet data on receipt of this packet (or the slow summary
 * packet).
 */
typedef struct
{
    float    sparkAdvance1;                 //!< Spark advance in degrees for the first spark output.
    float    _sparkAdvance2;                //!< Spark advance in degrees for the second spark output.
    float    power;                         //!< Estimated engine shaft power in Watts.
    unsigned rpmControllerFromUser : 1;     //!< Set if the RPM controller is running and gettings its command from the user.
    unsigned rpmControllerFromThrottle : 1; //!< Set if the RPM controller is running and getting its command from the throttle input, or the throttle limiter.
    float    rpmcmd;                        //!< Engine speed command in revolutions per minute.
    float    pumpduty;                      //!< Fuel pump duty cycle in percent
    float    cooling1;                      //!< First cooling output in percent
}efiTelemetrySlowapi7_t;

//! Decode the efiTelemetrySlowapi7 packet
int decodeefiTelemetrySlowapi7Pkt(const efiPacket_t* pkt, efiTelemetrySlowapi7_t* user);

//! Decode a efiTelemetrySlowapi7_t from a byte array
int decodeefiTelemetrySlowapi7_t(const uint8_t* data, int* bytecount, efiTelemetrySlowapi7_t* user);

//! return the packet ID for the efiTelemetrySlowapi7 packet
#define getefiTelemetrySlowapi7PktID() (EFI_PKT_TELEMETRYSLOW)

//! return the minimum encoded length for the efiTelemetrySlowapi7 packet
#define getefiTelemetrySlowapi7MinDataLength() (8)

//! return the maximum encoded length for the efiTelemetrySlowapi7 packet
#define getefiTelemetrySlowapi7MaxDataLength() (8)

/*!
 * Run time system information including CPU loading
 */
typedef struct
{
    float    cpuLoad;              //!< Total cpu loading in percent
    float    intLoad;              //!< Percentage of CPU time spent in interrupts
    float    stack;                //!< Percentage of available stack space that has been used
    float    cpuTemp;              //!< CPU temperature in C.
    unsigned safeModeActive : 1;   //!< If set the system booted in safe mode due to too many resets. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system.
    unsigned passwordRequired : 1; //!< If set the EFI requires a password to be unlocked.
    unsigned unlockLevel : 2;      //!< EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked
    unsigned sdcardPresent : 1;    //!< If set an SD card is detected and configured for data recording, and the SD card telemetry packet should be expected.
    unsigned gcuPresent : 1;       //!< If set a GCU (generator control unit) is detected on the CNA bus and the GCU telemetry packet should be expected.
    uint32_t watchdog;             //!< Maximum interval of time, in microseconds, between watchdog service events.
    uint8_t  api;                  //!< Application programming interface number. Changes to the ICD will increment this number.. Field is encoded constant.
    uint32_t interrupt;            //!< Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds.
}efiTelemetryCPU_t;

//! Create the efiTelemetryCPU packet
void encodeefiTelemetryCPUPkt(efiPacket_t* pkt, const efiTelemetryCPU_t* user);

//! Decode the efiTelemetryCPU packet
int decodeefiTelemetryCPUPkt(const efiPacket_t* pkt, efiTelemetryCPU_t* user);

//! Encode a efiTelemetryCPU_t into a byte array
void encodeefiTelemetryCPU_t(uint8_t* data, int* bytecount, const efiTelemetryCPU_t* user);

//! Decode a efiTelemetryCPU_t from a byte array
int decodeefiTelemetryCPU_t(const uint8_t* data, int* bytecount, efiTelemetryCPU_t* user);

//! return the packet ID for the efiTelemetryCPU packet
#define getefiTelemetryCPUPktID() (EFI_PKT_TELEMETRYCPU)

//! return the minimum encoded length for the efiTelemetryCPU packet
#define getefiTelemetryCPUMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryCPU packet
#define getefiTelemetryCPUMaxDataLength() (8)

/*!
 * Run time system information including CPU loading
 */
typedef struct
{
    float    cpuLoad;              //!< Total cpu loading in percent
    float    intLoad;              //!< Percentage of CPU time spent in interrupts
    float    stack;                //!< Percentage of available stack space that has been used
    float    cpuTemp;              //!< CPU temperature in C.
    unsigned passwordRequired : 1; //!< If set the EFI requires a password to be unlocked.
    unsigned unlockLevel : 2;      //!< EFI unlock level. 0 indicates the EFI is locked, '1' indicates the EFI is partially unlocked, and '2' indicates it is password unlocked
    uint32_t watchdog;             //!< Maximum interval of time, in microseconds, between watchdog service events.
    unsigned interrupt : 14;       //!< Maximum amount time spent in an interrupt, or with interrupts blocked, in microseconds.
}efiTelemetryCPUapi4_t;

//! Decode the efiTelemetryCPUapi4 packet
int decodeefiTelemetryCPUapi4Pkt(const efiPacket_t* pkt, efiTelemetryCPUapi4_t* user);

//! Decode a efiTelemetryCPUapi4_t from a byte array
int decodeefiTelemetryCPUapi4_t(const uint8_t* data, int* bytecount, efiTelemetryCPUapi4_t* user);

//! return the packet ID for the efiTelemetryCPUapi4 packet
#define getefiTelemetryCPUapi4PktID() (EFI_PKT_TELEMETRYCPU)

//! return the minimum encoded length for the efiTelemetryCPUapi4 packet
#define getefiTelemetryCPUapi4MinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryCPUapi4 packet
#define getefiTelemetryCPUapi4MaxDataLength() (8)

/*!
 * Enumerated list of errors that can be reported by the crank sensor
 */
typedef enum
{
    EFI_CRANK_NOERROR,       //!< No errors in crank sense
    EFI_CRANK_STARTSYNCERROR,//!< Crank wheel synchronization error during start. This could be a transient
    EFI_CRANK_MISSEDEDGE,    //!< Crank sense missed an edge (i.e. two edges of the same type (rising or falling) in a row)
    EFI_CRANK_OVERCAPTURE,   //!< Crank sense hardware registered an overcapture, which occurs when software does not service the hardware fast enough
    EFI_CRANK_TOOFAST,       //!< Crank sense active edge was earlier than expected
    EFI_CRANK_RUNSYNCERROR,  //!< Crank wheel synchronization was lost after the engine was running
    EFI_CRANK_TOOLATE,       //!< Crank sense active edge was later than expected
    EFI_CRANK_REVERSED       //!< Crank is rotating in a direction that is not allowed
} efiCrankError;

/*!
 * Error information, output at the slow telemetry rate. There are two types of
 * error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`)
 * and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors
 * indicate the current error condition, and will automatically clear when the
 * error condition is resolved. Sticky errors are only cleared by sending
 * `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.
 */
typedef struct
{
    unsigned inputvoltagelow : 1;          //!< Set if input voltage is too low
    unsigned inputvoltagehigh : 1;         //!< Set if input voltage is too high
    unsigned matsensorunderrng : 1;        //!< Set if manifold air temperature sensor is out of range low
    unsigned matsensoroverrng : 1;         //!< Set if manifold air temperature sensor is out of range high
    unsigned cht1sensorunderrng : 1;       //!< Set if first cylinder head temperature sensor is out of range low
    unsigned cht1sensoroverrng : 1;        //!< Set if first cylinder head temperature sensor is out of range high
    unsigned cht2sensorunderrng : 1;       //!< Set if second cylinder head temperature sensor is out of range low
    unsigned cht2sensoroverrng : 1;        //!< Set if second cylinder head temperature sensor is out of range high
    unsigned mapsensorunderrng : 1;        //!< Set if manifold air pressure sensor is out of range low
    unsigned mapsensoroverrng : 1;         //!< Set if manifold air pressure sensor is out of range high
    unsigned fuelpsensorunderrng : 1;      //!< Set if fuel pressure sensor is out of range low
    unsigned fuelpsensoroverrng : 1;       //!< Set if fuel pressure sensor is out of range high
    unsigned analogtpssensorunderrng : 1;  //!< Set if analog TPS sensor is out of range low
    unsigned analogtpssensoroverrng : 1;   //!< Set if analog TPS is out of range high
    unsigned cputemplow : 1;               //!< Set if CPU temperature is too low
    unsigned cputemphigh : 1;              //!< Set if CPU temperature is too high
    unsigned sparetempsensorunderrng : 1;  //!< Set if spare temperature sensor is out of range low
    unsigned sparetempsensoroverrng : 1;   //!< Set if spare temperature sensor is out of range high
    unsigned barosensorunderrng : 1;       //!< Set if barometric air pressure sensor is out of range low
    unsigned barosensoroverrng : 1;        //!< Set if barometric air pressure sensor is out of range high
    unsigned crank1error : 3;              //!< Enumerated errors from crank sense1, clear if no errors
    unsigned crank2error : 3;              //!< Enumerated errors from crank sense2, clear if no errors
    unsigned cht1low : 1;                  //!< Set if the first cylinder head temperature is too low, the head is overcooled
    unsigned cht1high : 1;                 //!< Set if the first cylinder head temperature is too high, the head is overheating
    unsigned cht2low : 1;                  //!< Set if the second cylinder head temperature is too low, the head is overcooled
    unsigned cht2high : 1;                 //!< Set if the second cylinder head temperature is too high, the head is overheating
    unsigned fuelplow : 1;                 //!< Set if the fuel pressure is too low
    unsigned fuelphigh : 1;                //!< Set if the fuel pressure is too high
    unsigned hardoverspeed : 1;            //!< Set if the engine RPM exceeded the hard rev limit
    unsigned softoverspeed : 1;            //!< Set if the engine RPM exceeded the soft rev limit
    unsigned parameterhash : 1;            //!< Set if the nonvolatile parameters did not hash to the expected value
    unsigned voltage12low : 1;             //!< Set if 12V voltage is too low
    unsigned voltage12high : 1;            //!< Set if 12V voltage is too high
    unsigned inputcurrentlow : 1;          //!< Set if the input current is too low
    unsigned inputcurrenthigh : 1;         //!< Set if the input current is too high
    unsigned current12low : 1;             //!< Set if the current of the 12 volt rail is too low
    unsigned current12high : 1;            //!< Set if the current of the 12 volt rail too high
    unsigned power6fault : 1;              //!< Set if the 6 volt power supply is faulted
    unsigned injector1fault : 1;           //!< Set if the first injector has a fault
    unsigned injector2fault : 1;           //!< Set if the second injector has a fault
    unsigned userStorageError : 1;         //!< Set if there is a user storage error
    unsigned analogbarosensorunderrng : 1; //!< Set if the analog barometric air pressure sensor is out of range low
    unsigned analogbarosensoroverrng : 1;  //!< Set if the analog barometric air pressure sensor is out of range high
    unsigned oatsensorunderrng : 1;        //!< Set if barometric air pressure sensor is out of range low
    unsigned oatsensoroverrng : 1;         //!< Set if barometric air pressure sensor is out of range high
    unsigned canThrottleMissing : 1;       //!< Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    unsigned canThrottleError : 1;         //!< Set if the CAN throttle servo has an error bit set
    unsigned canCooling1Missing : 1;       //!< Set if the cooling output 1 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    unsigned canCooling1Error : 1;         //!< Set if the CAN cooling 1 servo has an error bit set
    unsigned maxstartthrottle : 1;         //!< Set if throttle was greater than the maximum start throttle while the engine was cranking for start. In that case spark and injector outputs are suspended.
    unsigned maplow : 1;                   //!< Set if manifold air pressure sensor is low compared to the estimate
    unsigned maphigh : 1;                  //!< Set if manifold air pressure sensor is high compared to the estimate
    unsigned tpsmissing : 1;               //!< Set if there is no throttle position source, but the system is configured for one.
    unsigned tpserror : 1;                 //!< Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle).
    unsigned sdcarderror : 1;              //!< Set if an error occurred with the SD card recording. This error will only assert after the SD card has been successfully detected.
    unsigned reserved1 : 1;                //!< Reserved for future expansion
    unsigned canCooling2Missing : 1;       //!< Set if the cooling output 2 is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    unsigned canCooling2Error : 1;         //!< Set if the CAN cooling 2 servo has an error bit set
    unsigned maintenanceNeeded : 1;        //!< If set a maintenance item has been triggered, see the maintenance packet for details.
    unsigned testModeActive : 1;           //!< If set the EFI is in test mode or is autocalibrating the throttle servo, refer to packet EFI_PKT_TESTMODE
}efiErrors_t;

//! Create the efiErrors packet
void encodeefiErrorsPkt(efiPacket_t* pkt, const efiErrors_t* user, uint32_t id);

//! Decode the efiErrors packet
int decodeefiErrorsPkt(const efiPacket_t* pkt, efiErrors_t* user);

//! Encode a efiErrors_t into a byte array
void encodeefiErrors_t(uint8_t* data, int* bytecount, const efiErrors_t* user);

//! Decode a efiErrors_t from a byte array
int decodeefiErrors_t(const uint8_t* data, int* bytecount, efiErrors_t* user);

//! return the minimum encoded length for the efiErrors packet
#define getefiErrorsMinDataLength() (8)

//! return the maximum encoded length for the efiErrors packet
#define getefiErrorsMaxDataLength() (8)

/*!
 * Error information, output at the slow telemetry rate. There are two types of
 * error information: dynamic errors (reported by `EFI_PKT_TELEMETRYERRORS`)
 * and sticky errors (reported by `EFI_PKT_STICKY_ERRORS`). Dynamic errors
 * indicate the current error condition, and will automatically clear when the
 * error condition is resolved. Sticky errors are only cleared by sending
 * `EFI_PKT_STICKY_ERRORS` with bits cleared where desired.
 */
typedef struct
{
    unsigned inputvoltagelow : 1;          //!< Set if input voltage is too low
    unsigned inputvoltagehigh : 1;         //!< Set if input voltage is too high
    unsigned matsensorunderrng : 1;        //!< Set if manifold air temperature sensor is out of range low
    unsigned matsensoroverrng : 1;         //!< Set if manifold air temperature sensor is out of range high
    unsigned cht1sensorunderrng : 1;       //!< Set if first cylinder head temperature sensor is out of range low
    unsigned cht1sensoroverrng : 1;        //!< Set if first cylinder head temperature sensor is out of range high
    unsigned cht2sensorunderrng : 1;       //!< Set if second cylinder head temperature sensor is out of range low
    unsigned cht2sensoroverrng : 1;        //!< Set if second cylinder head temperature sensor is out of range high
    unsigned mapsensorunderrng : 1;        //!< Set if manifold air pressure sensor is out of range low
    unsigned mapsensoroverrng : 1;         //!< Set if manifold air pressure sensor is out of range high
    unsigned fuelpsensorunderrng : 1;      //!< Set if fuel pressure sensor is out of range low
    unsigned fuelpsensoroverrng : 1;       //!< Set if fuel pressure sensor is out of range high
    unsigned analogtpssensorunderrng : 1;  //!< Set if analog TPS sensor is out of range low
    unsigned analogtpssensoroverrng : 1;   //!< Set if analog TPS is out of range high
    unsigned cputemplow : 1;               //!< Set if CPU temperature is too low
    unsigned cputemphigh : 1;              //!< Set if CPU temperature is too high
    unsigned sparetempsensorunderrng : 1;  //!< Set if spare temperature sensor is out of range low
    unsigned sparetempsensoroverrng : 1;   //!< Set if spare temperature sensor is out of range high
    unsigned barosensorunderrng : 1;       //!< Set if barometric air pressure sensor is out of range low
    unsigned barosensoroverrng : 1;        //!< Set if barometric air pressure sensor is out of range high
    unsigned oatsensorunderrng : 1;        //!< Set if barometric air pressure sensor is out of range low
    unsigned oatsensoroverrng : 1;         //!< Set if barometric air pressure sensor is out of range high
    unsigned crank1bounce : 1;             //!< Set if the first crank sensor detected a signal bounce (crank sense event too fast)
    unsigned crank2bounce : 1;             //!< Set if the second crank sensor detected a signal bounce (crank sense event too fast)
    unsigned crank1late : 1;               //!< Set if the first crank sensor is late in firing relative to the second crank sensor.
    unsigned crank2late : 1;               //!< Set if the second crank sensor is late in firing relative to the first crank sensor.
    unsigned cht1low : 1;                  //!< Set if the first cylinder head temperature is too low, the head is overcooled
    unsigned cht1high : 1;                 //!< Set if the first cylinder head temperature is too high, the head is overheating
    unsigned cht2low : 1;                  //!< Set if the second cylinder head temperature is too low, the head is overcooled
    unsigned cht2high : 1;                 //!< Set if the second cylinder head temperature is too high, the head is overheating
    unsigned fuelplow : 1;                 //!< Set if the fuel pressure is too low
    unsigned fuelphigh : 1;                //!< Set if the fuel pressure is too high
    unsigned hardoverspeed : 1;            //!< Set if the engine RPM exceeded the hard rev limit
    unsigned softoverspeed : 1;            //!< Set if the engine RPM exceeded the soft rev limit
    unsigned parameterhash : 1;            //!< Set if the nonvolatile parameters did not hash to the expected value
    unsigned voltage12low : 1;             //!< Set if 12V voltage is too low
    unsigned voltage12high : 1;            //!< Set if 12V voltage is too high
    unsigned inputcurrentlow : 1;          //!< Set if the input current is too low
    unsigned inputcurrenthigh : 1;         //!< Set if the input current is too high
    unsigned current12low : 1;             //!< Set if the current of the 12 volt rail is too low
    unsigned current12high : 1;            //!< Set if the current of the 12 volt rail too high
    unsigned power6fault : 1;              //!< Set if the 6 volt power supply is faulted
    unsigned injector1fault : 1;           //!< Set if the first injector has a fault
    unsigned injector2fault : 1;           //!< Set if the second injector has a fault
    unsigned analogbarosensorunderrng : 1; //!< Set if the analog barometric air pressure sensor is out of range low
    unsigned analogbarosensoroverrng : 1;  //!< Set if the analog barometric air pressure sensor is out of range high
    unsigned crank1missededge : 1;         //!< Set if the first crank sensor missed an edge of the crank sense signal (i.e. two edges of the same type (rising or falling) in a row)
    unsigned crank2missededge : 1;         //!< Set if the second crank sensor missed an edge of the crank sense signal (i.e. two edges of the same type (rising or falling) in a row)
    unsigned canThrottleMissing : 1;       //!< Set if the throttle is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    unsigned canThrottleError : 1;         //!< Set if the CAN throttle servo has an error bit set
    unsigned canCoolingMissing : 1;        //!< Set if the cooling output is configured to use a CAN servo, but the CAN servo has not been detected on the bus
    unsigned canCoolingError : 1;          //!< Set if the CAN cooling servo has an error bit set
    unsigned maplow : 1;                   //!< Set if manifold air pressure sensor is low compared to the estimate
    unsigned maphigh : 1;                  //!< Set if manifold air pressure sensor is high compared to the estimate
    unsigned tpsmissing : 1;               //!< Set if there is no throttle position source, but the system is configured for one.
    unsigned tpserror : 1;                 //!< Set if there is a problem with the throttle position sensor: either it is invalid (none connected to analog or PWM), or it disagrees with the throttle output (if efi drives throttle).
    unsigned maintenanceNeeded : 1;        //!< If set a maintenance item has been triggered, see the maintenance packet for details.
    unsigned testModeActive : 1;           //!< If set the EFI is in test mode, refer to packet EFI_PKT_TESTMODE
}efiErrorsapi4_t;

//! Decode the efiErrorsapi4 packet
int decodeefiErrorsapi4Pkt(const efiPacket_t* pkt, efiErrorsapi4_t* user);

//! Decode a efiErrorsapi4_t from a byte array
int decodeefiErrorsapi4_t(const uint8_t* data, int* bytecount, efiErrorsapi4_t* user);

//! return the minimum encoded length for the efiErrorsapi4 packet
#define getefiErrorsapi4MinDataLength() (8)

//! return the maximum encoded length for the efiErrorsapi4 packet
#define getefiErrorsapi4MaxDataLength() (8)

/*!
 * Information about engine wear, output at the slow telemetry rate.
 */
typedef struct
{
    uint32_t hobbs;        //!< Total engine run time in seconds
    uint32_t revcount;     //!< Total number of revolutions the engine has made
    uint32_t hotTime;      //!< Seconds the engine has spent running above the CHT limit
    uint32_t highLoadTime; //!< Seconds the engine has spent running at high load (throttle greater than 80%).
    float    peakCHT;      //!< Highest head temperature observed while the engine was running
    uint16_t numStarts;    //!< Number of times the engine has started
}efiEngineWear_t;

//! Create the efiEngineWear packet
void encodeefiEngineWearPkt(efiPacket_t* pkt, const efiEngineWear_t* user);

//! Decode the efiEngineWear packet
int decodeefiEngineWearPkt(const efiPacket_t* pkt, efiEngineWear_t* user);

//! Encode a efiEngineWear_t into a byte array
void encodeefiEngineWear_t(uint8_t* data, int* bytecount, const efiEngineWear_t* user);

//! Decode a efiEngineWear_t from a byte array
int decodeefiEngineWear_t(const uint8_t* data, int* bytecount, efiEngineWear_t* user);

//! return the packet ID for the efiEngineWear packet
#define getefiEngineWearPktID() (EFI_PKT_ENGINEWEAR)

//! return the minimum encoded length for the efiEngineWear packet
#define getefiEngineWearMinDataLength() (16)

//! return the maximum encoded length for the efiEngineWear packet
#define getefiEngineWearMaxDataLength() (16)

/*!
 * Short information about engine wear, output at the slow telemetry rate over
 * the CAN bus.
 */
typedef struct
{
    uint32_t hobbs;    //!< Total engine run time in seconds
    uint32_t revcount; //!< Total number of revolutions the engine has made
}efiEngineWearShort_t;

//! Create the efiEngineWearShort packet from parameters
void encodeefiEngineWearShortPkt(efiPacket_t* pkt, uint32_t hobbs, uint32_t revcount);

//! Decode the efiEngineWearShort packet to parameters
int decodeefiEngineWearShortPkt(const efiPacket_t* pkt, uint32_t* hobbs, uint32_t* revcount);

//! Encode a efiEngineWearShort_t into a byte array
void encodeefiEngineWearShort_t(uint8_t* data, int* bytecount, const efiEngineWearShort_t* user);

//! Decode a efiEngineWearShort_t from a byte array
int decodeefiEngineWearShort_t(const uint8_t* data, int* bytecount, efiEngineWearShort_t* user);

//! return the packet ID for the efiEngineWearShort packet
#define getefiEngineWearShortPktID() (EFI_PKT_ENGINEWEAR)

//! return the minimum encoded length for the efiEngineWearShort packet
#define getefiEngineWearShortMinDataLength() (8)

//! return the maximum encoded length for the efiEngineWearShort packet
#define getefiEngineWearShortMaxDataLength() (8)

/*!
 * Enumeration of CAN bus errors
 */
typedef enum
{
    EFI_CANERR_NONE, //!< No error
    EFI_CANERR_STUFF,//!< Bit stuff error (more than 5 consecutive bits the same)
    EFI_CANERR_FORM, //!< Form error
    EFI_CANERR_ACK,  //!< Frame acknowledgement error
    EFI_CANERR_BITREC,//!< Bit recessive error
    EFI_CANERR_BITDOM,//!< Bit dominant error
    EFI_CANERR_CRC,  //!< CRC error
    EFI_CANERR_SOFT  //!< Software error
} efiCANerr;

//! \return the title of a 'efiCANerr' enum entry, based on its value
const char* efiCANerr_EnumTitle(int value);

/*!
 * Information about communications performance and configuration, output at
 * the slow telemetry rate.
 */
typedef struct
{
    uint8_t   canREC;                        //!< The receive error counter from the CAN bus hardware
    uint8_t   canTEC;                        //!< The least significant 8 bits of the transmit error counter from the CAN bus hardware
    efiCANerr lastCANerr;                    //!< Cause of the last CAN error
    unsigned  canBOF : 1;                    //!< This bit is set when the CAN hardware enters the bus-off state. The bus-off state is entered on canTEC overflow, greater than 255
    unsigned  canEPVF : 1;                   //!< This bit is set when the CAN error passive limit has been reached (canREC or canTEC greater than 127).
    unsigned  canEWGF : 1;                   //!< This bit is set when the CAN warning limit has been reached (canREC or canTEC greater than 95).
    unsigned  canDisableNativeInput : 1;     //!< This bit echos the CAN configuration bit `disableNativeInput`. If set then native CAN packets cannot be sent to this EFI (except possibly using the broadcast ID).
    unsigned  canDisableNativeOutput : 1;    //!< This bit echos the CAN configuration bit `disableNativeOutput`. If set then native CAN packets will not be sent by this EFI.
    unsigned  canDisableNativeBroadcast : 1; //!< This bit echos the CAN configuration bit `disableNativeBroadcast`. If set then native CAN packets cannot be sent to this EFI using the broadcast ID.
    unsigned  canForcePacketOverCAN : 1;     //!< This bit echos the CAN configuration bit `forcePacketOverCAN`. If set any CAN packets sent to this EFI must use the packet-over-CAN schema, otherwise they will be ignored.
    unsigned  canCmdAndTmOnly : 1;           //!< This bit echos the CAN configuration bit `cmdAndTmOnly`. If set then only commands and telemetry are supported on the CAN bus (configuration request or change will be ignored).
    unsigned  canTxFull : 1;                 //!< Set if the transmit buffer of the CAN interface is full.
    uint8_t   canPacketFailureCnt;           //!< Number of packets received over the CAN bus which were invalid (bad CRC) since the last time this packet was output
    unsigned  uartTxFull : 1;                //!< Set if the transmit buffer of the UART interface is full.
    uint8_t   uartPacketFailureCnt;          //!< Number of packets received over the UART which were invalid (bad CRC) since the last time this packet was output
    unsigned  usbTxFull : 1;                 //!< Set if the transmit buffer of the USB interface is full.
    uint8_t   usbPacketFailureCnt;           //!< Number of packets received over the USB which were invalid (bad CRC) since the last time this packet was output
    uint8_t   txCANPacketCounter;            //!< Free running counter of packets transmitted over CAN (not counting this packet).
    uint8_t   txPacketCounter;               //!< Free running counter of packets transmitted over the UART or USB (not counting this packet).
    uint8_t   rxPacketCounter;               //!< Free running counter for received packets (from any source).
}efiTelemetryComms_t;

//! Create the efiTelemetryComms packet
void encodeefiTelemetryCommsPkt(efiPacket_t* pkt, const efiTelemetryComms_t* user);

//! Decode the efiTelemetryComms packet
int decodeefiTelemetryCommsPkt(const efiPacket_t* pkt, efiTelemetryComms_t* user);

//! Encode a efiTelemetryComms_t into a byte array
void encodeefiTelemetryComms_t(uint8_t* data, int* bytecount, const efiTelemetryComms_t* user);

//! Decode a efiTelemetryComms_t from a byte array
int decodeefiTelemetryComms_t(const uint8_t* data, int* bytecount, efiTelemetryComms_t* user);

//! return the packet ID for the efiTelemetryComms packet
#define getefiTelemetryCommsPktID() (EFI_PKT_TELEMETRYCOMMS)

//! return the minimum encoded length for the efiTelemetryComms packet
#define getefiTelemetryCommsMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryComms packet
#define getefiTelemetryCommsMaxDataLength() (8)

/*!
 * Telemetry about the SD card. This packet is only sent if the SD card is
 * present. Presence of the SD card is always visible in the [CPU
 * telemetry](#EFI_PKT_TELEMETRYCPU) packet.
 */
typedef struct
{
    efiSDStatus sdstatus;      //!< Status of the SD card
    uint8_t     errorCount;    //!< The number of SD card errors experienced since bootup.
    uint32_t    sequence;      //!< If `sdstatus` is `EFI_SD_READY` this is the number of 512-byte blocks that have been written to the card since the system booted up. If `sdstatus` is `EFI_SD_SETTINGUP` this gives the progress of the directory setup in tenths of a percent. If `sdstatus` is `EFI_SD_TRANSFER` this gives the progress of the transfer in tenths of a percent. In all other states this value is zero.
    uint32_t    numDataBlocks; //!< The total number of data blocks that have been written to the card, this does not include the journal blocks.
}efiTelemetrySDCard_t;

//! Create the efiTelemetrySDCard packet
void encodeefiTelemetrySDCardPkt(efiPacket_t* pkt, const efiTelemetrySDCard_t* user);

//! Decode the efiTelemetrySDCard packet
int decodeefiTelemetrySDCardPkt(const efiPacket_t* pkt, efiTelemetrySDCard_t* user);

//! Encode a efiTelemetrySDCard_t into a byte array
void encodeefiTelemetrySDCard_t(uint8_t* data, int* bytecount, const efiTelemetrySDCard_t* user);

//! Decode a efiTelemetrySDCard_t from a byte array
int decodeefiTelemetrySDCard_t(const uint8_t* data, int* bytecount, efiTelemetrySDCard_t* user);

//! return the packet ID for the efiTelemetrySDCard packet
#define getefiTelemetrySDCardPktID() (EFI_PKT_TELEMETRYSDCARD)

//! return the minimum encoded length for the efiTelemetrySDCard packet
#define getefiTelemetrySDCardMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetrySDCard packet
#define getefiTelemetrySDCardMaxDataLength() (8)

/*!
 * Enable/disable command. Use this packet to shut down the engine by clearing
 * `userEnable` or to selectively disable the first or second spark output by
 * clearing `spark1Enable` or `spark2Enable`. The EFI will boot up with all the
 * enables set. The current enable status is visible in the [fast
 * telemetry](#EFI_PKT_TELEMETRYFAST) packet.
 */
typedef struct
{
    uint8_t  ioEnable;     //!< Global enable based on physical input. This enable cannot be changed by this packet.
    uint8_t  userEnable;   //!< User global enable. Set to zero to disable the engine.
    uint8_t  spark1Enable; //!< User enable for spark1. Set to zero to disable spark 1.
    uint8_t  spark2Enable; //!< User enable for spark2. Set to zero to disable spark 2.
    uint8_t  spark3Enable; //!< User enable for spark3. Set to zero to disable spark 3.
    uint8_t  crankEnable;  //!< If set command the GCU system to crank for start, if clear command the GCU system to stop cranking. Cranking status will be visible in the GCU telemetry packet.
    uint16_t oilInjPrime;  //!< Number of oil injection pulses to deliver to prime the system. This only applies if an injector is configured for oil injection. Use zero to stop the priming operation. Priming will be ignored if the system is not enabled. Priming will be stopped if the engine starts running.
}efiEnable_t;

//! Create the efiEnable packet
void encodeefiEnablePkt(efiPacket_t* pkt, const efiEnable_t* user);

//! Decode the efiEnable packet
int decodeefiEnablePkt(const efiPacket_t* pkt, efiEnable_t* user);

//! return the packet ID for the efiEnable packet
#define getefiEnablePktID() (EFI_PKT_ENABLE)

//! return the minimum encoded length for the efiEnable packet
#define getefiEnableMinDataLength() (1)

//! return the maximum encoded length for the efiEnable packet
#define getefiEnableMaxDataLength() (2)

//! Create the efiUserThrottle packet from parameters
void encodeefiUserThrottlePkt(efiPacket_t* pkt, float throttle);

//! Decode the efiUserThrottle packet to parameters
int decodeefiUserThrottlePkt(const efiPacket_t* pkt, float* throttle);

//! return the packet ID for the efiUserThrottle packet
#define getefiUserThrottlePktID() (EFI_PKT_USERTHROTTLE)

//! return the minimum encoded length for the efiUserThrottle packet
#define getefiUserThrottleMinDataLength() (1)

//! return the maximum encoded length for the efiUserThrottle packet
#define getefiUserThrottleMaxDataLength() (1)

//! Create the efiRPMCommand packet from parameters
void encodeefiRPMCommandPkt(efiPacket_t* pkt, float rpmcmd);

//! Decode the efiRPMCommand packet to parameters
int decodeefiRPMCommandPkt(const efiPacket_t* pkt, float* rpmcmd);

//! return the packet ID for the efiRPMCommand packet
#define getefiRPMCommandPktID() (EFI_PKT_RPMCOMMAND)

//! return the minimum encoded length for the efiRPMCommand packet
#define getefiRPMCommandMinDataLength() (2)

//! return the maximum encoded length for the efiRPMCommand packet
#define getefiRPMCommandMaxDataLength() (2)

/*!
 * Use this packet to request one or more configuration and status packets from
 * the EFI. After receiving this packet the EFI will transmit a response packet
 * for every bit which is set. If the EFI is configured to hide configuration
 * data the response packet(s) may be a [nack](#EFI_PKT_NACK) rather than the
 * desired packet(s).
 */
typedef struct
{
    efiConfigBits_t bits; //!< One bit for every configuration packet
    uint8_t         api;  //!< Application programming interface number of the protocol doing the requesting. Changes to the ICD will increment this number.. Field is encoded constant.
}efiConfigRequest_t;

//! Create the efiConfigRequest packet from parameters
void encodeefiConfigRequestPkt(efiPacket_t* pkt, const efiConfigBits_t* bits);

//! Decode the efiConfigRequest packet to parameters
int decodeefiConfigRequestPkt(const efiPacket_t* pkt, efiConfigBits_t* bits, uint8_t* api);

//! return the packet ID for the efiConfigRequest packet
#define getefiConfigRequestPktID() (EFI_PKT_REQUEST)

//! return the minimum encoded length for the efiConfigRequest packet
#define getefiConfigRequestMinDataLength() (13)

//! return the maximum encoded length for the efiConfigRequest packet
#define getefiConfigRequestMaxDataLength() (13)

//! Decode the efismallConfigRequest packet
int decodeefismallConfigRequestPkt(const efiPacket_t* pkt, efiConfigBits_t* user);

//! return the packet ID for the efismallConfigRequest packet
#define getefismallConfigRequestPktID() (EFI_PKT_REQUEST)

//! return the minimum encoded length for the efismallConfigRequest packet
#define getefismallConfigRequestMinDataLength() (8)

//! return the maximum encoded length for the efismallConfigRequest packet
#define getefismallConfigRequestMaxDataLength() (12)

/*!
 * Send this packet to unlock the EFI so configuration data can be changed (or
 * viewed if hidden). For password locked configurations, if the password is
 * lost you can use the string 'CLEAR ALL DATA'. This will allow the EFI to be
 * password unlocked, but will also reset the EFI to defaults, clearing all
 * existing configuration data from both user and factory storage. Note that
 * the 'CLEAR ALL DATA' password cannot be used if the engine is running, in
 * which case a [nack](#EFI_PKT_NACK) will be generated. After receiving this
 * packet the EFI will send this packet back to the user, to report the current
 * lock status. Anytime the EFI sends this packet the password field will be
 * empty. The lock status is always visible in the [cpu
 * telemetry](#EFI_PKT_TELEMETRYCPU) packet. The cpu telemetry packet also
 * indicates if unlocking will require a password.
 * 
 * This packet can be used to lock the EFI by requesting an unlock level which
 * is lower than the current level. In that case the password is not needed.
 */
typedef struct
{
    unsigned unlockLevel : 2; //!< For packets going to the EFI this is the desired unlock level. For packets coming from the EFI this the current unlock level.
    char     password[32];    //!< Password used to unlock. This password must match the password used in the lock configuration. If the password is incorrect the EFI will respond with nack. When the EFI sends this packet the password field will be empty.
}efiUnlock_t;

//! Create the efiUnlock packet
void encodeefiUnlockPkt(efiPacket_t* pkt, const efiUnlock_t* user);

//! Decode the efiUnlock packet
int decodeefiUnlockPkt(const efiPacket_t* pkt, efiUnlock_t* user);

//! return the packet ID for the efiUnlock packet
#define getefiUnlockPktID() (EFI_PKT_UNLOCK)

//! return the minimum encoded length for the efiUnlock packet
#define getefiUnlockMinDataLength() (2)

//! return the maximum encoded length for the efiUnlock packet
#define getefiUnlockMaxDataLength() (33)

/*!
 * Packet used to command an EFI reset. This is primarily used to reset the EFI
 * into bootloader mode for firmware update. This packet is also used for
 * software development testing and to test the behavior of the engine during
 * EFI reset. This packet will not be obeyed unless the unlock level is
 * [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels), *or* the engine is not
 * running and the reset requested is `bootloaderReset`.
 */
typedef struct
{
    unsigned watchdogReset : 1;          //!< If set perform a reset by entering an infinite loop so that the watchdog triggers a reset.
    unsigned softwareReset : 1;          //!< If set perform a software reset
    unsigned invalidAddressReset : 1;    //!< If set perform a memory write to an invalid address in order to trigger a memory exception reset
    unsigned unalignedAddressReset : 1;  //!< If set perform a memory write to an unaligned address in order to trigger a unaligned exception reset
    unsigned divideByZeroReset : 1;      //!< If set perform a integer divide by zero in order to trigger an exception reset
    unsigned floatDivideByZeroReset : 1; //!< If set perform a floating point divide by zero in order to trigger an floating point interrupt reset
    unsigned bootloaderReset : 1;        //!< If set perform a reset to enter into bootloader mode for firmware update.
    unsigned safemodereset : 1;          //!< If set perform a reset that results in safe mode
    uint32_t extraVerification;          //!< This field must be set to `0xABCD8765` or the packet will be ignored. Field is encoded constant.
}efiResetCmd_t;

//! Create the efiResetCmd packet
void encodeefiResetCmdPkt(efiPacket_t* pkt, const efiResetCmd_t* user);

//! Decode the efiResetCmd packet
int decodeefiResetCmdPkt(const efiPacket_t* pkt, efiResetCmd_t* user);

//! return the packet ID for the efiResetCmd packet
#define getefiResetCmdPktID() (EFI_PKT_RESET)

//! return the minimum encoded length for the efiResetCmd packet
#define getefiResetCmdMinDataLength() (5)

//! return the maximum encoded length for the efiResetCmd packet
#define getefiResetCmdMaxDataLength() (5)

/*!
 * Enumeration of storage commands
 */
typedef enum
{
    efiStorageClearAll,      //!< Use this command to clear user and factory settings, causing the EFI to revert to hard-coded default settings. This will trigger a send of all configuration data.
    efiStorageRestoreFactory,//!< Use this command to clear any user settings, causing the EFI to revert to any stored settings in the factory storage space. This will trigger a send of all configuration data.
    efiStorageSaveFactory,   //!< Use this command to save the current settings to factory storage. This will also clear the user storage, except for the engine wear information.
    efiStorageSetupSD,       //!< Use this command to setup the SD card, which lays out the root directory filesystem.
    efiStorageFormatSD,      //!< Use this command to format the SD card.
    efiStorageEraseSD,       //!< Erase the SD card.
    efiStorageTransferSD,    //!< Transfer a record from the SD card.
    efiStorageStopTransferSD //!< Stop Transferring a record from the SD card.
} efiStorageCmds;

/*!
 * Commands for manipulating storage. The EFI maintains two storage locations
 * for non-volatile configuration data. The user storage data is always updated
 * whenever the configuration is changed. Any configuration data which is not
 * present in the user storage will be supplied by the factory storage when the
 * EFI starts up. Factory storage is intended to hold the configuration as it
 * left the factory, providing a way for users to revert to the original
 * configuration. Factory configuration data is stored in on-chip flash, and
 * will take several seconds to change, therefore factory storage cannot be
 * changed while the engine is running.
 * 
 * Storage commands that affect the EEPROM or flash (i.e. non-sdcard commands)
 * will not be obeyed unless the unlock level is
 * [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels). In addition any command
 * which changes the factory storage will not be obeyed if the engine is
 * running. Note that clearing the storage will not clear the engine wear
 * information. If this command alters configuration data the EFI will send the
 * configuration packets.
 * 
 * The storage command is also used with the SD card. SD card storage commands
 * can be sent when the engine is running, and do not require the system to be
 * unlocked. To read a record from the SD card send the command
 * `efiStorageTransferSD` with the record number to be read. The progress of
 * the SD transfer can be monitored with the SD card telemetry packet. When the
 * transfer is complete this packet will be sent from the EFI with the command
 * `efiStorageStopTransferSD` to indicate the transfer is complete. You can
 * also stop the transfer by sending the command `efiStorageStopTransferSD`.
 */
typedef struct
{
    efiStorageCmds command;  //!< The storage command to execute
    uint8_t        aborted;  //!< If the command is `efiStorageStopTransferSD` this flag will be set if the transfer was stopped because of a problem with the SD card.
    uint16_t       sdrecord; //!< The record identifier for the `efiStorageTransferSD` command. This must be a valid record in the SD card journal.
}efiStorageLong_t;

//! Create the efiStorageLong packet from parameters
void encodeefiStorageLongPkt(efiPacket_t* pkt, efiStorageCmds command, uint8_t aborted, uint16_t sdrecord);

//! Decode the efiStorageLong packet to parameters
int decodeefiStorageLongPkt(const efiPacket_t* pkt, efiStorageCmds* command, uint8_t* aborted, uint16_t* sdrecord);

//! return the packet ID for the efiStorageLong packet
#define getefiStorageLongPktID() (EFI_PKT_STORAGE)

//! return the minimum encoded length for the efiStorageLong packet
#define getefiStorageLongMinDataLength() (4)

//! return the maximum encoded length for the efiStorageLong packet
#define getefiStorageLongMaxDataLength() (4)

//! Create the efiStorage packet from parameters
void encodeefiStoragePkt(efiPacket_t* pkt, efiStorageCmds command);

//! Decode the efiStorage packet to parameters
int decodeefiStoragePkt(const efiPacket_t* pkt, efiStorageCmds* command);

//! return the packet ID for the efiStorage packet
#define getefiStoragePktID() (EFI_PKT_STORAGE)

//! return the minimum encoded length for the efiStorage packet
#define getefiStorageMinDataLength() (1)

//! return the maximum encoded length for the efiStorage packet
#define getefiStorageMaxDataLength() (1)

/*!
 * Use this packet to set or request the total fuel and oil used. The fuel and
 * oil totalizers start at zero when the EFI boots up and increases as the
 * engine runs. The fuel used is also reported in the fuel telemetry packet.
 * The oil used is also reported in the oil injection telemetry packet. Send
 * this packet with zero length to request the fuel and oil used.
 */
typedef struct
{
    float fuelConsumption; //!< Fuel consumption in grams since the system turned on.
    float oilConsumption;  //!< Oil consumption in grams since the system turned on.
}efiFuelUsed_t;

//! Create the efiFuelUsed packet from parameters
void encodeefiFuelUsedPkt(efiPacket_t* pkt, float fuelConsumption, float oilConsumption);

//! Decode the efiFuelUsed packet to parameters
int decodeefiFuelUsedPkt(const efiPacket_t* pkt, float* fuelConsumption, float* oilConsumption);

//! return the packet ID for the efiFuelUsed packet
#define getefiFuelUsedPktID() (EFI_PKT_FUELUSED)

//! return the minimum encoded length for the efiFuelUsed packet
#define getefiFuelUsedMinDataLength() (2)

//! return the maximum encoded length for the efiFuelUsed packet
#define getefiFuelUsedMaxDataLength() (4)

/*!
 * List of maintenance item status
 */
typedef struct
{
    unsigned      triggered : 1;           //!< This bit is set if the maintenance item has elapsed.
    uint8_t       index;                   //!< The index number of this maintenance item status. the index number matches the index from the maintenance schedule configuration.
    efiDateTime_t servicetime;             //!< The date and time when this maintenance item was last serviced. This field can only be changed with the `DoMaintenance` command
    uint32_t      lastdone;                //!< The last time this maintenance item was done, zero if never.
    char          name[maxNameCharacters]; //!< Name of the person who did the most recent maintenance.
}efiMaintenanceItemStatus_t;

/*!
 * Set or request the maintenance status. To request the status send this
 * packet with zero length. If unlocked you can send this packet to overwrite
 * the maintenance status (except for `engineSerial`). To change the
 * `engineSerial` `setEngineSerial` must be set and IntelliJect must be
 * unlocked. Typically you do not send this packet to change the maintenance
 * status, instead you use the PerformMaintenance packet for that purpose.
 */
typedef struct
{
    unsigned                   domaintenance : 1;                          //!< This bit must be clear, if not clear than this packet is interpreted as a PerformMaintenance packet. This bit will never be set when this packet comes from IntelliJect.. Field is encoded constant.
    unsigned                   setEngineSerial : 1;                        //!< Set this bit when sending to IntelliJect to change the engine serial number. This change can only be performed if IntelliJect is unlocked. This bit will never be set when this packet comes from IntelliJect.
    uint8_t                    numItems;                                   //!< The number of maintenance status items in this packet
    uint32_t                   engineSerial;                               //!< The engine serial number. This can only be changed if IntelliJect is unlocked and `setEngineSerial` is set.
    efiMaintenanceItemStatus_t MaintenanceItemStatus[maxMaintenanceItems]; //!< List of maintenance item status
}efiMaintenanceStatus_t;

//! Encode a efiMaintenanceItemStatus_t into a byte array
void encodeefiMaintenanceItemStatus_t(uint8_t* data, int* bytecount, const efiMaintenanceItemStatus_t* user);

//! Decode a efiMaintenanceItemStatus_t from a byte array
int decodeefiMaintenanceItemStatus_t(const uint8_t* data, int* bytecount, efiMaintenanceItemStatus_t* user);

//! Create the efiMaintenanceStatus packet
void encodeefiMaintenanceStatusPkt(efiPacket_t* pkt, const efiMaintenanceStatus_t* user);

//! Decode the efiMaintenanceStatus packet
int decodeefiMaintenanceStatusPkt(const efiPacket_t* pkt, efiMaintenanceStatus_t* user);

//! return the packet ID for the efiMaintenanceStatus packet
#define getefiMaintenanceStatusPktID() (EFI_PKT_MAINTENANCESTATUS)

//! return the minimum encoded length for the efiMaintenanceStatus packet
#define getefiMaintenanceStatusMinDataLength() (5)

//! return the maximum encoded length for the efiMaintenanceStatus packet
#define getefiMaintenanceStatusMaxDataLength() (5+maxMaintenanceItems*(maxNameCharacters+10))

/*!
 * Send this packet to IntelliJect to perform a single maintenance item.
 * Performing maintenance means clearing the triggered status, updating the
 * `lastdone` and `name` fields on the maintenance status, and adding a log
 * entry. This packet is never sent by IntelliJect, the response will always be
 * the MaintenanceStatus packet, followed by a LogEntry packet.
 */
typedef struct
{
    unsigned      domaintenance : 1;                                    //!< Set this bit when sending to IntelliJect to indicate that this maintenance item has been performed. This bit will never be set when this packet comes from IntelliJect.. Field is encoded constant.
    uint8_t       index;                                                //!< The index number of the maintenance item that is being performed. the index number matches the index from the maintenance schedule configuration.
    efiDateTime_t servicetime;                                          //!< The date and time when this maintenance item was serviced.
    char          name[maxNameCharacters];                              //!< Name of the person who did the maintenance.
    char          description[EFI_PACKET_SIZE - maxNameCharacters - 7]; //!< The text that goes into the log as part of performing this maintenance.
}efiPerformMaintenance_t;

//! Create the efiPerformMaintenance packet
void encodeefiPerformMaintenancePkt(efiPacket_t* pkt, const efiPerformMaintenance_t* user);

//! Decode the efiPerformMaintenance packet
int decodeefiPerformMaintenancePkt(const efiPacket_t* pkt, efiPerformMaintenance_t* user);

//! return the packet ID for the efiPerformMaintenance packet
#define getefiPerformMaintenancePktID() (EFI_PKT_MAINTENANCESTATUS)

//! return the minimum encoded length for the efiPerformMaintenance packet
#define getefiPerformMaintenanceMinDataLength() (8)

//! return the maximum encoded length for the efiPerformMaintenance packet
#define getefiPerformMaintenanceMaxDataLength() (maxNameCharacters+EFI_PACKET_SIZE - maxNameCharacters - 7+6)

/*!
 * Commands for the log entry packet.
 */
typedef enum
{
    logEntry,        //!< A new or existing log entry
    requestLogEntry, //!< Request a specific log entry
    deleteLogEntry,  //!< Delete a log entry
    numLogEntries,   //!< Request the number of log entries.
    eraseLogBook     //!< Erase the entire log.
} LogEntryCommands;

/*!
 * Maximum number of log entries.
 */
typedef enum
{
    maxLogEntries = 1022 //!< Maximum number of log entries that can be supported.
} MaxLogEntries;

/*!
 * Log entry packet used to request, add, or change entries in the digital
 * engine logbook. The logbook consists of a series of entries, each contained
 * in a single packet. Each log entry contains a, `date`, `name`, and
 * `description` text. In addition each log entry has an `index` that simply
 * identifies the location of the entry in the logbook.
 * 
 * The interpretation of the log entry packet depends on the value of the `cmd`
 * field, and on whether the packet was sent to, or received from, the EFI.
 * When requesting a specific log entry, requesting the number of log entries,
 * or deleting a log entry; you only need to send the first two bytes,
 * identifying the log entry by its index. Note that if a log entry is deleted
 * the indices of the log entries above the deleted entry will be changed so
 * that the list of indices alays starts at zero and ends at 1 less than the
 * number of entries.
 * 
 * When requesting the number of log entries the EFI will respond with the two
 * byte form of this packet, with `cmd` set to `numLogEntries` and `index`
 * giving the number of log entries. When requesting a log entry the EFI will
 * respond with the requested entry and the `cmd` value set to `logEntry`. When
 * deleting a log entry the EFI will respond with the two byte form of this
 * packet, with the `cmd` set to `deleteLogEntry` and the `index` set to the
 * deleted entry's index.
 * 
 * To add a new log entry send this packet with `cmd` set to `logEntry` and
 * `index` greater than the or equal to the `numLogEntries`. The EFI will
 * respond by echoing the new log entry. To change an existing log entry set
 * `index` equal to the entry to change. The EFI will first delete the `index`
 * entry (resetting all the indices of later entries) and then append the
 * updated entry to the logbook. In this case the EFI will respond as through
 * two separate commands were sent: a delete command followed by a new log
 * entry.
 * 
 * The logbook is stored onboard IntelliJect in 128Kbytes of flash. If each
 * entry uses the maximum amount of text there is space for at least 127
 * entries. Most entries will have less than the maximum text so it should be
 * possible to have many more than 127 entries. Because the logbook is stored
 * in flash deleting or changing an entry requires zero-ing that flash location
 * and re-writing the entry further on. Enough log entries, deletions, or
 * edits, will use up or fragment the log storage space until no more entries
 * can be made. In that case log additions will result in a nack. Use the
 * command `eraseLogBook` to completely erase the log; at which point you can
 * reload it without framentation, and/or remove older log entries to make room
 * for new ones. The log cannot be changed while the engine is running,
 * attempting to do so will result in a nack.
 * 
 * Adding a new log entry does not require IntelliJect to be unlocked. However
 * deleting or changing a log entry does require IntelliJect to be unlocked.
 * The log follows the same access restrictions as the maintenance schedule.
 */
typedef struct
{
    LogEntryCommands cmd;                                                  //!< Command for the log entry packet. The interpretation of the command depends . Use `logEntry` or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`.
    uint16_t         index;                                                //!< The index number for this log.
    efiDateTime_t    time;                                                 //!< The date and time of the log entry.
    char             name[maxNameCharacters];                              //!< Name of the person who entered the log entry.
    char             description[EFI_PACKET_SIZE - maxNameCharacters - 7]; //!< The log entry text.
}efiLogEntry_t;

//! Create the efiLogEntry packet
void encodeefiLogEntryPkt(efiPacket_t* pkt, const efiLogEntry_t* user);

//! Decode the efiLogEntry packet
int decodeefiLogEntryPkt(const efiPacket_t* pkt, efiLogEntry_t* user);

//! return the packet ID for the efiLogEntry packet
#define getefiLogEntryPktID() (EFI_PKT_LOGENTRY)

//! return the minimum encoded length for the efiLogEntry packet
#define getefiLogEntryMinDataLength() (9)

//! return the maximum encoded length for the efiLogEntry packet
#define getefiLogEntryMaxDataLength() (maxNameCharacters+EFI_PACKET_SIZE - maxNameCharacters - 7+7)

/*!
 * Command packet for a log entry.
 */
typedef struct
{
    LogEntryCommands cmd;   //!< Command for the log entry packet. Use 'logEntry' or `requestLogEntry` to request a log. Use `deleteLogEntry` to delete a log. Use `numLogEntries` to request the number of log entries. The log is identified by either the `time` value, of if the `time` is invalid, then by the `index`.
    uint16_t         index; //!< The index number that goes with the command.
}efiLogEntryCommand_t;

//! Create the efiLogEntryCommand packet from parameters
void encodeefiLogEntryCommandPkt(efiPacket_t* pkt, LogEntryCommands cmd, uint16_t index);

//! Decode the efiLogEntryCommand packet to parameters
int decodeefiLogEntryCommandPkt(const efiPacket_t* pkt, LogEntryCommands* cmd, uint16_t* index);

//! return the packet ID for the efiLogEntryCommand packet
#define getefiLogEntryCommandPktID() (EFI_PKT_LOGENTRY)

//! return the minimum encoded length for the efiLogEntryCommand packet
#define getefiLogEntryCommandMinDataLength() (2)

//! return the maximum encoded length for the efiLogEntryCommand packet
#define getefiLogEntryCommandMaxDataLength() (2)

typedef enum
{
    maxJournalEntries = 81 //!< Maximum number of journal entries that can fit in a 512 byte packet
} NumJournal;

/*!
 * Journal information for records of data on the SD card
 */
typedef struct
{
    uint16_t record;    //!< The record identifier.
    uint32_t lastBlock; //!< The last 512 byte block written for this record, relative to the start of the card volume. The first and last blocks on the card contains the journal.
}efijournal_t;

/*!
 * This packet reports the SD card journal, which is used to track information
 * written to the SD card. The journal is stored on the card and cannot be
 * changed with this packet. The journal can be requested from the EFI by
 * sending this packet with zero length. If no card is installed, or the card
 * has a problem, the journal will contain no records.
 */
typedef struct
{
    efiTelemetrySDCard_t sdcardtm;                   //!< SD card telemetry information. The only field from this telemetry that is used for journaling is `numDataBlocks`.
    uint32_t             numBlocksInVolume;          //!< The number of data blocks the card volume can hold, including the journal blocks.
    uint8_t              numRecords;                 //!< Number of records in the journal. This may be less than the number of records on the card.
    efijournal_t         journal[maxJournalEntries]; //!< Journal information for records of data on the SD card
}efiSDCardJournal_t;

//! Encode a efijournal_t into a byte array
void encodeefijournal_t(uint8_t* data, int* bytecount, const efijournal_t* user);

//! Decode a efijournal_t from a byte array
int decodeefijournal_t(const uint8_t* data, int* bytecount, efijournal_t* user);

//! Create the efiSDCardJournal packet
void encodeefiSDCardJournalPkt(efiPacket_t* pkt, const efiSDCardJournal_t* user);

//! Decode the efiSDCardJournal packet
int decodeefiSDCardJournalPkt(const efiPacket_t* pkt, efiSDCardJournal_t* user);

//! return the packet ID for the efiSDCardJournal packet
#define getefiSDCardJournalPktID() (EFI_PKT_SDCARDJOURNAL)

//! return the minimum encoded length for the efiSDCardJournal packet
#define getefiSDCardJournalMinDataLength() (14)

//! return the maximum encoded length for the efiSDCardJournal packet
#define getefiSDCardJournalMaxDataLength() (maxJournalEntries*6+14)

/*!
 * The file packet gives the name of a file. This is typically used to store
 * the name of the file that was used to configure this EFI. The file name is
 * not used by the EFI, it is provided as a convenient means of configuration
 * management.
 */
typedef struct
{
    efiDate_t date;          //!< The date when the file configuration was sent
    char      filename[128]; //!< The name of the file used to load configuration.
}efiFile_t;

//! Create the efiFile packet
void encodeefiFilePkt(efiPacket_t* pkt, const efiFile_t* user);

//! Decode the efiFile packet
int decodeefiFilePkt(const efiPacket_t* pkt, efiFile_t* user);

//! return the packet ID for the efiFile packet
#define getefiFilePktID() (EFI_PKT_FILE)

//! return the minimum encoded length for the efiFile packet
#define getefiFileMinDataLength() (11)

//! return the maximum encoded length for the efiFile packet
#define getefiFileMaxDataLength() (138)

/*!
 * This packet gives a user comment to describe the configuration. The comment
 * is not used by the EFI, it is provided as a means of configuration
 * management.
 */
typedef struct
{
    uint8_t userdata[8];  //!< 8 bytes of user writable and readable nonvolatile data
    char    comment[512]; //!< User comment string
}efiComment_t;

//! Create the efiComment packet
void encodeefiCommentPkt(efiPacket_t* pkt, const efiComment_t* user);

//! Decode the efiComment packet
int decodeefiCommentPkt(const efiPacket_t* pkt, efiComment_t* user);

//! return the packet ID for the efiComment packet
#define getefiCommentPktID() (EFI_PKT_COMMENT)

//! return the minimum encoded length for the efiComment packet
#define getefiCommentMinDataLength() (9)

//! return the maximum encoded length for the efiComment packet
#define getefiCommentMaxDataLength() (520)

/*!
 * Different levels of configuration data protecting
 */
typedef enum
{
    EFI_PRT_READWRITE,//!< Configuration data is not password protected
    EFI_PRT_READONLY,//!< Configuration data can be requested but requires a password unlock to change
    EFI_PRT_HIDDEN   //!< Configuration can only be requested or changed with a password unlock
} efiprotectionlevels;

/*!
 * This packet is used to lock the configuration and set the unlock password.
 * Each time the EFI starts the configuration is automaticaly locked and cannot
 * be changed unless the [unlock](#EFI_PKT_UNLOCK) command is given. EFI
 * locking has three levels: [`EFI_LCK_LOCKED`](#efiunlocklevels),
 * [`EFI_LCK_PARTIAL_UNLOCKED`](#efiunlocklevels), and
 * [`EFI_LCK_PASSWORD_UNLOCKED`](#efiunlocklevels).
 * 
 * For each set of configuration data (tables, governor, throttle, engine,
 * pump, sensors, comms) this packet specifies the behavior of the protections
 * when the password *has not yet been supplied*. There are three options:
 * read/write, read only, and hidden. When configuration data are read/write
 * the data can be requested when the efi is locked, and can be changed when
 * the efi unlock level is [`EFI_LCK_PARTIAL_UNLOCKED`](#efiunlocklevels). When
 * configuration data are read only the data can be requested when the efi is
 * locked, but changing the data requires unlocking with the password. When
 * configuration data are hidden the data cannot be requested or changed
 * without unlocking using the password.
 * 
 * Upon receipt of this packet, if the EFI is currently unlocked, the
 * configuration will be locked. The lock control configuration data are always
 * protected at the read only level: therefore you can always request the lock
 * control configuration but you cannot change it without doing a password
 * unlock. Note that when sent from the EFI this packet will never include the
 * password.
 */
typedef struct
{
    efiprotectionlevels tablesProtection;      //!< Protection level for all the table configuration data
    efiprotectionlevels governorProtection;    //!< Protection level for the RPM controller configuration data
    efiprotectionlevels throttleProtection;    //!< Protection level for the throttle configuration data
    efiprotectionlevels engineProtection;      //!< Protection level for the engine configuration data
    efiprotectionlevels injectorProtection;    //!< Protection level for the injector configuration data
    efiprotectionlevels pumpProtection;        //!< Protection level for the pump configuration data
    efiprotectionlevels sensorsProtection;     //!< Protection level for all sensor configuration data
    efiprotectionlevels commsProtection;       //!< Protection level for the communications configuration data
    efiprotectionlevels maintenanceProtection; //!< Protection level for the maintenance and logbook data
    efiprotectionlevels coolingProtection;     //!< Protection level for the cooling configuration data
    char                password[32];          //!< Password for unlocking. This can be an empty string in which case no password is needed for unlocking. Requesting this packet will always return an empty string for the password.
}efiLockControl_t;

//! Create the efiLockControl packet
void encodeefiLockControlPkt(efiPacket_t* pkt, const efiLockControl_t* user);

//! Decode the efiLockControl packet
int decodeefiLockControlPkt(const efiPacket_t* pkt, efiLockControl_t* user);

//! return the packet ID for the efiLockControl packet
#define getefiLockControlPktID() (EFI_PKT_LOCKCONTROL)

//! return the minimum encoded length for the efiLockControl packet
#define getefiLockControlMinDataLength() (13)

//! return the maximum encoded length for the efiLockControl packet
#define getefiLockControlMaxDataLength() (44)

/*!
 * Send this packet to mark the current configuration as valid. Upon receipt of
 * this packet, if the EFI is unlocked, a parameter hash of the configuration
 * will be computed and stored. The EFI maintains a hash of the actual
 * configuration which is compared with the stored value, generating a
 * parameter mismatch error if the two values are different. In addition, if a
 * hash is computed and stored, the EFI will be locked.
 * 
 * When sending this packet to the EFI the values `storedParameterHash` and
 * `actualParameterHash` are used as a command flag. Setting these to
 * `0x00000000` and `0xFFFFFFFF` respectively will cause the EFI to disable the
 * parameter mismatch check (and the EFI will not be locked). Any other value
 * results in the computation and storage of the parameter hash, triggering the
 * parameter mismatch check.
 * 
 * When this packet comes from the EFI `storedParameterHash` will be
 * `0x00000000` if the parameter mismatch check is disabled. If you change the
 * EFI configuration (by sending a configuration packet) the EFI will recompute
 * and resend the new configuration hash the next time it outputs slow
 * telemetry. Alternatively you can request the configuration hash packet to
 * get the updated `actualParameterHash`.
 */
typedef struct
{
    uint32_t storedParameterHash; //!< Parameter hash that was stored the last time this packet was sent to the EFI, for packets coming from the EFI. If this value is zero the parameter mismatch check is not being performed.
    uint32_t actualParameterHash; //!< The parameter hash that was computed from the stored configuration. This value is ignored for packets going to the EFI, it is available only on request.
}efiConfigHash_t;

//! Create the efiConfigHash packet
void encodeefiConfigHashPkt(efiPacket_t* pkt, const efiConfigHash_t* user);

//! Decode the efiConfigHash packet
int decodeefiConfigHashPkt(const efiPacket_t* pkt, efiConfigHash_t* user);

//! return the packet ID for the efiConfigHash packet
#define getefiConfigHashPktID() (EFI_PKT_CONFIGHASH)

//! return the minimum encoded length for the efiConfigHash packet
#define getefiConfigHashMinDataLength() (8)

//! return the maximum encoded length for the efiConfigHash packet
#define getefiConfigHashMaxDataLength() (8)

/*!
 * Configuration information for the fuel pump control. The fuel pump can be
 * controlled using bang-bang feedback, or proportional-integral (PI) feedback.
 * Bang-bang feedback simply toggles between minimum and maximum pump duty
 * cycle based on comparing the fuel pressure error with the
 * `fuelPressureBangBangThreshold`. In PI feedback the pump duty cycle is
 * controlled using proportional and integral feedback of fuel pressure error
 * combined with feedforward of fuel flow rate. The current fuel pump duty
 * cycle is visible in the [slow telemetry](#EFI_PKT_TELEMETRYSLOW) packet.
 */
typedef struct
{
    float    fuelPressureCmd;               //!< Desired fuel pressure in kilo-Pascals.
    float    fuelPressureErrorThreshold;    //!< Fuel pressures in kilo-Pascals relative to the fuelPressureCmd which is used to define a fuel pressure error (too low or too high)
    float    minDutyCycle;                  //!< Minimum pump output duty cycle in percent.
    float    maxDutyCycle;                  //!< Maximum pump output duty cycle in percent.
    float    fuelPressureBangBangThreshold; //!< Fuel pressure error threshold in kilo-Pascals for bang-bang pump control. If this is non-zero the fuel pump is controlled by bang-bang feedback.
    float    proGain;                       //!< Feedback gain from fuel pressure error (in kilo-Pascals) to fuel pump duty cycle in percent. Must be positive.
    float    intGain;                       //!< Feedback gain from fuel pressure error integral (in kilo-Pascals-seconds) to fuel pump duty cycle in percent. Must be positive.
    float    forGain;                       //!< Feedforward gain from fuel flow rate in grams per minute to fuel pump duty cycle in percent. Must be positive.
    uint8_t  rpmEnablesPump;                //!< If set the fuel pump output will remain at 0% until a non-zero engine speed is detected. If clear the pump is allowed to run even if the engine is not running.
    uint8_t  primeTime;                     //!< The amount of time, in seconds, the pump is allowed to run to prime the fuel system. If `rpmEnablesPump` is set, and if the RPM is zero, the pump will be allowed to run until 'primeTime' seconds have elapsed. If `rpmEnablesPump` is clear `primeTime` will do nothing.
    uint8_t  maxIfFailure;                  //!< If set the fuel pump output will be `maxDutyCycle` if the fuel pressure sensor is failed. Otherwise the pump output will be set according to the feedforward gain.
    float    positiveRateLimit;             //!< Rate limit on pump output, if the output is increasing, in units of % duty cycle per second. 0 will disable the positive rate limiter.
    float    negativeRateLimit;             //!< Rate limit on pump output, if the output is decreasing, in units of % duty cycle per second. 0 will disable the negative rate limiter.
    float    _outputRateLimit;              //!< Deprecated rate limit on pump output in units of % duty cycle per second. 0 will disable the positive rate limiter. This field will only be used if it is positive and `positiveRateLimit` and `negativeRateLimit` are zero.. Field is encoded constant.
    uint16_t pwmPeriod;                     //!< Fuel pump PWM period in microseconds.
}efiPumpConfiguration_t;

//! Create the efiPumpConfiguration packet
void encodeefiPumpConfigurationPkt(efiPacket_t* pkt, const efiPumpConfiguration_t* user);

//! Decode the efiPumpConfiguration packet
int decodeefiPumpConfigurationPkt(const efiPacket_t* pkt, efiPumpConfiguration_t* user);

//! return the packet ID for the efiPumpConfiguration packet
#define getefiPumpConfigurationPktID() (EFI_PKT_PUMPCONFIGURATION)

//! return the minimum encoded length for the efiPumpConfiguration packet
#define getefiPumpConfigurationMinDataLength() (22)

//! return the maximum encoded length for the efiPumpConfiguration packet
#define getefiPumpConfigurationMaxDataLength() (24)

/*!
 * Enumeration for baud rates on the CAN bus
 */
typedef enum
{
    EFI_CAN_125K,    //!< Baud rate of 125 thousand bits per second
    EFI_CAN_250K,    //!< Baud rate of 250 thousand bits per second
    EFI_CAN_500K,    //!< Baud rate of 500 thousand bits per second
    EFI_CAN_1M,      //!< Baud rate of 1 million bits per second
    NUM_EFI_CANBAUDS 
} CANBaudEnums;

/*!
 * Configuration data for CAN communciations
 */
typedef struct
{
    CANBaudEnums baud;                       //!< Baud rate enumeration for the CAN bus
    uint8_t      typeShift;                  //!< The bit number of the least significant bit of the packet type ([efiPacketIds](#efiPacketIds)) in the native protocol CAN ID. This is the number of bits that the packet type will be left shifted to place it into the CAN ID.
    uint8_t      longid;                     //!< Set this bit to use 29-bit identifiers in the native protocol, else the CAN bus will use 11-bit identifiers.
    unsigned     disableNativeInput : 1;     //!< Set this bit to disable receipt of native protocol CAN communications (inputBaseId is don't care).
    uint32_t     inputBaseId;                //!< The base value used to form the CAN identifier for input CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value.
    unsigned     disableNativeOutput : 1;    //!< Set this bit to disable transmission of native protocol CAN communications.
    uint32_t     outputBaseId;               //!< The base value used to form the CAN identifier for outputput CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value.
    unsigned     disableNativeBroadcast : 1; //!< Set this bit to disable receipt of native protocol broadcast CAN communications (broadcastBaseId is don't care).
    uint32_t     broadcastBaseId;            //!< The base value used to form the CAN identifier for broadcast input CAN frames. The CAN identifier is formed by left shifting the packet type according to typeShift and then ORing the result with this value.
    unsigned     forcePacketOverCAN : 1;     //!< Set this bit to force the system to use *only* the Packet-over-CAN schema, even for packets that have 8 or less bytes of data. This option is not recommended unless the EFI must be limited to a single identifier on the CAN bus. When this option is set the EFI will only output CAN frames that match exactly the `outputBaseId`, and will only accept CAN frames that exactly match the `inputBaseId` or the `broadcastBaseId`.
    unsigned     cmdAndTmOnly : 1;           //!< Set this bit to limit the CAN bus to command and telemetry messages only. Attempts to request or change configuration using the CAN bus will be ignored. Packet-over-CAN will not be used since all remaining packets have 8 or less bytes of data (unless `forcePacketOverCAN` is set).
    unsigned     enableGCU : 1;              //!< Set this bit to enable receive of the Generator Control Unit telemetry (Northwest or Millswood). This can be enabled simultaneously with the other alternative protocols.
    unsigned     enablePE3ECU : 1;           //!< Set this bit to emulate the Performance Electronics PE3 ECU CAN interface. This can be set at the same time as `enablePiccoloECU`
    unsigned     enableCurrawongECU : 1;     //!< Set this bit to emulate the Currawong ECU CAN interface.
    unsigned     enablePiccoloECU : 1;       //!< Set this bit to enable support for the Piccolo ECU CAN interface.
    uint16_t     alternativeProtocolAddress; //!< The 16-bit address to use with either the Currawong ECU or Piccolo ECU protocols. This address applies to Currawong ECU over serial as well as CAN
}efiCANconfig_t;

/*!
 * Configuration information for communications, including Controller Area
 * Network (CAN) setup, Universal Asynchronous Receiver Transmitter (UART) baud
 * rate, and telemetry output options. If you select a baud rate (UART or CAN)
 * which is too low to accommodate the telemetry output rates, the rates will
 * be adjusted down until the expected bandwidth fits the available data rate.
 * If you select the option `setToDefault` the UART baud rate will be set to
 * 57600 bits per second, the fast telemetry rate will be 20Hz, and the slow
 * telemetry rate will be 1Hz.
 * 
 * The CAN configuration supports multiple options and protocols. The primary
 * CAN protocol is the *native protocol*, which implements the packet-over-CAN
 * schema to move packets as documented in this ICD. The native protocol
 * includes input and output base identifiers, as well as a broadcast
 * identifier. The input and output identifier must be unique on the CAN bus;
 * but the broadcast identifier can be common with other EFIs on the bus. If
 * you select the option `setToDefault` the native protocol will be configured
 * to run at 1Mbit, with long identifiers, a type shift of 16 bits, an input
 * identifier of `0x1E00xxxx`, and an output identifier of `0x1F00xxxx` (where
 * `xxxx` are the lower 16 bits of the EFI serial number).
 * 
 * In addition to the native communications protocol three other protocols are
 * supported (Currawong, Piccolo, Performance Electronics). If you set
 * `enableCurrawongECU` the EFI will emulate the communications protocol used
 * by the [CE367
 * ECU](http://www.currawongeng.com/uav-engines/engine-control-unit/) from
 * Currawong Engineering. The emulation of this interface includes telemetry,
 * commands, and configuration packets, see the Currawong ECU ICD for details.
 * The `enableCurrawongECU` bit is an option for both the UART and the CAN
 * interface. On the UART interface the Currawong protocol runs at 57600 bits
 * per second, and runs simultaneously with the native protocol (the EFI
 * discriminates based on the packet format). The EFI will use the
 * `alternativeProtocolAddress` for the address field in the Currawong serial
 * packet. When using `enableCurrawongECU` with the CAN interface the EFI will
 * generate CAN frames from `0x0800xxxx` through `0x0818xxxx` (where `xxxx` are
 * the `alternativeProtocolAddress`), and will process CAN frames from
 * `0x0900xxxx` through `0x0918xxxx` (where `xxxx` are
 * `alternativeProtocolAddress`, or `0xFFFF`).
 * 
 * The second alternative protocol is enabled with the option
 * `enablePiccoloECU`. This protocol is only available on the CAN bus. You
 * cannot simultaneously set `enablePiccoloECU` and `enableCurrawongECU` on the
 * CAN bus, if you do the EFI will negate `enablePiccoloECU`. When using
 * `enablePiccoloECU` the EFI will generate CAN frames from `0x0880xxxx`
 * through `0x0884xxxx` (where `xxxx` are the `alternativeProtocolAddress`),
 * and will process CAN frames from `0x0990xxxx` through `0x0991xxxx` (where
 * `xxxx` are the `alternativeProtocolAddress`, or `0xFFFF`). Details of this
 * protocool can be had in the Piccolo communications ICD. The [Piccolo
 * autopilot](http://www.cloudcaptech.com/products/auto-pilots) CAN bus can
 * work with either the Piccolo ECU or the Currawong ECU protocol. When using
 * either protocol the CAN baud rate will be forced to 1Mbit, and the
 * `outputBaseID` and `inputBaseID` must *not* be `0x08xxxxxx` or `0x09xxxx`,
 * or the native output and input should be disabled.
 * 
 * The third alternative protocol is enabled with the option `enablePE3ECU`.
 * This is an output only protocol that emulates the CAN bus outputs of the
 * Performance Electronics PE3 ECU. You can use the `enablePE3ECU`
 * simultaneously with `enablePiccoloECU`, but not with `enableCurrawongECU` on
 * the CAN bus. The PE3 protocol option does not force the CAN baud rate, and
 * it does not follow the fast and slow telemetry rates; instead using the
 * telemetry rates specified by the Performance Electronics protocol (20Hz,
 * 10Hz, and 1Hz).
 * 
 * The fourth alternative protocol is enabled with the option `enableGCU`. This
 * is a CAN bus protocol which should be enabled if you want to decode
 * telemetry from the Northwest or Millswood generator control unit. This
 * protocol can be enabled with all other protocols and does not force the CAN
 * baud rate. If this protocol is enabled, and if a GCU is sending telemetry on
 * the CAN bus, IntelliJect will parse the telemetry data and forward it using
 * the [TelemetryGCU packet](#EFI_PKT_TELEMETRYGCU).
 * 
 * When using the Currawong, Piccolo, or PE3 alternative protocols the EFI will
 * suppress the native protocol telemetry output on the interface. However if a
 * native protocol packet is received on the interface the EFI will resume
 * output of the native protocol telemetry.
 */
typedef struct
{
    unsigned       disableSDRecording : 1; //!< If set SD card recording will be disabled all the time, even if the engine is running.
    uint8_t        fastTelemetrySDRate;    //!< SD recording rate for fast telemetry.
    uint8_t        fastTelemetryRate;      //!< Output rate for fast telemetry.
    unsigned       recordSDAlways : 1;     //!< If set SD card recording will be enabled all the time, even if the engine is not running.
    uint8_t        slowTelemetrySDRate;    //!< SD recording rate for slow telemetry.
    uint8_t        slowTelemetryRate;      //!< Output rate for slow telemetry.
    unsigned       useSummaryPackets : 1;  //!< Set this bit to use summary packets for the telemetry on non-CAN interfaces.
    unsigned       setToDefault : 1;       //!< Set this bit to configure all communications for default settings. If this bit is set all other fields are ignored when this packet is sent to the EFI.
    unsigned       enableCurrawongECU : 1; //!< Set this bit to emulate the Currawong ECU Serial interface. If this is set the regular telemetry output in native packet format is suppressed, and the `uartBaud` is forced to 57600.
    uint32_t       uartBaud;               //!< Baud rate for the UART in units of bits per second
    efiCANconfig_t CANconfig;              //!< Configuration data for CAN communciations
}efiCommConfiguration_t;

//! Encode a efiCANconfig_t into a byte array
void encodeefiCANconfig_t(uint8_t* data, int* bytecount, const efiCANconfig_t* user);

//! Decode a efiCANconfig_t from a byte array
int decodeefiCANconfig_t(const uint8_t* data, int* bytecount, efiCANconfig_t* user);

//! Create the efiCommConfiguration packet
void encodeefiCommConfigurationPkt(efiPacket_t* pkt, const efiCommConfiguration_t* user);

//! Decode the efiCommConfiguration packet
int decodeefiCommConfigurationPkt(const efiPacket_t* pkt, efiCommConfiguration_t* user);

//! return the packet ID for the efiCommConfiguration packet
#define getefiCommConfigurationPktID() (EFI_PKT_COMMCONFIGURATION)

//! return the minimum encoded length for the efiCommConfiguration packet
#define getefiCommConfigurationMinDataLength() (24)

//! return the maximum encoded length for the efiCommConfiguration packet
#define getefiCommConfigurationMaxDataLength() (24)

// Initial and verify values for SensorConfiguration
#define eficomms_SensorConfiguration_sensor_VerifyMax EFI_SENSOR_MAXINDEX

/*!
 * Enumeration for sensors. Not all sensors exist in all variants of
 * IntelliJect hardware.
 */
typedef enum
{
    EFI_SENSOR_VOLT,                             //!< Input voltage sensor, units of Volts
    EFI_SENSOR_MAT,                              //!< Manifold air temperature sensor, units of Celsius
    EFI_SENSOR_CHT1,                             //!< First cylinder head temperature sensor, units of Celsius
    EFI_SENSOR_CHT2,                             //!< Second cylinder head temperature sensor, units of Celsius
    EFI_SENSOR_MAP,                              //!< Manifold pressure sensor, units of kilo-Pascals
    EFI_SENSOR_FUELP,                            //!< Fuel pressure sensor, units of kilo-Pascals
    EFI_SENSOR_ANALOGTPS,                        //!< Analog throttle sensor, units of percent
    EFI_SENSOR_CPUTEMP,                          //!< Temperature of the CPU, units of Celsius
    EFI_SENSOR_SPARETEMP,                        //!< Spare temperature sensor, units of Celsius
    EFI_SENSOR_BARO,                             //!< Barometric pressure sensor, units of kilo-Pascals
    EFI_SENSOR_OAT,                              //!< Temperature of the outside air, units of Celsius
    EFI_SENSOR_CURRENT,                          //!< Input current sensor, units of Amps
    EFI_SENSOR_12VOLT,                           //!< 12 Volt rail voltage sensor, units of Volts
    EFI_SENSOR_12CURRENT,                        //!< 12 Volt rail current sensor, units of Amps
    EFI_SENSOR_ANALOGBARO,                       //!< Analog barometric pressure sensor, units of kilo-Pascals
    EFI_SENSOR_MAXINDEX = EFI_SENSOR_ANALOGBARO  //!< The maximum valid sensor index
} efiSensorEnum;

//! \return the title of a 'efiSensorEnum' enum entry, based on its value
const char* efiSensorEnum_EnumTitle(int value);

/*!
 * Size of the sensor list
 */
typedef enum
{
    NUM_EFI_SENSORS = EFI_SENSOR_MAXINDEX+1  //!< The number of sensors in the EFI.
} efiSensorEnumSize;

/*!
 * This packet gives configuration information for a single sensor. Send this
 * packet with just the first byte to request a specific sensor configuration.
 * Sensor configuration includes the sensor gain and offset, the minimum and
 * maximum sensor readings beyond which the sensor is considered bad, and the
 * default sensor value to use if the sensor is bad or disabled. If the sensor
 * is configured as a kty84 or kty83 temperature sensor the gain should be
 * nominally 1 and the offset nominally 0. If `enableAutocorrect` is set the
 * sensor's calibration will be automatically adjusted to correct errors (if
 * possible). The only automatically corrected sensor is the MAP sensor
 * (pressure offset is corrected against Baro when engine is off).
 * 
 * Sensor readings and error status are available in the [telemetry
 * packets](#telemetrypacketsoutputbyintelliject).
 */
typedef struct
{
    unsigned      enabled : 1;           //!< Set to 1 to enable this sensor, disabled sensors will use the `failedvalue` or be ignored
    unsigned      kty84 : 1;             //!< Set to 1 to indicate that this sensor is a KTY84 temperature sensor
    unsigned      sealedGauge : 1;       //!< Set to 1 to indicate this sensor is of the sealed gauge type. This only applies to the fuel pressure sensor. If clear the fuel pressure sensor is considered a normal gauge type.
    efiSensorEnum sensor;                //!< The enumeration identifying the sensor to which this packet applies.
    float         filterlpf;             //!< Cutoff frequency for the low pass filter to apply to the sensor after conversion, 0 will disable the filter
    float         offset;                //!< Offset to be subtracted from the raw sensor reading, as a fraction of the sensor raw span
    float         gain;                  //!< Gain of the sensor in output units per full scale range. Sensor output = gain(reading - offset).
    float         failedvalue;           //!< Sensor value to use if the sensor readings are out of range, or the sensor is disabled.
    float         min;                   //!< Minimum sensor value, values below this are out of range
    float         max;                   //!< Maximum sensor value, values above this are out of range
    unsigned      kty83 : 1;             //!< Set to 1 to indicate that this sensor is a KTY83 temperature sensor
    unsigned      setToDefault : 1;      //!< Set this bit to configure this sensor for default settings. All other settings in this packet will be ignored.
    unsigned      calibrate : 1;         //!< Set this bit to perform a calibration for this sensor. This setting must be combined with `calibrateoffset` or `calibrategain` (but not both). This bit will never bet set when this packet comes from the EFI.
    unsigned      calibrateoffset : 1;   //!< Set this bit to perform a zero calibration for this sensor. The offset of the sensor will be adjusted to make the sensor output match the calibration value. The `offset` field will be ignored in this case. This bit will never be set when this packet comes from the EFI.
    unsigned      calibrategain : 1;     //!< Set this bit to perform a gain calibration for this sensor. The gain of the sensor will be adjusted to make the sensor output match the calibration value. The `gain` field will be ignored in this case. This bit will never be set when this packet comes from the EFI.
    unsigned      enableAutocorrect : 1; //!< Set this bit to enable this sensor to be automatically corrected.
    unsigned      platinum1000rtd : 1;   //!< Set to 1 to indicate this sensor is a platinum RTD with a resistance of 1000 ohms at 0C. Offset should be set to 0, and the gain should be 1.0 if the TCR (Ohm/Ohm/C) of the sensor is 0.00385. Increase or decrease the gain to account for different TCR values.
    float         calibrationvalue;      //!< The known sense value used with `calibrateoffset` or `calibrategain`.
}efiSensorConfiguration_t;

//! Create the efiSensorConfiguration packet
void encodeefiSensorConfigurationPkt(efiPacket_t* pkt, const efiSensorConfiguration_t* user);

//! Decode the efiSensorConfiguration packet
int decodeefiSensorConfigurationPkt(const efiPacket_t* pkt, efiSensorConfiguration_t* user);

//! Verify a efiSensorConfiguration_t has acceptable values
int verifyefiSensorConfiguration_t(efiSensorConfiguration_t* user);

//! return the packet ID for the efiSensorConfiguration packet
#define getefiSensorConfigurationPktID() (EFI_PKT_SENSORCONFIGURATION)

//! return the minimum encoded length for the efiSensorConfiguration packet
#define getefiSensorConfigurationMinDataLength() (16)

//! return the maximum encoded length for the efiSensorConfiguration packet
#define getefiSensorConfigurationMaxDataLength() (20)

/*!
 * Configuration information specific to the throttle. There are two possible
 * sources of throttle position sensing: The analog throttle sensor and the PWM
 * input. If the EFI is configured to drive the throttle (`efiDrivesThrottle`
 * is set) there are four possible sources of throttle command: The analog
 * throttle, the PWM input, the user command, or the RPM controller. In
 * addition, it is also possible to apply a throttle curve to convert the the
 * commanded throttle to the actual throttle. Finally, if the EFI is configured
 * to drive the throttle it is possible to *not* have a TPS sensor, in which
 * case the throttle position is assumed to be equal the throttle output by the
 * EFI.
 */
typedef struct
{
    uint16_t     closedPWMoutput;    //!< PWM in microseconds for 0% throttle output (for `efiDrivesThrottle`)
    uint16_t     openPWMoutput;      //!< PWM in microseconds for 100% throttle output (for `efiDrivesThrottle`)
    float        inputfilterlpf;     //!< Cutoff frequency for the low pass filter to apply to the throttle input, 0 will disable the filter. This filter always applies to TPS as well as command inputs. This filter supercedes the filter on the analog throttle sensor configuration.
    float        outputRateLimit;    //!< Rate limit on throttle output, in units of % throttle per second. 0 will disable the rate limiter.
    uint8_t      enableAnalogCmd;    //!< Set to enable the use of the analog throttle input as a throttle command (only valid if `efiDrivesThrottle` is set).
    uint8_t      enablePWMCmd;       //!< Set to enable the use of the PWM input as a throttle command (only valid if `efiDrivesThrottle` is set).
    uint8_t      efiDrivesThrottle;  //!< Set if the EFI is driving the throttle (through PWM out or CAN).
    uint8_t      enableAnalogTPS;    //!< Set to enable the use of the analog throttle input as a throttle position sensor. This cannot be set simultaneously with `enableAnalogCmd`.
    uint8_t      enablePWMTPS;       //!< Set to enable the use of the PWM throttle input as a throttle position sensor. This cannot be set simultaneously with `enablePWMCmd`.
    uint8_t      _enableCECANServo;  //!< Deprecated for api 7.
    uint8_t      enableCECANTPS;     //!< Set to enable the CAN servo position feedback as a throttle position sensor.
    uint8_t      enableMAPTPS;       //!< Set to enable the manifold pressure (plus the MAP estimate table) as a throttle position sensor.
    efiTable1D_t curve;              //!< The throttle curve relating throttle inputs to outputs. This can be disabled using the curve.enabled bit. The curve.indices are percent throttle input, and the curve.data are percent throttle output.
    float        startThrottle;      //!< Throttle percentage used to start the engine in percent. If there is no valid throttle command, this is used to set the throttle position.
    uint8_t      cecanAddress;       //!< Address, from 1 to 254, that identifies a Currawong Engineering CAN servo used for the throttle control if `efiDrivesThrottle` is set. Use 0 to disable the CAN servo output. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo.
    float        tpsErrorThreshold;  //!< Throttle position sensor error threshold in percent, used to determine if the TPS sensor has an error (if `efiDrivesThrottle` is set). Zero to disable
    float        maxStartThrottle;   //!< Maximum throttle percentage that can be used to start the engine. If the engine is cranked with throttle above this value spark and injector outputs will be suspended. Use 0% to disable the start prevention feature.
    uint16_t     closedPWMinput;     //!< PWM in microseconds for 0% throttle input (command or TPS), use zero to set `closedPWMinput` equal to `closedPWMoutput`
    uint16_t     openPWMinput;       //!< PWM in microseconds for 100% throttle input (command or TPS), use zero to set `closedPWMinput` equal to `closedPWMoutput`
    float        tpsFeedbackIntGain; //!< Integral feedback gain (/s) used to adjust throttle output to make the TPS value match the output command. The adjustment is only performed if this gain is non-zero, and if a TPS is enabled, and if `efiDrivesThrottle` is set.
}efiThrottleConfiguration_t;

//! Create the efiThrottleConfiguration packet
void encodeefiThrottleConfigurationPkt(efiPacket_t* pkt, const efiThrottleConfiguration_t* user);

//! Decode the efiThrottleConfiguration packet
int decodeefiThrottleConfigurationPkt(const efiPacket_t* pkt, efiThrottleConfiguration_t* user);

//! return the packet ID for the efiThrottleConfiguration packet
#define getefiThrottleConfigurationPktID() (EFI_PKT_THROTTLECONFIGURATION)

//! return the minimum encoded length for the efiThrottleConfiguration packet
#define getefiThrottleConfigurationMinDataLength() (8)

//! return the maximum encoded length for the efiThrottleConfiguration packet
#define getefiThrottleConfigurationMaxDataLength() (4*EFI_TABLE_MAX_COLS+18)

/*!
 * Configuration information for the cooling system.
 */
typedef struct
{
    float    chtTooCold;         //!< Head temperatures, in C, lower than this are an error (if the engine is running).
    float    chtTooHot;          //!< Head temperatures, in C, higher than this are an error.
    float    chtDesired;         //!< Desired operating head temperature, in C.
    float    derTime;            //!< Time in seconds used to compute the CHT rate. Longer times will have less noise but more lag.
    float    trajGain;           //!< Feedback trajectory gain from CHT error to CHT rate command. Must be positive. Use zero to disable the trajectory controller in favor of the classical controller.
    float    forGain;            //!< Feedforward gain from engine load (in percent) to cooling output in percent. Must be positive.
    float    proGain;            //!< Feedback gain from error (in C or C/s) to cooling output in percent. Must be positive.
    float    intGain;            //!< Feedback gain from error (in C or C/s) integral to cooling output in percent. Must be positive.
    float    derGain;            //!< Feedback gain from error derivative to the cooling output. Must be positive.
    uint8_t  enableSplitCooling; //!< Set to enable split cooling in which CHT1 drives cooling output 1, CHT2 drives cooling output 2, and CHT3 drives cooling output 3.
    uint16_t closedPWM1;         //!< PWM in microseconds for 0% cooling or cowl flap position for cooling output 1
    uint16_t openPWM1;           //!< PWM in microseconds for 100% cooling or cowl flap position for cooling output 1
    uint16_t closedPWM2;         //!< PWM in microseconds for 0% cooling or cowl flap position for cooling output 2
    uint16_t openPWM2;           //!< PWM in microseconds for 100% cooling or cowl flap position for cooling output 2
    uint8_t  cecanAddress1;      //!< Address, from 1 to 254, that identifies the first cowl flap servo on the CAN bus. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo. Use address 0 to disable the first CAN servo output.
    uint8_t  cecanAddress2;      //!< Address, from 1 to 254, that identifies the second cowl flap servo on the CAN bus. The CAN bus must be configured for 1Mbit operation to work with the Currawong Engineering CAN servo. Use address 0 to disable the second CAN servo output.
}efiCoolingConfiguration_t;

//! Create the efiCoolingConfiguration packet
void encodeefiCoolingConfigurationPkt(efiPacket_t* pkt, const efiCoolingConfiguration_t* user);

//! Decode the efiCoolingConfiguration packet
int decodeefiCoolingConfigurationPkt(const efiPacket_t* pkt, efiCoolingConfiguration_t* user);

//! return the packet ID for the efiCoolingConfiguration packet
#define getefiCoolingConfigurationPktID() (EFI_PKT_COOLINGCONFIGURATION)

//! return the minimum encoded length for the efiCoolingConfiguration packet
#define getefiCoolingConfigurationMinDataLength() (28)

//! return the maximum encoded length for the efiCoolingConfiguration packet
#define getefiCoolingConfigurationMaxDataLength() (28)

/*!
 * Configuration information for the core engine. This packet is used to set a
 * number of options about how to sense the crank shaft position, and control
 * the spark.
 */
typedef struct
{
    float           displacement;           //!< Engine displacement in cubic centimeters
    uint8_t         ignoreInputEnable;      //!< Set to ignore the input line that enables/disabes the EFI. If set the input enable is always enabled. Note that the physical enable line must be high to trigger the CDI outputs. `ignoreInputEnable` is only useful for testing or if you are not using the CDI.
    uint8_t         preventNormalRotation;  //!< Set to prevent normal direction engine running. This only applies if the crank sense system can determine direction.
    uint8_t         preventReverseRotation; //!< Set to prevent reverse direction engine running. This only applies if the crank sense system can determine direction.
    uint8_t         _enableCrank2;          //!< Deprecated setting for enabling crank sensor 2, this setting will only be obeyed if api8 is clear
    uint8_t         enableSpark3;          
    uint8_t         ignActiveHigh;          //!< Set if the ignitions are triggered on a rising edge from the EFI, else ignition is triggered on the falling edge.
    uint8_t         api8;                   //!< This bit will be set for api8 or later packets.. Field is encoded constant.
    uint8_t         maxIgnDwellTime;        //!< Maximum ignition dwell time in milliseconds.
    uint16_t        minIgnActiveTime;       //!< Minimum ignition active time in microseconds.
    float           hardRevLimit;           //!< Maximum engine speed, above which spark and injection are turned off. Zero to disable the rev limiter.
    float           softRevLimit;           //!< Engine speed above which spark and injection begin to turn off.
    float           rpmfilterlpf;           //!< Cutoff frequency for the low pass filter to apply to the rpm, 0 will disable the filter
    float           mapErrorThreshold;      //!< Manifold pressure error threshold in kPa, used (along with the MAP estimate table) to determine if the manifold pressure has an error. Zero to disable.
    efiCrankSense_t crankSense1;            //!< Details of the crank sense configuration for crank sensor 1
    efiCrankSense_t crankSense2;            //!< Details of the crank sense configuration for crank sensor 2
    float           chtReference;           //!< Reference head temperature for fuel correction, in C.
}efiEngineConfiguration_t;

//! Create the efiEngineConfiguration packet
void encodeefiEngineConfigurationPkt(efiPacket_t* pkt, const efiEngineConfiguration_t* user);

//! Decode the efiEngineConfiguration packet
int decodeefiEngineConfigurationPkt(const efiPacket_t* pkt, efiEngineConfiguration_t* user);

//! return the packet ID for the efiEngineConfiguration packet
#define getefiEngineConfigurationPktID() (EFI_PKT_NEWENGINECONFIGURATION)

//! return the minimum encoded length for the efiEngineConfiguration packet
#define getefiEngineConfigurationMinDataLength() (36)

//! return the maximum encoded length for the efiEngineConfiguration packet
#define getefiEngineConfigurationMaxDataLength() (36)

/*!
 * Enumeration detailing the interpretation of injector phase
 */
typedef enum
{
    injectorPhaseEnd,//!< The injector phasing describes the angle of the end of the injection
    injectorPhaseMid,//!< The injector phasing describes the angle of the middle of the injection
    injectorPhaseStart //!< The injector phasing describes the angle of the start of the injection
} InjectorPhaseEdge;

/*!
 * Configuration information for the injector. The EFI supports three injector
 * outputs. The injectors are operated so that the sum of all injectors is
 * equal to the desired fuel output. The proportion of fuel that each injector
 * outputs is controlled through the injector ratio tables. The EFI also
 * supports injector skipping, in which short fuel injection pulses are
 * accumulated into longer pulses for more precise control of the fuel
 * delivery.
 * 
 * Injectors can be configured to operate independently, which means that the
 * fuel multiplier that comes from temperature is determined independently for
 * each injector. There are four temperature sensors: a dedicated MAT sensor,
 * two dedicated CHT sensors, and a spare sensor that can be configurable as a
 * second MAT or third CHT. If the spare temp sensor is configured as manifold
 * temp the fuel multiplier for injector1 is based on CHT1 and MAT, the fuel
 * multiplier for injector2 is based on CHT2 and spare temp, and the fuel
 * multiplier for injector3 is the average of injector1 and 2. If the spare
 * temp sensor is configured as cylinder temp the fuel multiplier for injector1
 * is based on CHT1 and MAT, the fule multiplier for injector2 is based on CHT2
 * and MAT, and the fuel multiplier for injector3 is based on spare temp and
 * MAT.
 */
typedef struct
{
    unsigned          enableInjector2 : 1;            //!< Set to enable the second injector.
    unsigned          enableInjectorIndependence : 1; //!< Set to allow injectors to independently compute fuel multipliers for temperature.
    unsigned          spareTempIsCHT : 1;             //!< Set to assign the role of cylinder temperature 3 to the spare temp sensor.
    unsigned          spareTempIsMAT : 1;             //!< Set to assign the role of manifold temperature 2 to the spare temp sensor.
    unsigned          enableInjector3 : 1;            //!< Set to enable the third injector.
    unsigned          injectorsAreRedundant : 1;      //!< Set to allow injectors to operate redundantly, such that a fault on one injector causes the other injectors to pick up the fuel flow.
    InjectorPhaseEdge phaseEdge;                      //!< The injector phase edge specifies how to apply the injector phase table, and what injector angle is reported in telemetry
    float             fuelVolumePercentPerMAT;        //!< Percent fuel volume correction per degree C of MAT difference from 15C. Should be positive (volume goes up as temp goes up).
    float             multiplier;                     //!< Overall fuel multiplier to apply to the output of the fuel table.
    float             nominalFuelPressure;            //!< Nominal injector pressure in kilo-Pascals.
    float             nominalFlowrate1;               //!< First injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute.
    float             nominalFlowrate2;               //!< Second injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute.
    uint32_t          minOpeningTime1;                //!< Minimum opening time in microseconds for the first injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value.
    uint32_t          minOpeningTime2;                //!< Minimum opening time in microseconds for the second injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value.
    float             fuelUsedCorrector;              //!< Multiplier to apply to the accumulated fuel injected to correct for any fuel consumption reporting error. This value does not affect the engine operation, just the fuel reporting.
    float             nominalFlowrate3;               //!< Third injector full-on flow rate at the nominal pressure at 15C fuel temperature in grams per minute.
    uint32_t          minOpeningTime3;                //!< Minimum opening time in microseconds for the third injector. Injector pulses less than this will result in erroneous fueling, so the EFI will perform injector skipping to keep the injector opening times longer than this value.
    float             oilPrimingFreq;                 //!< Frequency to run the oil injection pump for priming.
    unsigned          spareTempIsOilT : 1;            //!< Set to assign the role of oil temperature to the spare temp sensor.
    unsigned          injector2IsOilInj : 1;          //!< Set to enable the second injector output to be used for oil injection. This must not be set at the same time as enableInjector2.
    unsigned          injector3IsOilInj : 1;          //!< Set to enable the third injector output to be used for oil injection. This must not be set at the same time as enableInjector3.
    float             oilForStarting;                 //!< Oil to inject when the engine starts, in micrograms per cc of engine displacement
    float             oilUsedCorrector;               //!< Multiplier to apply to the accumulated oil injected to correct for any oil consumption reporting error. This value does not affect the oil injection operation, just the reporting.
}efiInjectorConfiguration_t;

//! Create the efiInjectorConfiguration packet
void encodeefiInjectorConfigurationPkt(efiPacket_t* pkt, const efiInjectorConfiguration_t* user);

//! Decode the efiInjectorConfiguration packet
int decodeefiInjectorConfigurationPkt(const efiPacket_t* pkt, efiInjectorConfiguration_t* user);

//! return the packet ID for the efiInjectorConfiguration packet
#define getefiInjectorConfigurationPktID() (EFI_PKT_INJECTORCONFIGURATION)

//! return the minimum encoded length for the efiInjectorConfiguration packet
#define getefiInjectorConfigurationMinDataLength() (16)

//! return the maximum encoded length for the efiInjectorConfiguration packet
#define getefiInjectorConfigurationMaxDataLength() (25)

/*!
 * Configuration information for the RPM controller. The RPM controller can
 * only be used if the throttle configuration has `efiDrivesThrottle` set. The
 * RPM controller functions by moving the throttle. This is not the same as the
 * rev limiter, which functions by interrupting spark and injection.
 * 
 * The RPM controller can be commanded two different ways: either by directly
 * commanding the controller with the [RPM command](#EFI_PKT_RPMCOMMAND)
 * packet; or the RPM controller can be driven by the throttle command in order
 * to achieve an RPM computed from the throttle command.
 * 
 * The RPM controller can run in two different feedback control modes. In the
 * first mode (used if `trajGain` is zero) the feedback is based on RPM error.
 * In the second mode the feedback is based on RPM rate error.
 */
typedef struct
{
    float   minRPM;                   //!< Minimum commandable engine speed. The RPM command will be limited to greater than or equal to this value.
    float   maxRPM;                   //!< Maximum commandable engine speed. The RPM command will be limited to less than or equal to this value. If the `maxRPM` is less than the `minRPM` the RPM controller settings will be set to defaults.
    uint8_t enableRPMfromThrottleCmd; //!< Set to enable RPM command from throttle command. If this is clear the RPM governor is only enabled when receiving a direct RPM command.
    uint8_t enableLowRPMLimiter;      //!< Set to override the throttle command (when the governor is *not* running) to prevent RPM falling below the minRPM.
    uint8_t enableHighRPMLimiter;     //!< Set to override the throttle command (when the governor is *not* running) to prevent RPM exceeding the maxRPM.
    float   updateRate;               //!< Maximum frequency of the RPM control loop in Hertz. Slower reduces noise, faster improves responsiveness
    float   throttleAtMinRPM;         //!< The throttle in percent which is expected to yield the minimum RPM. This term is used to compute the RPM command from the throttle command when running in throttle mode. It is also used to compute the feedforward throttle term when running in direct RPM mode, and the throttle output in direct RPM mode if the engine is not yet running.
    float   rpmToThrottlePower;       //!< Power relationship between rpm ratio (rpmcmd-minRPM)/(maxRPM-minRPM) and throttle. This term is used to compute the RPM command from the throttle command when running in throttle mode. It is also used to compute the feedforward throttle term when running in direct RPM mode, and the throttle output in direct RPM mode if the engine is not yet running.
    float   rpmCmdfilterlpf;          //!< Low pass filter cutoff frequency applied to the rpm command. Use zero to disable the filter.
    float   maxRateCmd;               //!< Maximum RPM rate command in RPM/s, zero to disable the rate limiter. Must be positive.
    float   trajGain;                 //!< Feedback trajectory gain from RPM error to RPM rate command. Must be positive. User zero to disable the trajectory controller in favor of the classical controller.
    float   gainScaler;               //!< Power applied to the inner loop gains. Positive numbers cause gains to increase as RPM increases. Negative numbers cause gains to decrease as RPM increases. 0 will cause gains to be constant with RPM.
    float   forGain;                  //!< Feedforward gain from RPM command to the throttle. Must be positive.
    float   proGain;                  //!< Feedback gain from error to the throttle. Must be positive.
    float   intGain;                  //!< Feedback gain from error integral to the throttle. Must be positive.
    float   derGain;                  //!< Feedback gain from error derivative to the throttle. Must be positive.
    float   derivativeTime;           //!< Time in seconds used to compute the RPM rate. Longer times will have less noise but more lag.
    float   outputfilterlpf;          //!< Low pass filter cutoff frequency applied to the rpm controller output. Use zero to disable the filter.
    float   outputsoftband;           //!< Percent throttle motion that falls into the 'softband', which increases the low pass filter strength. Use zero to disable the softband.
}efiRPMController_t;

//! Create the efiRPMController packet
void encodeefiRPMControllerPkt(efiPacket_t* pkt, const efiRPMController_t* user);

//! Decode the efiRPMController packet
int decodeefiRPMControllerPkt(const efiPacket_t* pkt, efiRPMController_t* user);

//! return the packet ID for the efiRPMController packet
#define getefiRPMControllerPktID() (EFI_PKT_RPMCONTROLLER)

//! return the minimum encoded length for the efiRPMController packet
#define getefiRPMControllerMinDataLength() (26)

//! return the maximum encoded length for the efiRPMController packet
#define getefiRPMControllerMaxDataLength() (26)

/*!
 * List of maintenance item
 */
typedef struct
{
    MaintenanceTriggers trigger;         //!< The trigger for this maintenance item
    uint32_t            interval;        //!< The interval at which this maintenance should be done. For time triggers this is in seconds. Use zero to disable this maintenance item.
    char                description[64]; //!< Brief description of the maintenance to be performed
}efiMaintenanceItemConfig_t;

/*!
 * Set or request the maintenance schedule. The maintenance schedule is a list
 * of maintenance service actions. You can see if any maintenance item is
 * pending by checking the `maintenanceNeeded` bit of the [errors
 * packet](#EFI_PKT_TELEMETRYERRORS). Details of the maintenance status are
 * provided in the [maintenance status](#EFI_PKT_MAINTENANCESTATUS) packet. If
 * you use this packet to change the number of maintenance items, the
 * maintenance status will also be updated to keep the status items in sync
 * with the schedule.
 */
typedef struct
{
    uint8_t                    numItems;                                   //!< The number of maintenance items
    float                      hotTimeGain;                                //!< Hot time multiplier gain in multiplier per degree overtemp.
    float                      highLoadThreshold;                          //!< Throttle position above which high load time begins accumulating
    efiMaintenanceItemConfig_t MaintenanceItemConfig[maxMaintenanceItems]; //!< List of maintenance item
}efiMaintenanceConfiguration_t;

//! Encode a efiMaintenanceItemConfig_t into a byte array
void encodeefiMaintenanceItemConfig_t(uint8_t* data, int* bytecount, const efiMaintenanceItemConfig_t* user);

//! Decode a efiMaintenanceItemConfig_t from a byte array
int decodeefiMaintenanceItemConfig_t(const uint8_t* data, int* bytecount, efiMaintenanceItemConfig_t* user);

//! Create the efiMaintenanceConfiguration packet
void encodeefiMaintenanceConfigurationPkt(efiPacket_t* pkt, const efiMaintenanceConfiguration_t* user);

//! Decode the efiMaintenanceConfiguration packet
int decodeefiMaintenanceConfigurationPkt(const efiPacket_t* pkt, efiMaintenanceConfiguration_t* user);

//! return the packet ID for the efiMaintenanceConfiguration packet
#define getefiMaintenanceConfigurationPktID() (EFI_PKT_MAINTENANCECONFIGURATION)

//! return the minimum encoded length for the efiMaintenanceConfiguration packet
#define getefiMaintenanceConfigurationMinDataLength() (4)

//! return the maximum encoded length for the efiMaintenanceConfiguration packet
#define getefiMaintenanceConfigurationMaxDataLength() (maxMaintenanceItems*68+4)

/*!
 * Hardware and manufacturing information. This data cannot be changed, only
 * requested from the EFI.
 */
typedef struct
{
    uint32_t  serial;              //!< 32-bit serial number
    float     mattempcurrentdev;   //!< Deviation from the nominal current in Amps generated by the driver of the MAT sensor.
    float     sparetempcurrentdev; //!< Deviation from the nominal current in Amps generated by the driver of the Spare sensor.
    float     cht1tempcurrentdev;  //!< Deviation from the nominal current in Amps generated by the driver of the CHT1 sensor.
    float     cht2tempcurrentdev;  //!< Deviation from the nominal current in Amps generated by the driver of the CHT2 sensor.
    uint8_t   reserved;           
    float     nomtempcurrent;      //!< Nominal current from the temp sensor drivers in Amps.
    uint8_t   revMajor;            //!< Major hardware revision number
    uint8_t   revMinor;            //!< Minor hardware revision number
    efiDate_t date;                //!< The manufacture date of the hardware
}efiHardwareInfo_t;

//! Create the efiHardwareInfo packet
void encodeefiHardwareInfoPkt(efiPacket_t* pkt, const efiHardwareInfo_t* user);

//! Decode the efiHardwareInfo packet
int decodeefiHardwareInfoPkt(const efiPacket_t* pkt, efiHardwareInfo_t* user);

//! return the packet ID for the efiHardwareInfo packet
#define getefiHardwareInfoPktID() (EFI_PKT_HARDWAREINFO)

//! return the minimum encoded length for the efiHardwareInfo packet
#define getefiHardwareInfoMinDataLength() (14)

//! return the maximum encoded length for the efiHardwareInfo packet
#define getefiHardwareInfoMaxDataLength() (14)

/*!
 * Software version information. This data cannot be changed, only requested.
 */
typedef struct
{
    uint32_t  swHash;             //!< Git hash number (short version) from the software repository for this build
    unsigned  released : 1;       //!< Set if software is released, otherwise this software is still being tested.
    unsigned  swMajorVersion : 7; //!< Major software revision number
    uint8_t   swMinorVersion;     //!< Minor software revision number
    uint16_t  swBuild;            //!< Build number for this software. Larger build numbers are newer software
    efiDate_t date;               //!< The release date of the software
    uint32_t  codecrc;            //!< The crc for the software load
    uint32_t  size;               //!< The size of the program load in bytes.
    char      description[256];   //!< Human readable description of the software release
}efiSoftwareInfo_t;

//! Create the efiSoftwareInfo packet
void encodeefiSoftwareInfoPkt(efiPacket_t* pkt, const efiSoftwareInfo_t* user);

//! Decode the efiSoftwareInfo packet
int decodeefiSoftwareInfoPkt(const efiPacket_t* pkt, efiSoftwareInfo_t* user);

//! return the packet ID for the efiSoftwareInfo packet
#define getefiSoftwareInfoPktID() (EFI_PKT_SOFTWAREINFO)

//! return the minimum encoded length for the efiSoftwareInfo packet
#define getefiSoftwareInfoMinDataLength() (20)

//! return the maximum encoded length for the efiSoftwareInfo packet
#define getefiSoftwareInfoMaxDataLength() (275)

// Initial and verify values for Table2D_1x
#define eficomms_Table2D_1x_index_VerifyMax EFI_OLDTABLE_MAXINDEX
#define eficomms_Table2D_1x_numrows_VerifyMax EFI_TABLE_MAX_ROWS
#define eficomms_Table2D_1x_numcols_VerifyMax EFI_TABLE_MAX_COLS

/*!
 * This packet is used to change or request a 2D table, for software version
 * 1.x. It should not be used when communicating with 2.x IntelliJect. Send
 * this packet with just the first byte to request a specific table.
 */
typedef struct
{
    unsigned        enabled : 1;                                  //!< Table enable. If clear this table is not used
    unsigned        loadfrommap : 1;                              //!< Set to use the percent ratio of manifold to baro pressure as the row axis index, otherwise use the throttle. This only applies to tables that use throttle/load for the row index.
    efiOldTableList index;                                        //!< Enumeration specifying to which old table this packet applies.
    uint8_t         numrows;                                      //!< Number of rows used in this table
    uint8_t         numcols;                                      //!< Number of columns used in this table
    float           rowindices[EFI_TABLE_MAX_ROWS];               //!< The number of rows used in this table
    float           colindices[EFI_TABLE_MAX_COLS];               //!< The number of columns used in this table
    float           data[EFI_TABLE_MAX_ROWS][EFI_TABLE_MAX_COLS]; //!< The table data organized as row major
    uint8_t         meta[EFI_TABLE_MAX_ROWS][EFI_TABLE_MAX_COLS]; //!< The table meta data organized as row major
}efiTable2D_1x_t;

//! Create the efiTable2D_1x packet
void encodeefiTable2D_1xPkt(efiPacket_t* pkt, const efiTable2D_1x_t* user);

//! Decode the efiTable2D_1x packet
int decodeefiTable2D_1xPkt(const efiPacket_t* pkt, efiTable2D_1x_t* user);

//! Verify a efiTable2D_1x_t has acceptable values
int verifyefiTable2D_1x_t(efiTable2D_1x_t* user);

//! return the packet ID for the efiTable2D_1x packet
#define getefiTable2D_1xPktID() (EFI_PKT_TABLE)

//! return the minimum encoded length for the efiTable2D_1x packet
#define getefiTable2D_1xMinDataLength() (4)

//! return the maximum encoded length for the efiTable2D_1x packet
#define getefiTable2D_1xMaxDataLength() (2*EFI_TABLE_MAX_ROWS+2*EFI_TABLE_MAX_COLS+2*EFI_TABLE_MAX_ROWS*EFI_TABLE_MAX_COLS+1*EFI_TABLE_MAX_ROWS*EFI_TABLE_MAX_COLS+4)

// Initial and verify values for Table2D
#define eficomms_Table2D_index_VerifyMax EFI_TABLE_MAXINDEX
#define eficomms_Table2D_rowindex_VerifyMax EFI_TBLIDX_MAXINDEX
#define eficomms_Table2D_colindex_VerifyMax EFI_TBLIDX_MAXINDEX
#define eficomms_Table2D_multiplierindex_VerifyMax EFI_TBLIDX_MAXINDEX
#define eficomms_Table2D_dividerindex_VerifyMax EFI_TBLIDX_MAXINDEX
#define eficomms_Table2D_numrows_VerifyMax EFI_TABLE_MAX_ROWS
#define eficomms_Table2D_numcols_VerifyMax EFI_TABLE_MAX_COLS

/*!
 * Enumerated options for how to do table lookups.
 */
typedef enum
{
    no_tableLookupOptions = 0,   //!< Standard table lookup: no extrapolation, simple interpolation.
    angle_tableLookup = 1,       //!< Table lookup uses angle rules for interpolation and output wrapping.
    extrapolated_tableLookup = 2,//!< Extrapolation allowed for table lookup.
    extrapangle_tableLookup = 3  //!< Table lookup uses angle rules and extrapolation.
} tableLookupOptions;

/*!
 * This packet is used to change or request a 2D table. It should not be used
 * when communicating with 1.x IntelliJect. Send this packet with just the
 * first byte to request a specific table.
 */
typedef struct
{
    unsigned           enabled : 1;                                  //!< Table enable. If clear this table is not used
    efiTableList       index;                                        //!< Enumeration specifying to which table this packet applies.
    unsigned           addone : 1;                                   //!< If set the result of the table interpolation is added to 1.0 after applying the multiplier and divider.
    efiTableIndex      rowindex;                                     //!< Enumeration identifying what variable is used for the row index
    efiTableIndex      colindex;                                     //!< Enumeration identifying what variable is used for the column index
    efiTableIndex      multiplierindex;                              //!< Enumeration identifying what variable is used to multiply the table output
    efiTableIndex      dividerindex;                                 //!< Enumeration identifying what variable is used to divide the table output
    char               description[28];                              //!< User definable name for the table.
    uint8_t            numrows;                                      //!< Number of rows used in this table
    uint8_t            numcols;                                      //!< Number of columns used in this table
    float              rowindices[EFI_TABLE_MAX_ROWS];               //!< The number of rows used in this table
    float              colindices[EFI_TABLE_MAX_COLS];               //!< The number of columns used in this table
    float              data[EFI_TABLE_MAX_ROWS][EFI_TABLE_MAX_COLS]; //!< The table data organized as row major
    uint8_t            meta[EFI_TABLE_MAX_ROWS][EFI_TABLE_MAX_COLS]; //!< The table meta data organized as row major
    float              disabledValue;                                //!< The value to be output by the table lookup when this table is disabled. Set programatically, not by this packet.
    tableLookupOptions lookupOptions;                                //!< Options on how this table should do its lookups. Set programatically, not by this packet.
}efiTable2D_t;

//! Create the efiTable2D packet
void encodeefiTable2DPkt(efiPacket_t* pkt, const efiTable2D_t* user);

//! Decode the efiTable2D packet
int decodeefiTable2DPkt(const efiPacket_t* pkt, efiTable2D_t* user);

//! Verify a efiTable2D_t has acceptable values
int verifyefiTable2D_t(efiTable2D_t* user);

//! return the packet ID for the efiTable2D packet
#define getefiTable2DPktID() (EFI_PKT_TABLE)

//! return the minimum encoded length for the efiTable2D packet
#define getefiTable2DMinDataLength() (13)

//! return the maximum encoded length for the efiTable2D packet
#define getefiTable2DMaxDataLength() (3*EFI_TABLE_MAX_ROWS+3*EFI_TABLE_MAX_COLS+3*EFI_TABLE_MAX_ROWS*EFI_TABLE_MAX_COLS+1*EFI_TABLE_MAX_ROWS*EFI_TABLE_MAX_COLS+40)

// Initial and verify values for TableValue
#define eficomms_TableValue_index_VerifyMax EFI_TABLE_MAXINDEX
#define eficomms_TableValue_row_VerifyMax EFI_TABLE_MAX_ROWS-1
#define eficomms_TableValue_col_VerifyMax EFI_TABLE_MAX_COLS-1

/*!
 * Change a single table value and meta-value. Note that the table value packet
 * incudes a 'do not store' flag. When calibrating an engine this packet is
 * used frequently, and the do not store flag can be used to suppress the
 * non-volatile storage update. IntelliJect will respond by sending the entire
 * table back.
 */
typedef struct
{
    unsigned     donotstore : 1; //!< If set the table in memory will be updated, but not stored to non-volatile storage
    efiTableList index;          //!< Enumeration specifying to which table this packet applies.
    unsigned     version2 : 1;   //!< This bit must be set for a 2.x table.. Field is encoded constant.
    unsigned     row : 5;        //!< The row number, starting at zero.
    unsigned     col : 5;        //!< The column number, starting at zero.
    float        value;          //!< The value of this table at [row, col]
    uint8_t      meta;           //!< Meta data for this table cell
}efiTableValue_t;

//! Create the efiTableValue packet
void encodeefiTableValuePkt(efiPacket_t* pkt, const efiTableValue_t* user);

//! Decode the efiTableValue packet
int decodeefiTableValuePkt(const efiPacket_t* pkt, efiTableValue_t* user);

//! Verify a efiTableValue_t has acceptable values
int verifyefiTableValue_t(efiTableValue_t* user);

//! return the packet ID for the efiTableValue packet
#define getefiTableValuePktID() (EFI_PKT_TABLEVALUE)

//! return the minimum encoded length for the efiTableValue packet
#define getefiTableValueMinDataLength() (7)

//! return the maximum encoded length for the efiTableValue packet
#define getefiTableValueMaxDataLength() (10)

// Initial and verify values for TableEnable
#define eficomms_TableEnable_index_VerifyMax EFI_TABLE_MAXINDEX
#define eficomms_TableEnable_rowindex_VerifyMax EFI_TBLIDX_MAXINDEX
#define eficomms_TableEnable_colindex_VerifyMax EFI_TBLIDX_MAXINDEX
#define eficomms_TableEnable_multiplierindex_VerifyMax EFI_TBLIDX_MAXINDEX
#define eficomms_TableEnable_dividerindex_VerifyMax EFI_TBLIDX_MAXINDEX

//! Create the efiTableEnable packet
void encodeefiTableEnablePkt(efiPacket_t* pkt, const efiTable2D_t* user);

//! Decode the efiTableEnable packet
int decodeefiTableEnablePkt(const efiPacket_t* pkt, efiTable2D_t* user);

//! return the packet ID for the efiTableEnable packet
#define getefiTableEnablePktID() (EFI_PKT_TABLE)

//! return the minimum encoded length for the efiTableEnable packet
#define getefiTableEnableMinDataLength() (6)

//! return the maximum encoded length for the efiTableEnable packet
#define getefiTableEnableMaxDataLength() (6)

/*!
 * Summary packet that contains all the fast telemetry in a single packet.
 */
typedef struct
{
    efiTelemetryTime_t time; //!< Time information for the fast telemetry
    efiTelemetryFast_t fast; //!< Fast EFI telemetry
}efiTelemetryFastSummary_t;

//! Create the efiTelemetryFastSummary packet from parameters
void encodeefiTelemetryFastSummaryPkt(efiPacket_t* pkt, const efiTelemetryTime_t* time, const efiTelemetryFast_t* fast);

//! Decode the efiTelemetryFastSummary packet to parameters
int decodeefiTelemetryFastSummaryPkt(const efiPacket_t* pkt, efiTelemetryTime_t* time, efiTelemetryFast_t* fast);

//! return the packet ID for the efiTelemetryFastSummary packet
#define getefiTelemetryFastSummaryPktID() (EFI_PKT_TELEMETRYFASTSUM)

//! return the minimum encoded length for the efiTelemetryFastSummary packet
#define getefiTelemetryFastSummaryMinDataLength() (16)

//! return the maximum encoded length for the efiTelemetryFastSummary packet
#define getefiTelemetryFastSummaryMaxDataLength() (16)

//! Create the efiEngineWearExtended packet from parameters
void encodeefiEngineWearExtendedPkt(efiPacket_t* pkt, uint32_t hotTime, uint32_t highLoadTime, float peakCHT, uint16_t numStarts);

//! Decode the efiEngineWearExtended packet to parameters
int decodeefiEngineWearExtendedPkt(const efiPacket_t* pkt, uint32_t* hotTime, uint32_t* highLoadTime, float* peakCHT, uint16_t* numStarts);

//! return the packet ID for the efiEngineWearExtended packet
#define getefiEngineWearExtendedPktID() (EFI_PKT_ENGINEWEAREXT)

//! return the minimum encoded length for the efiEngineWearExtended packet
#define getefiEngineWearExtendedMinDataLength() (8)

//! return the maximum encoded length for the efiEngineWearExtended packet
#define getefiEngineWearExtendedMaxDataLength() (8)

/*!
 * Automatic fuel determination packet. This packet reports the results of the
 * autofuel algorithm, each time it runs.
 */
typedef struct
{
    float correlation; //!< Correlation value between fuel multiplier and specific power.
    float coefficient; //!< Pearson's correlation coefficient from 0.0 to 1.0
    float timedelay;   //!< Time delay in seconds for maximum correlation magnitude.
}efiTelemetryAutoFuel_t;

//! Create the efiTelemetryAutoFuel packet
void encodeefiTelemetryAutoFuelPkt(efiPacket_t* pkt, const efiTelemetryAutoFuel_t* user);

//! Decode the efiTelemetryAutoFuel packet
int decodeefiTelemetryAutoFuelPkt(const efiPacket_t* pkt, efiTelemetryAutoFuel_t* user);

//! return the packet ID for the efiTelemetryAutoFuel packet
#define getefiTelemetryAutoFuelPktID() (EFI_PKT_TELEMETRYAUTOFUEL)

//! return the minimum encoded length for the efiTelemetryAutoFuel packet
#define getefiTelemetryAutoFuelMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryAutoFuel packet
#define getefiTelemetryAutoFuelMaxDataLength() (8)

/*!
 * Telemetry about the oil injection system. The oil injection system must be
 * enabled in the injector configuration. If oil injection is not enabled this
 * packet will not be sent.
 */
typedef struct
{
    float    oilFlowRate;    //!< Oil flow rate in grams per minute.
    float    oilConsumption; //!< Oil consumption in grams since the system turned on.
    float    oilDuty;        //!< Oil injector pump duty cycle in percent
    float    oilFreq;        //!< Oil injector pump frequency in Hz
    uint16_t oilPrimeLeft;   //!< Number of oil injection priming pulses remaining, zero if priming is off
}efiTelemetryOilInjection_t;

//! Create the efiTelemetryOilInjection packet
void encodeefiTelemetryOilInjectionPkt(efiPacket_t* pkt, const efiTelemetryOilInjection_t* user);

//! Decode the efiTelemetryOilInjection packet
int decodeefiTelemetryOilInjectionPkt(const efiPacket_t* pkt, efiTelemetryOilInjection_t* user);

//! return the packet ID for the efiTelemetryOilInjection packet
#define getefiTelemetryOilInjectionPktID() (EFI_PKT_TELEMETRYOILINJ)

//! return the minimum encoded length for the efiTelemetryOilInjection packet
#define getefiTelemetryOilInjectionMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryOilInjection packet
#define getefiTelemetryOilInjectionMaxDataLength() (8)

typedef enum
{
    NWGCU,
    MWPMU,
    P4FGEN 
} gcuSource;

//! \return the title of a 'gcuSource' enum entry, based on its value
const char* gcuSource_EnumTitle(int value);

/*!
 * Telemetry about the Generator Control Unit (GCU). The GCU is external
 * hardware that sends status information on the CAN bus. This packet is only
 * sent by IntelliJect if the GCU data are detected on the CAN bus. Detection
 * of the GCU is always visible in the [CPU telemetry](#EFI_PKT_TELEMETRYCPU)
 * packet.
 */
typedef struct
{
    gcuSource source;             //!< Enumeration describing the source of the GCU information
    float     volts28;            //!< Voltage of the 28 V rail
    float     volts12;            //!< Voltage of the 12 V rail
    float     volts6;             //!< Voltage of the 6 V rail
    float     gcuTemp;            //!< Internal temperature of the GCU in Celsius
    unsigned  cranking : 1;       //!< Set if the GCU is cranking the engine for start
    unsigned  generating : 1;     //!< Set if the GCU is making electricity from the generator
    unsigned  charging : 1;       //!< Set if the GCU is charging the battery
    unsigned  startAvailable : 1; //!< Set if the GCU starter is available
    float     current28;          //!< Current in Amps of the 28 V rail
}efiTelemetryGCU_t;

//! Create the efiTelemetryGCU packet
void encodeefiTelemetryGCUPkt(efiPacket_t* pkt, const efiTelemetryGCU_t* user);

//! Decode the efiTelemetryGCU packet
int decodeefiTelemetryGCUPkt(const efiPacket_t* pkt, efiTelemetryGCU_t* user);

//! return the packet ID for the efiTelemetryGCU packet
#define getefiTelemetryGCUPktID() (EFI_PKT_TELEMETRYGCU)

//! return the minimum encoded length for the efiTelemetryGCU packet
#define getefiTelemetryGCUMinDataLength() (8)

//! return the maximum encoded length for the efiTelemetryGCU packet
#define getefiTelemetryGCUMaxDataLength() (8)

/*!
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 */
typedef struct
{
    efiTelemetryTime_t         time;         //!< Time information for the slow telemetry
    efiTelemetrySensorsapi7_t  sensors;      //!< First set of sensor information
    efiTelemetrySensors2api7_t sensors2;     //!< Second set of sensor information
    efiTelemetryFuel_t         fuel;         //!< Fuel flow and fuel used information
    efiTelemetryInjector_t     injector;     //!< Injector(s) information
    efiTelemetrySlowapi7_t     slow;         //!< Slow telemetry data
    efiTelemetryCPUapi4_t      cpu;          //!< Run time CPU information
    efiTelemetrySensors3api0_t sensors3;     //!< Third set of sensor information
    efiErrorsapi4_t            dynamicError; //!< Dynamic engine errors
    efiErrorsapi4_t            stickyError;  //!< Sticky engine errors
    efiEngineWearShort_t       wear;         //!< Short engine wear information
}efiTelemetrySlowSummaryapi0_t;

//! Decode the efiTelemetrySlowSummaryapi0 packet to parameters
int decodeefiTelemetrySlowSummaryapi0Pkt(const efiPacket_t* pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3api0_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWearShort_t* wear);

//! return the packet ID for the efiTelemetrySlowSummaryapi0 packet
#define getefiTelemetrySlowSummaryapi0PktID() (EFI_PKT_TELEMETRYSLOWSUM)

//! return the minimum encoded length for the efiTelemetrySlowSummaryapi0 packet
#define getefiTelemetrySlowSummaryapi0MinDataLength() (84)

//! return the maximum encoded length for the efiTelemetrySlowSummaryapi0 packet
#define getefiTelemetrySlowSummaryapi0MaxDataLength() (84)

/*!
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 */
typedef struct
{
    efiTelemetryTime_t         time;         //!< Time information for the slow telemetry
    efiTelemetrySensorsapi7_t  sensors;      //!< First set of sensor information
    efiTelemetrySensors2api7_t sensors2;     //!< Second set of sensor information
    efiTelemetryFuel_t         fuel;         //!< Fuel flow and fuel used information
    efiTelemetryInjector_t     injector;     //!< Injector(s) information
    efiTelemetrySlowapi7_t     slow;         //!< Slow telemetry data
    efiTelemetryCPUapi4_t      cpu;          //!< Run time CPU information
    efiTelemetrySensors3_t     sensors3;     //!< Third set of sensor information
    efiErrorsapi4_t            dynamicError; //!< Dynamic engine errors
    efiErrorsapi4_t            stickyError;  //!< Sticky engine errors
    efiEngineWearShort_t       wear;         //!< Short engine wear information
}efiTelemetrySlowSummaryapi1_t;

//! Decode the efiTelemetrySlowSummaryapi1 packet to parameters
int decodeefiTelemetrySlowSummaryapi1Pkt(const efiPacket_t* pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWearShort_t* wear);

//! return the packet ID for the efiTelemetrySlowSummaryapi1 packet
#define getefiTelemetrySlowSummaryapi1PktID() (EFI_PKT_TELEMETRYSLOWSUM)

//! return the minimum encoded length for the efiTelemetrySlowSummaryapi1 packet
#define getefiTelemetrySlowSummaryapi1MinDataLength() (88)

//! return the maximum encoded length for the efiTelemetrySlowSummaryapi1 packet
#define getefiTelemetrySlowSummaryapi1MaxDataLength() (88)

/*!
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 */
typedef struct
{
    efiTelemetryTime_t         time;         //!< Time information for the slow telemetry
    efiTelemetrySensorsapi7_t  sensors;      //!< First set of sensor information
    efiTelemetrySensors2api7_t sensors2;     //!< Second set of sensor information
    efiTelemetryFuel_t         fuel;         //!< Fuel flow and fuel used information
    efiTelemetryInjector_t     injector;     //!< Injector(s) information
    efiTelemetrySlowapi7_t     slow;         //!< Slow telemetry data
    efiTelemetryCPUapi4_t      cpu;          //!< Run time CPU information
    efiTelemetrySensors3_t     sensors3;     //!< Third set of sensor information
    efiErrorsapi4_t            dynamicError; //!< Dynamic engine errors
    efiErrorsapi4_t            stickyError;  //!< Sticky engine errors
    efiEngineWearShort_t       wear;         //!< Short engine wear information
    efiTelemetryComms_t        comms;        //!< Communications error and performance information
}efiTelemetrySlowSummaryapi2_t;

//! Decode the efiTelemetrySlowSummaryapi2 packet to parameters
int decodeefiTelemetrySlowSummaryapi2Pkt(const efiPacket_t* pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWearShort_t* wear, efiTelemetryComms_t* comms);

//! return the packet ID for the efiTelemetrySlowSummaryapi2 packet
#define getefiTelemetrySlowSummaryapi2PktID() (EFI_PKT_TELEMETRYSLOWSUM)

//! return the minimum encoded length for the efiTelemetrySlowSummaryapi2 packet
#define getefiTelemetrySlowSummaryapi2MinDataLength() (96)

//! return the maximum encoded length for the efiTelemetrySlowSummaryapi2 packet
#define getefiTelemetrySlowSummaryapi2MaxDataLength() (96)

/*!
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 */
typedef struct
{
    efiTelemetryTime_t         time;         //!< Time information for the slow telemetry
    efiTelemetrySensorsapi7_t  sensors;      //!< First set of sensor information
    efiTelemetrySensors2api7_t sensors2;     //!< Second set of sensor information
    efiTelemetryFuel_t         fuel;         //!< Fuel flow and fuel used information
    efiTelemetryInjector_t     injector;     //!< Injector(s) information
    efiTelemetrySlowapi7_t     slow;         //!< Slow telemetry data
    efiTelemetryCPUapi4_t      cpu;          //!< Run time CPU information
    efiTelemetrySensors3_t     sensors3;     //!< Third set of sensor information
    efiErrorsapi4_t            dynamicError; //!< Dynamic engine errors
    efiErrorsapi4_t            stickyError;  //!< Sticky engine errors
    efiEngineWearShort_t       wear;         //!< Short engine wear information
    efiTelemetryComms_t        comms;        //!< Communications error and performance information
    efiTelemetrySensors4_t     sensors4;     //!< Fourth set of sensor information
}efiTelemetrySlowSummaryapi3_t;

//! Decode the efiTelemetrySlowSummaryapi3 packet to parameters
int decodeefiTelemetrySlowSummaryapi3Pkt(const efiPacket_t* pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWearShort_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4);

//! return the packet ID for the efiTelemetrySlowSummaryapi3 packet
#define getefiTelemetrySlowSummaryapi3PktID() (EFI_PKT_TELEMETRYSLOWSUM)

//! return the minimum encoded length for the efiTelemetrySlowSummaryapi3 packet
#define getefiTelemetrySlowSummaryapi3MinDataLength() (104)

//! return the maximum encoded length for the efiTelemetrySlowSummaryapi3 packet
#define getefiTelemetrySlowSummaryapi3MaxDataLength() (104)

/*!
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 */
typedef struct
{
    efiTelemetryTime_t         time;         //!< Time information for the slow telemetry
    efiTelemetrySensorsapi7_t  sensors;      //!< First set of sensor information
    efiTelemetrySensors2api7_t sensors2;     //!< Second set of sensor information
    efiTelemetryFuel_t         fuel;         //!< Fuel flow and fuel used information
    efiTelemetryInjector_t     injector;     //!< Injector(s) information
    efiTelemetrySlowapi7_t     slow;         //!< Slow telemetry data
    efiTelemetryCPUapi4_t      cpu;          //!< Run time CPU information
    efiTelemetrySensors3_t     sensors3;     //!< Third set of sensor information
    efiErrorsapi4_t            dynamicError; //!< Dynamic engine errors
    efiErrorsapi4_t            stickyError;  //!< Sticky engine errors
    efiEngineWear_t            wear;         //!< Engine wear information
    efiTelemetryComms_t        comms;        //!< Communications error and performance information
    efiTelemetrySensors4_t     sensors4;     //!< Fourth set of sensor information
}efiTelemetrySlowSummaryapi4_t;

//! Decode the efiTelemetrySlowSummaryapi4 packet to parameters
int decodeefiTelemetrySlowSummaryapi4Pkt(const efiPacket_t* pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPUapi4_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrorsapi4_t* dynamicError, efiErrorsapi4_t* stickyError, efiEngineWear_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4);

//! return the packet ID for the efiTelemetrySlowSummaryapi4 packet
#define getefiTelemetrySlowSummaryapi4PktID() (EFI_PKT_TELEMETRYSLOWSUM)

//! return the minimum encoded length for the efiTelemetrySlowSummaryapi4 packet
#define getefiTelemetrySlowSummaryapi4MinDataLength() (112)

//! return the maximum encoded length for the efiTelemetrySlowSummaryapi4 packet
#define getefiTelemetrySlowSummaryapi4MaxDataLength() (112)

/*!
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 */
typedef struct
{
    efiTelemetryTime_t         time;         //!< Time information for the slow telemetry
    efiTelemetrySensorsapi7_t  sensors;      //!< First set of sensor information
    efiTelemetrySensors2api7_t sensors2;     //!< Second set of sensor information
    efiTelemetryFuel_t         fuel;         //!< Fuel flow and fuel used information
    efiTelemetryInjector_t     injector;     //!< Injector(s) information
    efiTelemetrySlowapi7_t     slow;         //!< Slow telemetry data
    efiTelemetryCPU_t          cpu;          //!< Run time CPU information
    efiTelemetrySensors3_t     sensors3;     //!< Third set of sensor information
    efiErrors_t                dynamicError; //!< Dynamic engine errors
    efiErrors_t                stickyError;  //!< Sticky engine errors
    efiEngineWear_t            wear;         //!< Engine wear information
    efiTelemetryComms_t        comms;        //!< Communications error and performance information
    efiTelemetrySensors4_t     sensors4;     //!< Fourth set of sensor information
}efiTelemetrySlowSummaryapi5_t;

//! Decode the efiTelemetrySlowSummaryapi5 packet to parameters
int decodeefiTelemetrySlowSummaryapi5Pkt(const efiPacket_t* pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPU_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrors_t* dynamicError, efiErrors_t* stickyError, efiEngineWear_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4);

//! return the packet ID for the efiTelemetrySlowSummaryapi5 packet
#define getefiTelemetrySlowSummaryapi5PktID() (EFI_PKT_TELEMETRYSLOWSUM)

//! return the minimum encoded length for the efiTelemetrySlowSummaryapi5 packet
#define getefiTelemetrySlowSummaryapi5MinDataLength() (112)

//! return the maximum encoded length for the efiTelemetrySlowSummaryapi5 packet
#define getefiTelemetrySlowSummaryapi5MaxDataLength() (112)

/*!
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 */
typedef struct
{
    efiTelemetryTime_t         time;         //!< Time information for the slow telemetry
    efiTelemetrySensorsapi7_t  sensors;      //!< First set of sensor information
    efiTelemetrySensors2api7_t sensors2;     //!< Second set of sensor information
    efiTelemetryFuel_t         fuel;         //!< Fuel flow and fuel used information
    efiTelemetryInjector_t     injector;     //!< Injector(s) information
    efiTelemetrySlowapi7_t     slow;         //!< Slow telemetry data
    efiTelemetryCPU_t          cpu;          //!< Run time CPU information
    efiTelemetrySensors3_t     sensors3;     //!< Third set of sensor information
    efiErrors_t                dynamicError; //!< Dynamic engine errors
    efiErrors_t                stickyError;  //!< Sticky engine errors
    efiEngineWear_t            wear;         //!< Engine wear information
    efiTelemetryComms_t        comms;        //!< Communications error and performance information
    efiTelemetrySensors4_t     sensors4;     //!< Fourth set of sensor information
    efiTelemetrySDCard_t       sdcard;       //!< SD Card telemetry information
}efiTelemetrySlowSummaryapi7_t;

//! Decode the efiTelemetrySlowSummaryapi7 packet to parameters
int decodeefiTelemetrySlowSummaryapi7Pkt(const efiPacket_t* pkt, efiTelemetryTime_t* time, efiTelemetrySensorsapi7_t* sensors, efiTelemetrySensors2api7_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlowapi7_t* slow, efiTelemetryCPU_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrors_t* dynamicError, efiErrors_t* stickyError, efiEngineWear_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4, efiTelemetrySDCard_t* sdcard);

//! return the packet ID for the efiTelemetrySlowSummaryapi7 packet
#define getefiTelemetrySlowSummaryapi7PktID() (EFI_PKT_TELEMETRYSLOWSUM)

//! return the minimum encoded length for the efiTelemetrySlowSummaryapi7 packet
#define getefiTelemetrySlowSummaryapi7MinDataLength() (120)

//! return the maximum encoded length for the efiTelemetrySlowSummaryapi7 packet
#define getefiTelemetrySlowSummaryapi7MaxDataLength() (120)

/*!
 * Summary packet that contains all the slow telemetry in a single packet. The
 * summary packet is only used on non-CAN interfaces (unless
 * `forcePacketOverCAN` is set), and only if it is enabled in the
 * communications configuration. Since each ordinary telemetry packet is only 8
 * bytes long, combining multiple telmetry packets into a single summary packet
 * can significantly reduce packet overhead.
 */
typedef struct
{
    efiTelemetryTime_t            time;            //!< Time information for the slow telemetry
    efiTelemetrySensors_t         sensors;         //!< First set of sensor information
    efiTelemetrySensors2_t        sensors2;        //!< Second set of sensor information
    efiTelemetryFuel_t            fuel;            //!< Fuel flow and fuel used information
    efiTelemetryInjector_t        injector;        //!< Injector(s) information
    efiTelemetrySlow_t            slow;            //!< Slow telemetry data
    efiTelemetryCPU_t             cpu;             //!< Run time CPU information
    efiTelemetrySensors3_t        sensors3;        //!< Third set of sensor information
    efiErrors_t                   dynamicError;    //!< Dynamic engine errors
    efiErrors_t                   stickyError;     //!< Sticky engine errors
    efiEngineWear_t               wear;            //!< Engine wear information
    efiTelemetryComms_t           comms;           //!< Communications error and performance information
    efiTelemetrySensors4_t        sensors4;        //!< Fourth set of sensor information
    efiTelemetrySDCard_t          sdcard;          //!< SD Card telemetry information
    efiTelemetryExtendedOutputs_t extendedoutputs; //!< Telemetry for injector3, spark2, and spark3
}efiTelemetrySlowSummary_t;

//! Create the efiTelemetrySlowSummary packet from parameters
void encodeefiTelemetrySlowSummaryPkt(efiPacket_t* pkt, const efiTelemetryTime_t* time, const efiTelemetrySensors_t* sensors, const efiTelemetrySensors2_t* sensors2, const efiTelemetryFuel_t* fuel, const efiTelemetryInjector_t* injector, const efiTelemetrySlow_t* slow, const efiTelemetryCPU_t* cpu, const efiTelemetrySensors3_t* sensors3, const efiErrors_t* dynamicError, const efiErrors_t* stickyError, const efiEngineWear_t* wear, const efiTelemetryComms_t* comms, const efiTelemetrySensors4_t* sensors4, const efiTelemetrySDCard_t* sdcard, const efiTelemetryExtendedOutputs_t* extendedoutputs);

//! Decode the efiTelemetrySlowSummary packet to parameters
int decodeefiTelemetrySlowSummaryPkt(const efiPacket_t* pkt, efiTelemetryTime_t* time, efiTelemetrySensors_t* sensors, efiTelemetrySensors2_t* sensors2, efiTelemetryFuel_t* fuel, efiTelemetryInjector_t* injector, efiTelemetrySlow_t* slow, efiTelemetryCPU_t* cpu, efiTelemetrySensors3_t* sensors3, efiErrors_t* dynamicError, efiErrors_t* stickyError, efiEngineWear_t* wear, efiTelemetryComms_t* comms, efiTelemetrySensors4_t* sensors4, efiTelemetrySDCard_t* sdcard, efiTelemetryExtendedOutputs_t* extendedoutputs);

//! return the packet ID for the efiTelemetrySlowSummary packet
#define getefiTelemetrySlowSummaryPktID() (EFI_PKT_TELEMETRYSLOWSUM)

//! return the minimum encoded length for the efiTelemetrySlowSummary packet
#define getefiTelemetrySlowSummaryMinDataLength() (128)

//! return the maximum encoded length for the efiTelemetrySlowSummary packet
#define getefiTelemetrySlowSummaryMaxDataLength() (128)

//! Create the efiResetStickyCounter packet from parameters
void encodeefiResetStickyCounterPkt(efiPacket_t* pkt, uint16_t stickyresetcount);

//! Decode the efiResetStickyCounter packet to parameters
int decodeefiResetStickyCounterPkt(const efiPacket_t* pkt, uint16_t* stickyresetcount);

//! return the packet ID for the efiResetStickyCounter packet
#define getefiResetStickyCounterPktID() (EFI_PKT_RESET)

//! return the minimum encoded length for the efiResetStickyCounter packet
#define getefiResetStickyCounterMinDataLength() (2)

//! return the maximum encoded length for the efiResetStickyCounter packet
#define getefiResetStickyCounterMaxDataLength() (2)

/*!
 * Enumeration for exceptions or interrupts on the chip. This enumeration will
 * appear in the exception field of a reset report packet if the reset is
 * caused by an exception or unhandled interrupted
 */
typedef enum
{
    EFI_EXC_NMI = 2,         //!< Non maskable interrupt, Clock Security System
    EFI_EXC_HARD_FAULT,      //!< All class of fault
    EFI_EXC_MEM_MANAGE,      //!< Memory management
    EFI_EXC_BUS_FAULT,       //!< Pre-fetch fault, memory access fault
    EFI_EXC_USAGE_FAULT,     //!< Undefined instruction or illegal state
    EFI_EXC_SV_CALL = 11,    //!< System Service call via SWI instruction
    EFI_EXC_DEBUG_MONITOR,   //!< Debug Monitor
    EFI_EXC_PEND_SV = 14,    //!< Pendable request for system service
    EFI_EXC_SYSTICK,         //!< System tick timer
    EFI_INT_WWDG,            //!< Window Watchdog interrupt
    EFI_INT_PVD,             //!< PVD through EXTI line detection interrupt
    EFI_INT_TAMP_STAMP,      //!< Tamper and TimeStamp interrupts through the EXTI line
    EFI_INT_RTC_WKUP,        //!< RTC Wakeup interrupt through the EXTI line
    EFI_INT_FLASH,           //!< Flash global interrupt
    EFI_INT_RCC,             //!< RCC global interrupt
    EFI_INT_EXTI0,           //!< EXTI Line0 interrupt
    EFI_INT_EXTI1,           //!< EXTI Line1 interrupt
    EFI_INT_EXTI2,           //!< EXTI Line2 interrupt
    EFI_INT_EXTI3,           //!< EXTI Line3 interrupt
    EFI_INT_EXTI4,           //!< EXTI Line4 interrupt
    EFI_INT_DMA1_Stream0,    //!< DMA1 Stream0 global interrupt
    EFI_INT_DMA1_Stream1,    //!< DMA1 Stream1 global interrupt
    EFI_INT_DMA1_Stream2,    //!< DMA1 Stream2 global interrupt
    EFI_INT_DMA1_Stream3,    //!< DMA1 Stream3 global interrupt
    EFI_INT_DMA1_Stream4,    //!< DMA1 Stream4 global interrupt
    EFI_INT_DMA1_Stream5,    //!< DMA1 Stream5 global interrupt
    EFI_INT_DMA1_Stream6,    //!< DMA1 Stream6 global interrupt
    EFI_INT_ADC,             //!< ADC1 global interrupt
    EFI_INT_CAN1_TX,         //!< CAN1 TX interrupt
    EFI_INT_CAN1_RX0,        //!< CAN1 RX0 interrupt
    EFI_INT_CAN1_RX1,        //!< CAN1 RX1 interrupt
    EFI_INT_CAN1_SCE,        //!< CAN1 SCE interrupt
    EFI_INT_EXTI9_5,         //!< EXTI Line[9:5] interrupts
    EFI_INT_TIM1_BRK_TIM9,   //!< TIM1 Break interrupt and TIM9 global interrupt
    EFI_INT_TIM1_UP_TIM10,   //!< TIM1 update interrupt and TIM10 global interrupt
    EFI_INT_TIM_TRG_COM_TIM11,//!< TIM1 Trigger and Commutation interrupts and TIM11 global interrupt
    EFI_INT_TIM1_CC,         //!< TIM1 Capture Compare interrupt
    EFI_INT_TIM2,            //!< TIM2 global interrupt
    EFI_INT_TIM3,            //!< TIM3 global interrupt
    EFI_INT_TIM4,            //!< TIM4 global interrupt
    EFI_INT_I2C1_EVT,        //!< I2C1 global event interrupt
    EFI_INT_I2C1_ERR,        //!< I2C1 global error interrupt
    EFI_INT_I2C2_EVT,        //!< I2C2 global event interrupt
    EFI_INT_I2C2_ERR,        //!< I2C2 global error interrupt
    EFI_INT_SPI1,            //!< SPI1 global interrupt
    EFI_INT_SPI2,            //!< SPI2 global interrupt
    EFI_INT_USART1,          //!< USART1 global interrupt
    EFI_INT_USART2,          //!< USART2 global interrupt
    EFI_INT_USART3,          //!< USART3 global interrupt
    EFI_INT_EXTI15_10,       //!< EXTI Line[15:10] interrupts
    EFI_INT_EXTI17_RTC_Alarm,//!< EXTI Line 17 interrupt / RTC Alarms (A and B) through EXTI line interrupt
    EFI_INT_EXTI18_OTG_FS_WKUP,//!< EXTI Line 18 interrupt / USB On-The-Go FS Wakeup through EXTI line interrupt
    EFI_INT_TIM8_BRK_TIM12,  //!< TIM8 Break interrupt TIM12 global interrupt
    EFI_INT_TIM8_UP_TIM13,   //!< TIM8 Update interrupt TIM13 global interrupt
    EFI_INT_TIM8_TRG_COM_TIM14,//!< TIM8 Trigger and Commutation interrupt TIM14 global interrupt
    EFI_INT_TIM8_CC,         //!< TIM8 Cap/Com interrupt
    EFI_INT_DMA1_Stream7,    //!< DMA1 global interrupt Channel 7
    EFI_INT_FSMC,            //!< FSMC global interrupt
    EFI_INT_SDIO,            //!< SDIO global interrupt
    EFI_INT_TIM5,            //!< TIM5 global interrupt
    EFI_INT_SPI3,            //!< SPI3 global interrupt
    EFI_INT_TIM6 = 70,       //!< TIM6 global interrupt
    EFI_INT_TIM7,            //!< TIM7 global interrupt
    EFI_INT_DMA2_Stream0,    //!< DMA2 Stream0 global interrupt
    EFI_INT_DMA2_Stream1,    //!< DMA2 Stream1 global interrupt
    EFI_INT_DMA2_Stream2,    //!< DMA2 Stream2 global interrupt
    EFI_INT_DMA2_Stream3,    //!< DMA2 Stream3 global interrupt
    EFI_INT_DMA2_Stream4,    //!< DMA2 Stream4 global interrupt
    EFI_INT_DFSDM1_FLT0,     //!< SD filter0 global interrupt
    EFI_INT_DFSDM1_FLT1,     //!< SD filter1 global interrupt
    EFI_INT_CAN2_TX,         //!< CAN2 TX interrupt
    EFI_INT_CAN2_RX0,        //!< BXCAN2 RX0 interrupt
    EFI_INT_CAN2_RX1,        //!< BXCAN2 RX1 interrupt
    EFI_INT_CAN2_SCE,        //!< CAN2 SCE interrupt
    EFI_INT_OTG_FS,          //!< USB On The Go FS global interrupt
    EFI_INT_DMA2_Stream5,    //!< DMA2 Stream5 global interrupt
    EFI_INT_DMA2_Stream6,    //!< DMA2 Stream6 global interrupt
    EFI_INT_DMA2_Stream7,    //!< DMA2 Stream7 global interrupt
    EFI_INT_USART6,          //!< USART6 global interrupt
    EFI_INT_I2C3_EV,         //!< I2C3 event interrupt
    EFI_INT_I2C3_ER,         //!< I2C3 error interrupt
    EFI_INT_RNG = 96,        //!< RNG global interrupt
    EFI_INT_FPU,             //!< FPU global interrupt
    EFI_INT_SPI4,            //!< SPI4 global interrupt
    EFI_INT_SPI5,            //!< SPI5 global interrupt
    EFI_INT_Quad_SPI = 108,  //!< Quad SPI global interrupt
    EFI_INT_I2CFMP1_EV,      //!< I2CFMP1 event interrupt
    EFI_INT_I2CFMP1_ER       //!< I2CFMP1 error interrupt
} efiExceptionId;

//! \return the label of a 'efiExceptionId' enum entry, based on its value
const char* efiExceptionId_EnumLabel(int value);

/*!
 * This packet reports the cause of a reset; it is spontaneously sent each time
 * the EFI resets, on the first connection from a user. In addition the reset
 * packet can be requested by sending this packet with zero length. The
 * firmware will handle any unexpected exception or interrupt by immediately
 * performing a software reset. In that case the `exceptionReset` bit will be
 * set, and the exception field will indicate which unhandled interrupt or
 * exception triggered the reset. The register values reported by this packet
 * are only valid for an exception reset. For other reset causes the register
 * values will be zero.
 * 
 * Resets which are not caused by power are counted in the `errorresetcnt`. If
 * the error counter reaches 20 the software will enter a safe mode in which it
 * does not load any settings from storage. 10 seconds after the system boots
 * up the `errorresetcnt` is zeroed. This makes it possible to recover the
 * system from a reset loop caused by bad settings data.
 */
typedef struct
{
    unsigned lowPowerReset : 1;        //!< Reset caused by the low power management
    unsigned windowWatchdogReset : 1;  //!< Reset caused by the window watchdog
    unsigned watchdogReset : 1;        //!< Reset caused by the independent watchdog
    unsigned softwareReset : 1;        //!< Reset caused by software
    unsigned powerReset : 1;           //!< Reset caused by power on
    unsigned pinReset : 1;             //!< Reset caused by the reset pin
    unsigned borReset : 1;             //!< Brown out reset
    unsigned exceptionReset : 1;       //!< Reset caused by unhandled exception or interrupt
    uint8_t  exception;                //!< The number of the interrupt or exception which caused this reset, valid only if `exceptionReset` is set, otherwise zero.
    unsigned first : 1;                //!< If set, this is the first report generated since the system reset. Subsequent requests for the reset report will have this bit clear.
    unsigned safeModeActive : 1;       //!< If set the system booted in safe mode because `errorresetcnt` was too large. No settings data were loaded from non-volatile storage in this mode. The only way to exit safe mode is to reset the system.
    unsigned quickRestartActive : 1;   //!< If set the system booted in quick restart mode because the engine was running when the reset occurred.
    unsigned specialWatchdogReset : 1; //!< Reset caused by special watchdog handling. This is an exception that fires before the true watchdog in an attempt to learn the program counter of the stuck code.
    uint8_t  count;                    //!< Volatile reset count information. Each time the system boots up, it increments this counter. If the system resets by losing power long enough to clear the RAM then this counter will reset to zero. After the counter reaches 255 it will roll over to zero.
    uint32_t programCounter;           //!< The program counter of the instruction that triggered the exception.
    uint32_t linkRegister;             //!< The link register at the time of the exception.
    uint32_t xpsr;                     //!< The program status register at the time of the exception.
    uint32_t fpscr;                    //!< The floating point status and control register at the time of the exception.
    uint32_t cfsr;                     //!< The configurable fault status register at the time of the exception.
    uint32_t mmfar;                    //!< The memory management fault address register at the time of the exception.
    uint32_t bfar;                     //!< The bus fault address register at the time of the exception.
    uint8_t  errorresetcnt;            //!< The error reset count is incremented once for each time the system resets due to an error which is not power related. If the error counter reaches 20 the software will enter a safe mode in which it does not load any settings from storage. 10 seconds after the system boots up the `errorresetcnt` is zeroed.
    uint16_t stickyresetcount;         //!< Non-volatile reset count information. Each time the system boots up, it increments this counter.
}efiResetReport_t;

//! Create the efiResetReport packet
void encodeefiResetReportPkt(efiPacket_t* pkt, const efiResetReport_t* user);

//! Decode the efiResetReport packet
int decodeefiResetReportPkt(const efiPacket_t* pkt, efiResetReport_t* user);

//! return the packet ID for the efiResetReport packet
#define getefiResetReportPktID() (EFI_PKT_RESET)

//! return the minimum encoded length for the efiResetReport packet
#define getefiResetReportMinDataLength() (24)

//! return the maximum encoded length for the efiResetReport packet
#define getefiResetReportMaxDataLength() (35)

/*!
 * Enumeration describing the cause of the nack
 */
typedef enum
{
    nackPktNotRecognized,    //!< Nack due to unrecognized input packet.
    nackDataAreLocked,       //!< Nack due to attempt to change locked data.
    nackDataAreHidden,       //!< Nack due to attempt to read hidden configuration data.
    nackRunningIncorrect,    //!< Nack due to engine running when it needs to be off, or vice versa.
    nackReqBitNotRecognized, //!< Nack due to use of a reserved bit in the request packet.
    nackLogIsFull,           //!< Nack due to log being full.
    nackEnableIncorrect      //!< Nack due to system being disabled when it needs to be enabled, or vice versa.
} efiNackCause;

/*!
 * This packet is sent by the EFI to indicate a not-acknowledge response. The
 * nack always occurs in reponse to a packet from the user. There are six
 * different nack cases: 1) The input packet was not recognized. 2) The input
 * packet attempted to change locked configuration data, 3) The input packet
 * attempted to read hidden configuration data, 4) The input packet attempted a
 * command that cannot be performed while the engine is running, or 5) The
 * input packet was `EFI_PKT_REQUEST` but one of the request bits was reserved,
 * or 6) The input packet required the system be enabled when it was disabled,
 * or vice versa.
 */
typedef struct
{
    uint8_t      type;       //!< The type of the packet that triggered the NACK response.
    efiNackCause cause;      //!< The reason for the nack response.
    uint8_t      index;      //!< The index information from the first data byte of the packet that triggered the NACK response. This is only relevant for those packets that have indices.
    uint8_t      requestbit; //!< If the cause of the nack was `nackReqBitNotRecognized` this field gives the bit number, from 95 (most significant) to 0 (least), of the request bit that was not understood.
}efiNack_t;

//! Create the efiNack packet
void encodeefiNackPkt(efiPacket_t* pkt, const efiNack_t* user);

//! Decode the efiNack packet
int decodeefiNackPkt(const efiPacket_t* pkt, efiNack_t* user);

//! return the packet ID for the efiNack packet
#define getefiNackPktID() (EFI_PKT_NACK)

//! return the minimum encoded length for the efiNack packet
#define getefiNackMinDataLength() (2)

//! return the maximum encoded length for the efiNack packet
#define getefiNackMaxDataLength() (4)

/*!
 * Enumeration for scope signals in the EFI. The first signals match exactly
 * the enumerations of the EFI sensors.
 */
typedef enum
{
    EFI_SCOPE_FIRSTANALOG,                       //!< First analog scope signal number
    EFI_SCOPE_VOLT = EFI_SCOPE_FIRSTANALOG,      //!< Input voltage sensor, units of Volts
    EFI_SCOPE_MAT,                               //!< Manifold air temperature sensor, units of Celsius
    EFI_SCOPE_CHT1,                              //!< First cylinder head temperature sensor, units of Celsius
    EFI_SCOPE_CHT2,                              //!< Second cylinder head temperature sensor, units of Celsius
    EFI_SCOPE_MAP,                               //!< Manifold pressure sensor, units of kilo-Pascals
    EFI_SCOPE_FUELP,                             //!< Fuel pressure sensor, units of kilo-Pascals
    EFI_SCOPE_ANALOGTPS,                         //!< Analog throttle sensor, units of percent
    EFI_SCOPE_CPUTEMP,                           //!< Temperature of the CPU, units of Celsius
    EFI_SCOPE_SPARETEMP,                         //!< Spare temperature sensor, units of Celsius
    EFI_SCOPE_RESERVED2,                         
    EFI_SCOPE_RESERVED3,                         
    EFI_SCOPE_CURRENT,                           //!< Input current sensor, units of Amps
    EFI_SCOPE_12VOLT,                            //!< 12 Volt rail voltage sensor, units of Volts
    EFI_SCOPE_12CURRENT,                         //!< 12 Volt rail current sensor, units of Amps
    EFI_SCOPE_ANALOGBARO,                        //!< Analog barometric pressure sensor, units of kilo-Pascals
    EFI_SCOPE_RESERVED4,                         
    EFI_SCOPE_LASTANALOG = EFI_SCOPE_RESERVED4,  //!< Last analog scope signal number
    EFI_SCOPE_FIRSTDIGITAL,                      //!< First digital scope signal number
    EFI_SCOPE_IOENABLE = EFI_SCOPE_FIRSTDIGITAL, //!< IO enable scope signal
    EFI_SCOPE_CRANKSENSE1,                       //!< First crank sense scope signal
    EFI_SCOPE_CRANKSENSE2,                       //!< Second crank sense scope signal
    EFI_SCOPE_THROTTLEOUT,                       //!< Throttle PWM output scope signal
    EFI_SCOPE_THROTTLEIN,                        //!< Throttle PWM input scope signal
    EFI_SCOPE_COOLINGOUT,                        //!< Cooling PWM output scope signal
    EFI_SCOPE_EDGEERROR,                         //!< An output edge error was detected
    EFI_SCOPE_SPARK1,                            //!< First spark output scope signal
    EFI_SCOPE_SPARK2,                            //!< Second spark output scope signal
    EFI_SCOPE_SPARK3,                            //!< Third spark output scope signal
    EFI_SCOPE_INJECTOR1,                         //!< First injector output scope signal
    EFI_SCOPE_INJECTOR2,                         //!< Second injector output scope signal
    EFI_SCOPE_INJECTOR3,                         //!< Third injector output scope signal
    EFI_SCOPE_CRANKERROR1,                       //!< Error flag on first crank sense signal
    EFI_SCOPE_CRANKERROR2,                       //!< Error flag on second crank sense signal
    EFI_SCOPE_ASYNCSAMPLE,                       //!< Flag on whether this sample was asynchronous (bit is set) or synchronous (bit is clear)
    EFI_SCOPE_LASTDIGITAL = EFI_SCOPE_ASYNCSAMPLE,//!< Last digital scope signal number
    NUM_EFI_SCOPE_SIGNALS                        
} efiScopeEnum;

//! \return the title of a 'efiScopeEnum' enum entry, based on its value
const char* efiScopeEnum_EnumTitle(int value);

/*!
 * This packet is used to configure and enable the high speed oscilloscope.
 * Triggering scope mode when a previous scope capture is underway will cause
 * the previous capture to be discarded. If you ask for continuous scope
 * output, but lack the neccessary communications bandwidth, the scope output
 * will be intermittent. A single scope capture may take multiple packets to
 * completely report. Send this packet with zero length to request the current
 * oscilloscope setup.
 */
typedef struct
{
    unsigned     enable : 1;         //!< Set to enable the oscilloscope, for packets going to the EFI. For packets from the EFI this reports the running status of the scope.
    unsigned     single : 1;         //!< Set for a single oscilloscope reporting window. If this is set the oscilloscope will automatically disable after a single capture.
    unsigned     timewindow : 22;    //!< Time window the scope will report in microseconds.
    unsigned     triggerenable : 1;  //!< Set to enable triggering, if clear then the scope is always triggered (i.e. always generating data).
    unsigned     triggerfalling : 1; //!< Set to trigger on the falling edge, else the trigger is on the rising edge.
    efiScopeEnum triggerchannel;     //!< Scope channel used to trigger oscilloscope output, if `triggerenable` is set.
    uint16_t     triggerlevel;       //!< Level of the trigger channel that causes an oscilloscope trigger. For analog sensor signals this in raw ADC units, with 0 the lowest value from the ADC and 65535 the largest value from the ADC. For digital signals this is either 0 or 1.
    uint32_t     channels;           //!< A bitfield flag indicating which channels should be captured for the scope. The channel numbers follow `efiScopeEnum` enumeration, with channel zero being the least significant bit. Digital channels (`EFI_SCOPE_IOENABLE` and higher) are always reported in the data packet, but will not generate data packets unless they are set in this bitfield.
}efiOscilloscopeSetup_t;

//! Create the efiOscilloscopeSetup packet
void encodeefiOscilloscopeSetupPkt(efiPacket_t* pkt, const efiOscilloscopeSetup_t* user);

//! Decode the efiOscilloscopeSetup packet
int decodeefiOscilloscopeSetupPkt(const efiPacket_t* pkt, efiOscilloscopeSetup_t* user);

//! return the packet ID for the efiOscilloscopeSetup packet
#define getefiOscilloscopeSetupPktID() (EFI_PKT_OSCILLOSCOPE_SETUP)

//! return the minimum encoded length for the efiOscilloscopeSetup packet
#define getefiOscilloscopeSetupMinDataLength() (12)

//! return the maximum encoded length for the efiOscilloscopeSetup packet
#define getefiOscilloscopeSetupMaxDataLength() (12)

/*!
 * Enumeration for data words.
 */
typedef enum
{
    EFI_SCOPE_WORD_TIME,     //!< The first word in a series is the time offset in microseconds
    EFI_SCOPE_WORD_DIGITALS, //!< The second word in a series is the digital sample field
    EFI_SCOPE_WORD_FIRSTANALOG,//!< The third word in a series is the first analog sample field
    EFI_SCOPE_MAX_WORDS = 500 //!< A maximum of 500 words in a packet
} efiScopeDataWords;

/*!
 * This packet is used to report the oscilliscope data. If the scope is setup
 * for continuous output, but the communications hardware lacks the neccessary
 * bandwidth, the scope output will be intermittent. A single scope capture
 * will usually take multiple packets to completely report; however the exact
 * number of packets is not known until the scope capture is complete. The EFI
 * will begin sending scope data as soon as possible, and the transfer is
 * complete when the `lastPacket` flag is set.
 * 
 * The oscilloscope data packet can contain multiple samples of data. Since the
 * number of signals in each sample depends on the oscilloscope configuration
 * the data are encoded as a repeating array of 16-bit words. The first word is
 * always the time offset, which gives the time of the sample in microseconds,
 * relative to the `reftime` of the packet. The second word of the sample is
 * always the digital sample word, with the least significant bit corresponding
 * to the `EFI_SCOPE_IOENABLE` digital channel. The remaining words in the
 * sample provide the analog scope signals; the number of analog signals are
 * given by `numAnalogPerSample`, which will equal the number of analog
 * channels that were selected in the oscilloscope configuration packet. The
 * total number of words in the packet will always be a multiple of `2 +
 * numAnalogPerSample`. The analog signals are transmitted in their raw 16-bit
 * ADC form. You must use the sensor configurations to convert the sensors to
 * engineering units data.
 */
typedef struct
{
    unsigned lastPacket : 1;             //!< If set this packet is the last packet in a series of scope packets that report a single scope window of data.
    unsigned triggerTimeIncluded : 1;    //!< If set this packet contains the time reference of the triggering event.
    unsigned packetCount : 12;           //!< The number of this packet in the series of scope packets that report a single scope window of data. This value will be zero on the first scope packet.
    unsigned numAnalogPerSample : 5;     //!< The number of analog channels that are included per sample in this packet.
    unsigned numWords : 9;               //!< Number of words in this packet. The number of samples in the packet is equal to `numWords / (2 + numAnalogPerSample)`
    uint64_t refTime;                    //!< Time in microseconds since the system booted up. This is the reference time used for subsequent samples in the packet.
    uint64_t triggerTime;                //!< Time in microseconds since the system booted up when the trigger event occurred.
    uint16_t words[EFI_SCOPE_MAX_WORDS]; //!< The words of the samples. The interpretation of the sample words depends on the oscilloscope configuration.
}efiOscilloscopeData_t;

//! Create the efiOscilloscopeData packet
void encodeefiOscilloscopeDataPkt(efiPacket_t* pkt, const efiOscilloscopeData_t* user);

//! Decode the efiOscilloscopeData packet
int decodeefiOscilloscopeDataPkt(const efiPacket_t* pkt, efiOscilloscopeData_t* user);

//! return the packet ID for the efiOscilloscopeData packet
#define getefiOscilloscopeDataPktID() (EFI_PKT_OSCILLOSCOPE_DATA)

//! return the minimum encoded length for the efiOscilloscopeData packet
#define getefiOscilloscopeDataMinDataLength() (10)

//! return the maximum encoded length for the efiOscilloscopeData packet
#define getefiOscilloscopeDataMaxDataLength() (2*EFI_SCOPE_MAX_WORDS+16)

/*!
 * This packet gives data used for debugging. The interpretation of this packet
 * is variable.
 */
typedef struct
{
    uint32_t time;         //!< Time in microseconds of the debug output
    uint8_t  details[12];  //!< 12 bytes of data to use as the debugger sees fit
    char     comment[512]; //!< Human readable debug string
}efiDebug_t;

//! Create the efiDebug packet from parameters
void encodeefiDebugPkt(efiPacket_t* pkt, uint32_t time, const uint8_t details[12], const char comment[512]);

//! Decode the efiDebug packet to parameters
int decodeefiDebugPkt(const efiPacket_t* pkt, uint32_t* time, uint8_t details[12], char comment[512]);

//! return the packet ID for the efiDebug packet
#define getefiDebugPktID() (EFI_PKT_DEBUG)

//! return the minimum encoded length for the efiDebug packet
#define getefiDebugMinDataLength() (17)

//! return the maximum encoded length for the efiDebug packet
#define getefiDebugMaxDataLength() (528)

/*!
 * The test mode packet is used to engage special features for testing software
 * and hardware. In order to engage test mode the EFI must be unlocked, and the
 * engine must not be running. If the engine starts running while test mode is
 * active (as indicated by crank sense detection) the test mode will be
 * automatically canceled. Test mode can also be canceled by this packet, by
 * locking the EFI configuration, or by timeout. When test mode is active this
 * packet will be reported at the slow telemetry rate to indicate the test mode
 * status. The test mode status is always visible in the telemetry errors
 * packet. In addition you can send this packet with zero length to request the
 * current test mode status.
 */
typedef struct
{
    uint8_t  enabled;                          //!< Set to enable test mode. For report packets this is the test mode status.
    uint8_t  enableThrottleClosedCalibration;  //!< Set to enable automatic calibration of the throttle `closedPWMout` value.
    uint8_t  enableThrottleOpenCalibration;    //!< Set to enable automatic calibration of the throttle `openPWMout` value.
    uint8_t  skipCrankSense1;                  //!< Set to skip the processing of one event cycle for crank sense 1.
    uint8_t  skipCrankSense2;                  //!< Set to skip the processing of one event cycle for crank sense 2.
    uint8_t  addToothCrankSense1;              //!< Set to add an extraneous sensed tooth for crank sense 1.
    uint8_t  addToothCrankSense2;              //!< Set to add an extraneous sensed tooth for crank sense 1.
    uint16_t timeout;                          //!< Test mode timeout in seconds. For report packets this is the amount of time remaining in the test. If the test is user storage this is percent remaining.
    uint8_t  testCrankSenseNormal;             //!< Set to simulate crank sense events in the normal direction.
    uint8_t  testInjector1;                    //!< Set for injector1 test
    uint8_t  testInjector2;                    //!< Set for injector2 test
    uint8_t  testSpark1;                       //!< Set for spark1 test
    uint8_t  testSpark2;                       //!< Set for spark2 test
    uint8_t  testFuelpump;                     //!< Set to drive the fuel pump at a specific duty cycle
    uint8_t  testFuelflow;                     //!< Set to control the injector duty cycle to achieve a fuel pressure. This should be combined with testInjector1 or testInjector2 to specify which injector is used to regulate the fuel pressure.
    uint8_t  testCrankSenseReverse;            //!< Set to simulate crank sense events in the reverse direction.
    uint8_t  missFire1;                        //!< Number of skipped outputs for spark1; 0 - 3.
    uint8_t  missFire2;                        //!< Number of skipped outputs for spark2; 0 - 3.
    uint8_t  enableCowlFlap2ClosedCalibration; //!< Set to enable automatic calibration of the cowl flap 2 `closedPWM` value.
    uint8_t  enableCowlFlap2OpenCalibration;   //!< Set to enable automatic calibration of the cowl flap 2 `openPWM` value.
    uint8_t  enableCowlFlap1ClosedCalibration; //!< Set to enable automatic calibration of the cowl flap 1 `closedPWM` value.
    uint8_t  enableCowlFlap1OpenCalibration;   //!< Set to enable automatic calibration of the cowl flap 1 `openPWM` value.
    float    dutycycle;                        //!< For injector, spark, and fuel pump tests this is duty cycle in percentage to apply to the injector output, spark output, or fuel pump output
    float    speed;                            //!< The frequency, in events per minute, at which the test should be performed. This does not apply to the fuel pump test.
    float    fuelflowProGain;                  //!< Proportional feedback gain for fuel flow test from kPa of fuel pressure error to percentage of injector duty cycle
    float    fuelflowIntGain;                  //!< Integral feedback gain for fuel flow test from integral of kPa of fuel pressure error to percentage of injector duty cycle
    float    currentThreshold;                 //!< The current rise used to indicate that a hard stop was discovered, used with `enableThrottleClosedCalibration`, `enableThrottleOpenCalibration`, `enableCowlFlapClosedCalibration`, and `enableCowlFlapOpenCalibration`.
    float    actualClosedStop;                 //!< The actual position, in percent, of the closed hard stop used with `enableThrottleClosedCalibration` or `enableCowlFlapClosedCalibration`.
    float    actualOpenStop;                   //!< The actual position, in percent, of the open hard stop used with `enableThrottleOpenCalibration` or `enableCowlFlapOpenCalibration`.
    uint8_t  testInjector3;                    //!< Set for injector3 test
    uint8_t  testSpark3;                       //!< Set for spark3 test
    uint8_t  missFire3;                        //!< Number of skipped outputs for spark3; 0 - 3.
    uint8_t  testUserStorage;                  //!< Set to enable test of user storage space. This will exercise the entire EEPROM. Do not disonnect from power until the test is complete, otherwise some data in user stroage may be lost. This test cannot be done simultaneously with other tests.
}efiTestMode_t;

//! Create the efiTestMode packet
void encodeefiTestModePkt(efiPacket_t* pkt, const efiTestMode_t* user);

//! Decode the efiTestMode packet
int decodeefiTestModePkt(const efiPacket_t* pkt, efiTestMode_t* user);

//! return the packet ID for the efiTestMode packet
#define getefiTestModePktID() (EFI_PKT_TESTMODE)

//! return the minimum encoded length for the efiTestMode packet
#define getefiTestModeMinDataLength() (13)

//! return the maximum encoded length for the efiTestMode packet
#define getefiTestModeMaxDataLength() (16)

/*!
 * Request crank sense timing packets. To request the crank sense timing set
 * either `onesample` or `continuous`. To stop the crank sense timing packets
 * clear `continuous`
 */
typedef struct
{
    unsigned onesample : 1;  //!< Set this bit to request one capture of data.
    unsigned continuous : 1; //!< Set this bit to request crank sense timing packets be sent continuously.
    unsigned onsynclost : 1; //!< Set this bit to downlink the timing when synchronization is lost.
    unsigned sense2 : 1;     //!< Set this bit to request crank sense timing for sense 2, otherwise the data are requested for sense 1.
    uint16_t numIntervals;   //!< The requested number of sense intervals. For crank wheels IntelliJect will adjust this to be an even multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500.
}efiRequestCrankSenseTiming_t;

//! Create the efiRequestCrankSenseTiming packet from parameters
void encodeefiRequestCrankSenseTimingPkt(efiPacket_t* pkt, unsigned onesample, unsigned continuous, unsigned onsynclost, unsigned sense2, uint16_t numIntervals);

//! Decode the efiRequestCrankSenseTiming packet to parameters
int decodeefiRequestCrankSenseTimingPkt(const efiPacket_t* pkt, unsigned* onesample, unsigned* continuous, unsigned* onsynclost, unsigned* sense2, uint16_t* numIntervals);

//! return the packet ID for the efiRequestCrankSenseTiming packet
#define getefiRequestCrankSenseTimingPktID() (EFI_PKT_CRANKSENSETIMING)

//! return the minimum encoded length for the efiRequestCrankSenseTiming packet
#define getefiRequestCrankSenseTimingMinDataLength() (2)

//! return the maximum encoded length for the efiRequestCrankSenseTiming packet
#define getefiRequestCrankSenseTimingMaxDataLength() (2)

/*!
 * Enumerations for the crank sense timing packet
 */
typedef enum
{
    maxCrankSenseIntervals = 500 //!< Maximum sense intervals
} CrankSenseTimingConstants;

/*!
 * Details of the crank sense timing. To receive this packet you must first
 * send the `RequestCrankSenseTiming` packet. The crank sense timing details
 * simply give the time intervals of crank sense events (active edges). This is
 * most useful for crank wheels, but can be used for once-per-rev sensors.
 */
typedef struct
{
    uint8_t  onesample;                         //!< If set a single crank sense timing packet was sent.
    uint8_t  continuous;                        //!< If set crank sense timing packets will be sent continuously.
    uint8_t  onsynclost;                        //!< Set this bit to downlink the timing when synchronization is lost.
    uint8_t  sense2;                            //!< If set this timing data comes from crank sense 2, otherwise it is from crank sense 1.
    uint8_t  wheelenabled;                      //!< Set if this timing data are for a crank wheel, else it is for a once per rev sensor.
    uint16_t numIntervals;                      //!< The number of sense intervals in this packet. For crank wheels this will be a multiple of the number of physical teeth (totalCount - bigGapCount - smallGapCount). Maximum value is 500.
    float    crankOffset;                       //!< Angle of the crank sense in degrees of crank rotation after TDC, in the current crank rotation direction. For crank wheels this is the angle of the first tooth after the big gap.
    uint8_t  totalCount;                        //!< The number of teeth on the crank wheel plus the missing teeth. This is the full count, as though no synchronization teeth were removed.
    uint8_t  bigGapCount;                       //!< The number of teeth missing in the big gap of the crank wheel. The end of the big gap is the crank angle synchronization point. There must always be a non-zero big gap count.
    uint8_t  smallGapCount;                     //!< The number of teeth missing in the small gap of the crank wheel. The small gap count can be zero, in which case there is no small gap, and no intra-gap.
    uint8_t  intraGapCount;                     //!< The number of teeth between the big gap and the small gap for the current direction of rotation. Zero if there is no small gap.
    uint32_t time;                              //!< Time in milliseconds since the system booted up. This is the reference time for subsequent intervals.
    uint16_t intervals[maxCrankSenseIntervals]; //!< The time difference of each sense event from the previous event in microseconds.
}efiCrankSenseTiming_t;

//! Create the efiCrankSenseTiming packet
void encodeefiCrankSenseTimingPkt(efiPacket_t* pkt, const efiCrankSenseTiming_t* user);

//! Decode the efiCrankSenseTiming packet
int decodeefiCrankSenseTimingPkt(const efiPacket_t* pkt, efiCrankSenseTiming_t* user);

//! return the packet ID for the efiCrankSenseTiming packet
#define getefiCrankSenseTimingPktID() (EFI_PKT_CRANKSENSETIMING)

//! return the minimum encoded length for the efiCrankSenseTiming packet
#define getefiCrankSenseTimingMinDataLength() (8)

//! return the maximum encoded length for the efiCrankSenseTiming packet
#define getefiCrankSenseTimingMaxDataLength() (2*maxCrankSenseIntervals+12)

/*!
 * Enumeration for the IntelliJect interrupts
 */
typedef enum
{
    systickInt,  
    timer4Int,   
    timer1Int,   
    timer2Int,   
    timer3Int,   
    timer5Int,   
    ext01Int,    
    timer9Int,   
    uartInt,     
    i2ceventInt, 
    i2cerrorInt, 
    canrx0Int,   
    canrx1Int,   
    cantxInt,    
    sdioInt,     
    fpuInt,      
    numInterrupts 
} interruptIndices;

//! \return the title of a 'interruptIndices' enum entry, based on its value
const char* interruptIndices_EnumTitle(int value);

//! Create the efiInterruptDetails packet from parameters
void encodeefiInterruptDetailsPkt(efiPacket_t* pkt, const efiInterruptDetail_t intdetails[numInterrupts]);

//! Decode the efiInterruptDetails packet to parameters
int decodeefiInterruptDetailsPkt(const efiPacket_t* pkt, efiInterruptDetail_t intdetails[numInterrupts]);

//! return the packet ID for the efiInterruptDetails packet
#define getefiInterruptDetailsPktID() (EFI_PKT_INTERRUPTDETAILS)

//! return the minimum encoded length for the efiInterruptDetails packet
#define getefiInterruptDetailsMinDataLength() (numInterrupts*6)

//! return the maximum encoded length for the efiInterruptDetails packet
#define getefiInterruptDetailsMaxDataLength() (numInterrupts*6)

/*!
 * Enumeration for the bootloader commands
 */
typedef enum
{
    btldHeartBeat,   //!< Heart beat packet from the bootloader, sent once per second
    btldEraseCmd,    //!< Erase command to the bootloader
    btldEraseAck,    //!< Erase acknowledgement from the bootloader
    btldEraseNack,   //!< Erase failure notification from the bootloader
    btldProgramCmd,  //!< Program command to the bootloader
    btldProgramAck,  //!< Program acknowledgement from the bootloader
    btldProgramNack, //!< Program failure notification from the bootloader
    btldReset        //!< Command to reset to the main application
} bootloadercmds;

/*!
 * Settings used for bootloader communication
 */
typedef enum
{
    btldUartBaud = 57600,    //!< Bit rate used for the uart under the bootloader
    btldCanBaud = EFI_CAN_1M,//!< Bit rate used for the CAN under the bootloader
    btldCanInputId = 0x400,  //!< Identifier used for CAN input under the bootloader
    btldCanOutputId = 0x401  //!< Identifier used for CAN output under the bootloader
} bootloadercomms;

/*!
 * Packet for bootloader interactions. The bootloader is a separate application
 * within the EFI firmware load; and only the bootloader will send, or respond
 * to, this packet. The bootloader uses fixed communications configurations. On
 * serial the bit rate is always 57600 bits per second. On CAN the bit rate is
 * always 1Mbit, the identifier is always 11-bits, the input ID is always
 * 0x400, and the output ID is always 0x401. Only one device on the CAN bus can
 * be in bootloader mode at a time.
 * 
 * When the bootloader is running it will output this packet on a regular basis
 * as a heartbeat. In order to program the firmware you must watch for the
 * bootloader packet and use the serial number that it contains in any packet
 * sent back to the bootloader. In order to start the bootloader you use the
 * [reset command](#EFI_PKT_RESET) packet.
 */
typedef struct
{
    uint32_t       serialnumber;       //!< 32-bit serial number of the EFI. When the bootloader packet comes from the EFI this contains the serial number of the EFI. When the bootloader packet goes to the EFI this must have the correct EFI serial number in order for this packet to be obeyed.
    uint32_t       startaddress;       //!< Starting address for this packet. This is used for erase as well as program. For the heartbeat packet this will be address `0x0801001C`, and the datsize will be at least 16 bytes.
    uint32_t       datasize;           //!< Data size for this packet. This is used for erase as well as program. For the program packet this datasize cannot be more than 256. For the program nack packet this indicates the first byte which failed to program.
    uint8_t        version;            //!< Version of the bootloader from 0 to 255
    unsigned       hasprogramdata : 1; //!< Set if this packet includes program data
    bootloadercmds command;            //!< The purpose of this bootloader packet
    uint8_t        programdata[256];   //!< Program data, starting at startaddress
}efiBootloader_t;

//! Create the efiBootloader packet
void encodeefiBootloaderPkt(efiPacket_t* pkt, const efiBootloader_t* user);

//! Decode the efiBootloader packet
int decodeefiBootloaderPkt(const efiPacket_t* pkt, efiBootloader_t* user);

//! return the packet ID for the efiBootloader packet
#define getefiBootloaderPktID() (EFI_PKT_BOOTLOADER)

//! return the minimum encoded length for the efiBootloader packet
#define getefiBootloaderMinDataLength() (14)

//! return the maximum encoded length for the efiBootloader packet
#define getefiBootloaderMaxDataLength() (270)

/*!
 * This packet is at the beginning of every valid block of 512 bytes (except
 * the journal) of an SD card. This packet cannot be sent to or from the EFI.
 */
typedef struct
{
    uint16_t record;   //!< The record number identifies the recording. Consecutive packets from the same recording will have the same record number.
    uint32_t sequence; //!< SD sequence number, starts at 0 and increasing monotonically. If successive sequence numbers go down the boundary represents a wrap point.
}efiSDCardBlockData_t;

//! Create the efiSDCardBlockData packet from parameters
void encodeefiSDCardBlockDataPkt(efiPacket_t* pkt, uint16_t record, uint32_t sequence);

//! Decode the efiSDCardBlockData packet to parameters
int decodeefiSDCardBlockDataPkt(const efiPacket_t* pkt, uint16_t* record, uint32_t* sequence);

//! return the packet ID for the efiSDCardBlockData packet
#define getefiSDCardBlockDataPktID() (EFI_PKT_SDBLOCKDATA)

//! return the minimum encoded length for the efiSDCardBlockData packet
#define getefiSDCardBlockDataMinDataLength() (8)

//! return the maximum encoded length for the efiSDCardBlockData packet
#define getefiSDCardBlockDataMaxDataLength() (8)

//! Create the efiSensorAutoOffsets packet from parameters
void encodeefiSensorAutoOffsetsPkt(efiPacket_t* pkt, const float autooffsets[NUM_EFI_SENSORS]);

//! Decode the efiSensorAutoOffsets packet to parameters
int decodeefiSensorAutoOffsetsPkt(const efiPacket_t* pkt, float autooffsets[NUM_EFI_SENSORS]);

//! return the packet ID for the efiSensorAutoOffsets packet
#define getefiSensorAutoOffsetsPktID() (EFI_PKT_SENSORAUTOOFFSET)

//! return the minimum encoded length for the efiSensorAutoOffsets packet
#define getefiSensorAutoOffsetsMinDataLength() (2*NUM_EFI_SENSORS+8)

//! return the maximum encoded length for the efiSensorAutoOffsets packet
#define getefiSensorAutoOffsetsMaxDataLength() (2*NUM_EFI_SENSORS+8)

/*!
 * This packet provides the minimum amount of data needed to fire the spark and
 * run the injectors, before the entire EFI system and sensors are up and
 * running. This packet is never sent or received; it exists only in backup RAM
 * onboard the EFI.
 */
typedef struct
{
    uint8_t                 enablequickrestart;     //!< Set to enable quick start response
    uint8_t                 ioEnable;               //!< Global enable based on physical input
    uint8_t                 userEnable;             //!< User global enable.
    uint8_t                 spark1UserEnable;       //!< User enable for spark1.
    uint8_t                 spark2UserEnable;       //!< User enable for spark2.
    uint8_t                 spark3UserEnable;       //!< User enable for spark3.
    uint8_t                 userThrottleCmd;        //!< Set if a user throttle command is active.
    uint8_t                 userRPMCmd;             //!< Set if a user rpm command is active.
    float                   throttlecmd;            //!< The user commanded throttle in percent
    float                   rpmcmd;                 //!< Engine speed command in revolutions per minute
    uint8_t                 ignActiveHigh;          //!< Set if ignition is active high
    uint8_t                 spark3ConfigEnabled;    //!< Set if spark 3 is configured enabled
    uint8_t                 injector3ConfigEnabled; //!< Set if injector 3 is configured enabled
    efiCrankDirection       direction1;             //!< Direction information for crank 1
    efiCrankDirection       direction2;             //!< Direction information for crank 2
    uint16_t                pwmOut;                 //!< Throttle pwm output time in 4 microseconds
    uint32_t                crankPeriod;            //!< Crank period in 4 microseconds
    uint32_t                spark1delay;            //!< Time delay in 4 microseconds from the sense ISR to output of spark1
    uint32_t                spark2delay;            //!< Time delay in 4 microseconds from the sense ISR to output of spark2
    uint32_t                spark3delay;            //!< Time delay in 4 microseconds from the sense ISR to output of spark3
    uint32_t                injector1delay;         //!< Time delay in 4 microseconds from the sense ISR to output of injector1
    uint32_t                injector2delay;         //!< Time delay in 4 microseconds from the sense ISR to output of injector2
    uint32_t                injector3delay;         //!< Time delay in 4 microseconds from the sense ISR to output of injector3
    uint32_t                injector1period;        //!< Injection time in 4 microseconds for injector1
    uint32_t                injector2period;        //!< Injection time in 4 microseconds for injector2
    uint32_t                injector3period;        //!< Injection time in 4 microseconds for injector3
    uint32_t                sparkPeriod;            //!< Spark period in 4 microseconds
    uint8_t                 spark1usesense1;        //!< Set if spark 1 is being triggered by sense 1
    uint8_t                 spark2usesense1;        //!< Set if spark 2 is being triggered by sense 1
    uint8_t                 spark3usesense1;        //!< Set if spark 3 is being triggered by sense 1
    uint8_t                 injector1usesense1;     //!< Set if injector 1 is being triggered by sense 1
    uint8_t                 injector2usesense1;     //!< Set if injector 2 is being triggered by sense 1
    uint8_t                 injector3usesense1;     //!< Set if injector 3 is being triggered by sense 1
    uint8_t                 spark1usesense2;        //!< Set if spark 1 is being triggered by sense 2
    uint8_t                 spark2usesense2;        //!< Set if spark 2 is being triggered by sense 2
    uint8_t                 spark3usesense2;        //!< Set if spark 3 is being triggered by sense 2
    uint8_t                 injector1usesense2;     //!< Set if injector 1 is being triggered by sense 2
    uint8_t                 injector2usesense2;     //!< Set if injector 2 is being triggered by sense 2
    uint8_t                 injector3usesense2;     //!< Set if injector 3 is being triggered by sense 2
    efiCrankWheelSyncStatus wheel1SyncStatus;       //!< Synchronization status for crank wheel 1
    efiCrankWheelSyncStatus wheel2SyncStatus;       //!< Synchronization status for crank wheel 2
    efiCrankSense_t         crankSense1;            //!< Details of the crank sense 1 configuration
    efiCrankSense_t         crankSense2;            //!< Details of the crank sense 2 configuration
    uint8_t                 spark1sense1tooth;      //!< The crank wheel tooth, on crank sense 1, that schedules spark1
    uint8_t                 spark2sense1tooth;      //!< The crank wheel tooth, on crank sense 1, that schedules spark2
    uint8_t                 spark3sense1tooth;      //!< The crank wheel tooth, on crank sense 1, that schedules spark3
    uint8_t                 spark1sense2tooth;      //!< The crank wheel tooth, on crank sense 2, that schedules spark1
    uint8_t                 spark2sense2tooth;      //!< The crank wheel tooth, on crank sense 2, that schedules spark2
    uint8_t                 spark3sense2tooth;      //!< The crank wheel tooth, on crank sense 2, that schedules spark3
    uint8_t                 injector1sense1tooth;   //!< The crank wheel tooth, on crank sense 1, that schedules injector1
    uint8_t                 injector2sense1tooth;   //!< The crank wheel tooth, on crank sense 1, that schedules injector2
    uint8_t                 injector3sense1tooth;   //!< The crank wheel tooth, on crank sense 1, that schedules injector3
    uint8_t                 injector1sense2tooth;   //!< The crank wheel tooth, on crank sense 2, that schedules injector1
    uint8_t                 injector2sense2tooth;   //!< The crank wheel tooth, on crank sense 2, that schedules injector2
    uint8_t                 injector3sense2tooth;   //!< The crank wheel tooth, on crank sense 2, that schedules injector3
    uint32_t                revcountsincestart;     //!< Number of revolutions since the engine started
    uint32_t                secondssincestart;      //!< Seconds since the engine started
}efiQuickRestart_t;

//! Create the efiQuickRestart packet
void encodeefiQuickRestartPkt(efiPacket_t* pkt, const efiQuickRestart_t* user);

//! Decode the efiQuickRestart packet
int decodeefiQuickRestartPkt(const efiPacket_t* pkt, efiQuickRestart_t* user);

//! return the packet ID for the efiQuickRestart packet
#define getefiQuickRestartPktID() (EFI_PKT_QUICKRESTART)

//! return the minimum encoded length for the efiQuickRestart packet
#define getefiQuickRestartMinDataLength() (67)

//! return the maximum encoded length for the efiQuickRestart packet
#define getefiQuickRestartMaxDataLength() (67)

#ifdef __cplusplus
}
#endif
#endif // _EFICOMMS_H
