// eficompareutil.cpp was generated by ProtoGen version 3.1.d

#include "eficompareutil.hpp"
#include <sstream>
#include <iomanip>
#include <cstring>

//! Create a numeric string with a specific number of decimal places
static std::string to_formatted_string(double number, int precision);

/*!
 * Create a numeric string with a specific number of decimal places
 * \param number is the number to convert to string
 * \param precision is the number of decimal places to output
 * \return the number as a string
 */
std::string to_formatted_string(double number, int precision)
{
    // This function exists becuase of a bug in GCC which prevents this from working correctly:
    // string = (std::stringstream() << std::setprecision(7) << _pg_user1->indices[_pg_i]).str()

    std::stringstream stream;
    stream << std::setprecision(precision);
    stream << number;
    return stream.str();

}// to_formatted_string

/*!
 * Compare two efiDate_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiDate_t(const std::string& _pg_prename, const efiDate_t* _pg_user1, const efiDate_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->day != _pg_user2->day)
        _pg_report += _pg_prename + ":day"  + " '" + std::to_string(_pg_user1->day) + "' '" + std::to_string(_pg_user2->day) + "'\n";

    if(_pg_user1->month != _pg_user2->month)
        _pg_report += _pg_prename + ":month"  + " '" + std::to_string(_pg_user1->month) + "' '" + std::to_string(_pg_user2->month) + "'\n";

    if(_pg_user1->year != _pg_user2->year)
        _pg_report += _pg_prename + ":year"  + " '" + std::to_string(_pg_user1->year) + "' '" + std::to_string(_pg_user2->year) + "'\n";

    return _pg_report;

}// compareefiDate_t

/*!
 * Compare two efiDateTime_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiDateTime_t(const std::string& _pg_prename, const efiDateTime_t* _pg_user1, const efiDateTime_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->jiffytime != _pg_user2->jiffytime)
        _pg_report += _pg_prename + ":jiffytime"  + " '" + std::to_string(_pg_user1->jiffytime) + "' '" + std::to_string(_pg_user2->jiffytime) + "'\n";

    if(_pg_user1->day != _pg_user2->day)
        _pg_report += _pg_prename + ":day"  + " '" + std::to_string(_pg_user1->day) + "' '" + std::to_string(_pg_user2->day) + "'\n";

    if(_pg_user1->month != _pg_user2->month)
        _pg_report += _pg_prename + ":month"  + " '" + std::to_string(_pg_user1->month) + "' '" + std::to_string(_pg_user2->month) + "'\n";

    if(_pg_user1->year != _pg_user2->year)
        _pg_report += _pg_prename + ":year"  + " '" + std::to_string(_pg_user1->year) + "' '" + std::to_string(_pg_user2->year) + "'\n";

    return _pg_report;

}// compareefiDateTime_t

/*!
 * Compare two efiCrankSense_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiCrankSense_t(const std::string& _pg_prename, const efiCrankSense_t* _pg_user1, const efiCrankSense_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->enableWheel != _pg_user2->enableWheel)
        _pg_report += _pg_prename + ":enableWheel"  + " '" + std::to_string(_pg_user1->enableWheel) + "' '" + std::to_string(_pg_user2->enableWheel) + "'\n";

    if(_pg_user1->activeHigh != _pg_user2->activeHigh)
        _pg_report += _pg_prename + ":activeHigh"  + " '" + std::to_string(_pg_user1->activeHigh) + "' '" + std::to_string(_pg_user2->activeHigh) + "'\n";

    if(_pg_user1->disableSensor != _pg_user2->disableSensor)
        _pg_report += _pg_prename + ":disableSensor"  + " '" + std::to_string(_pg_user1->disableSensor) + "' '" + std::to_string(_pg_user2->disableSensor) + "'\n";

    if(_pg_user1->preferThisSensor != _pg_user2->preferThisSensor)
        _pg_report += _pg_prename + ":preferThisSensor"  + " '" + std::to_string(_pg_user1->preferThisSensor) + "' '" + std::to_string(_pg_user2->preferThisSensor) + "'\n";

    if(_pg_user1->senseDelay != _pg_user2->senseDelay)
        _pg_report += _pg_prename + ":senseDelay"  + " '" + std::to_string(_pg_user1->senseDelay) + "' '" + std::to_string(_pg_user2->senseDelay) + "'\n";

    if(_pg_user1->normalOffset != _pg_user2->normalOffset)
        _pg_report += _pg_prename + ":normalOffset"  + " '" + to_formatted_string(_pg_user1->normalOffset, 7) + "' '" + to_formatted_string(_pg_user2->normalOffset, 7) + "'\n";

    if(_pg_user1->reverseOffset != _pg_user2->reverseOffset)
        _pg_report += _pg_prename + ":reverseOffset"  + " '" + to_formatted_string(_pg_user1->reverseOffset, 7) + "' '" + to_formatted_string(_pg_user2->reverseOffset, 7) + "'\n";

    if(_pg_user1->totalCount != _pg_user2->totalCount)
        _pg_report += _pg_prename + ":totalCount"  + " '" + std::to_string(_pg_user1->totalCount) + "' '" + std::to_string(_pg_user2->totalCount) + "'\n";

    if(_pg_user1->bigGapCount != _pg_user2->bigGapCount)
        _pg_report += _pg_prename + ":bigGapCount"  + " '" + std::to_string(_pg_user1->bigGapCount) + "' '" + std::to_string(_pg_user2->bigGapCount) + "'\n";

    if(_pg_user1->smallGapCount != _pg_user2->smallGapCount)
        _pg_report += _pg_prename + ":smallGapCount"  + " '" + std::to_string(_pg_user1->smallGapCount) + "' '" + std::to_string(_pg_user2->smallGapCount) + "'\n";

    if(_pg_user1->normalIntraGapCount != _pg_user2->normalIntraGapCount)
        _pg_report += _pg_prename + ":normalIntraGapCount"  + " '" + std::to_string(_pg_user1->normalIntraGapCount) + "' '" + std::to_string(_pg_user2->normalIntraGapCount) + "'\n";

    if(_pg_user1->reverseIntraGapCount != _pg_user2->reverseIntraGapCount)
        _pg_report += _pg_prename + ":reverseIntraGapCount"  + " '" + std::to_string(_pg_user1->reverseIntraGapCount) + "' '" + std::to_string(_pg_user2->reverseIntraGapCount) + "'\n";

    return _pg_report;

}// compareefiCrankSense_t

/*!
 * Compare two efiTable1D_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiTable1D_t(const std::string& _pg_prename, const efiTable1D_t* _pg_user1, const efiTable1D_t* _pg_user2)
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    if(_pg_user1->enabled != _pg_user2->enabled)
        _pg_report += _pg_prename + ":enabled"  + " '" + std::to_string(_pg_user1->enabled) + "' '" + std::to_string(_pg_user2->enabled) + "'\n";

    if(_pg_user1->num != _pg_user2->num)
        _pg_report += _pg_prename + ":num"  + " '" + std::to_string(_pg_user1->num) + "' '" + std::to_string(_pg_user2->num) + "'\n";

    if(_pg_user1->num == _pg_user2->num)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_COLS) && (_pg_i < (unsigned)_pg_user1->num); _pg_i++)
        {
            if(_pg_user1->indices[_pg_i] != _pg_user2->indices[_pg_i])
                _pg_report += _pg_prename + ":indices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(_pg_user1->indices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user2->indices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":indices array dimension differs, array not compared\n";

    if(_pg_user1->num == _pg_user2->num)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_COLS) && (_pg_i < (unsigned)_pg_user1->num); _pg_i++)
        {
            if(_pg_user1->data[_pg_i] != _pg_user2->data[_pg_i])
                _pg_report += _pg_prename + ":data"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(_pg_user1->data[_pg_i], 7) + "' '" + to_formatted_string(_pg_user2->data[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":data array dimension differs, array not compared\n";

    return _pg_report;

}// compareefiTable1D_t

/*!
 * Compare two EngineWear packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiEngineWearPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiEngineWear_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "EngineWear";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiEngineWearPkt(_pg_pkt1, &_pg_struct1) || !decodeefiEngineWearPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiEngineWear_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiEngineWearPkt

/*!
 * Compare two efiEngineWear_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiEngineWear_t(const std::string& _pg_prename, const efiEngineWear_t* _pg_user1, const efiEngineWear_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->hobbs != _pg_user2->hobbs)
        _pg_report += _pg_prename + ":hobbs"  + " '" + std::to_string(_pg_user1->hobbs) + "' '" + std::to_string(_pg_user2->hobbs) + "'\n";

    if(_pg_user1->revcount != _pg_user2->revcount)
        _pg_report += _pg_prename + ":revcount"  + " '" + std::to_string(_pg_user1->revcount) + "' '" + std::to_string(_pg_user2->revcount) + "'\n";

    if(_pg_user1->hotTime != _pg_user2->hotTime)
        _pg_report += _pg_prename + ":hotTime"  + " '" + std::to_string(_pg_user1->hotTime) + "' '" + std::to_string(_pg_user2->hotTime) + "'\n";

    if(_pg_user1->highLoadTime != _pg_user2->highLoadTime)
        _pg_report += _pg_prename + ":highLoadTime"  + " '" + std::to_string(_pg_user1->highLoadTime) + "' '" + std::to_string(_pg_user2->highLoadTime) + "'\n";

    if(_pg_user1->peakCHT != _pg_user2->peakCHT)
        _pg_report += _pg_prename + ":peakCHT"  + " '" + to_formatted_string(_pg_user1->peakCHT, 7) + "' '" + to_formatted_string(_pg_user2->peakCHT, 7) + "'\n";

    if(_pg_user1->numStarts != _pg_user2->numStarts)
        _pg_report += _pg_prename + ":numStarts"  + " '" + std::to_string(_pg_user1->numStarts) + "' '" + std::to_string(_pg_user2->numStarts) + "'\n";

    return _pg_report;

}// compareefiEngineWear_t

/*!
 * Compare two efiMaintenanceItemStatus_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiMaintenanceItemStatus_t(const std::string& _pg_prename, const efiMaintenanceItemStatus_t* _pg_user1, const efiMaintenanceItemStatus_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->triggered != _pg_user2->triggered)
        _pg_report += _pg_prename + ":triggered"  + " '" + std::to_string(_pg_user1->triggered) + "' '" + std::to_string(_pg_user2->triggered) + "'\n";

    if(_pg_user1->index != _pg_user2->index)
        _pg_report += _pg_prename + ":index"  + " '" + std::to_string(_pg_user1->index) + "' '" + std::to_string(_pg_user2->index) + "'\n";

    _pg_report += compareefiDateTime_t(_pg_prename + ":servicetime", &_pg_user1->servicetime, &_pg_user2->servicetime);

    if(_pg_user1->lastdone != _pg_user2->lastdone)
        _pg_report += _pg_prename + ":lastdone"  + " '" + std::to_string(_pg_user1->lastdone) + "' '" + std::to_string(_pg_user2->lastdone) + "'\n";

    if(std::string(_pg_user1->name).compare(_pg_user2->name) != 0)
        _pg_report += _pg_prename + ":name strings differ\n";

    return _pg_report;

}// compareefiMaintenanceItemStatus_t

/*!
 * Compare two MaintenanceStatus packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiMaintenanceStatusPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiMaintenanceStatus_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "MaintenanceStatus";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiMaintenanceStatusPkt(_pg_pkt1, &_pg_struct1) || !decodeefiMaintenanceStatusPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiMaintenanceStatus_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiMaintenanceStatusPkt

/*!
 * Compare two efiMaintenanceStatus_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiMaintenanceStatus_t(const std::string& _pg_prename, const efiMaintenanceStatus_t* _pg_user1, const efiMaintenanceStatus_t* _pg_user2)
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    if(_pg_user1->domaintenance != _pg_user2->domaintenance)
        _pg_report += _pg_prename + ":domaintenance"  + " '" + std::to_string(_pg_user1->domaintenance) + "' '" + std::to_string(_pg_user2->domaintenance) + "'\n";

    if(_pg_user1->setEngineSerial != _pg_user2->setEngineSerial)
        _pg_report += _pg_prename + ":setEngineSerial"  + " '" + std::to_string(_pg_user1->setEngineSerial) + "' '" + std::to_string(_pg_user2->setEngineSerial) + "'\n";

    if(_pg_user1->numItems != _pg_user2->numItems)
        _pg_report += _pg_prename + ":numItems"  + " '" + std::to_string(_pg_user1->numItems) + "' '" + std::to_string(_pg_user2->numItems) + "'\n";

    if(_pg_user1->engineSerial != _pg_user2->engineSerial)
        _pg_report += _pg_prename + ":engineSerial"  + " '" + std::to_string(_pg_user1->engineSerial) + "' '" + std::to_string(_pg_user2->engineSerial) + "'\n";

    // List of maintenance item status
    for(_pg_i = 0; _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_report += compareefiMaintenanceItemStatus_t(_pg_prename + ":MaintenanceItemStatus" + "[" + std::to_string(_pg_i) + "]", &_pg_user1->MaintenanceItemStatus[_pg_i], &_pg_user2->MaintenanceItemStatus[_pg_i]);

    return _pg_report;

}// compareefiMaintenanceStatus_t

/*!
 * Compare two LogEntry packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiLogEntryPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiLogEntry_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "LogEntry";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiLogEntryPkt(_pg_pkt1, &_pg_struct1) || !decodeefiLogEntryPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiLogEntry_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiLogEntryPkt

/*!
 * Compare two efiLogEntry_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiLogEntry_t(const std::string& _pg_prename, const efiLogEntry_t* _pg_user1, const efiLogEntry_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->cmd != _pg_user2->cmd)
        _pg_report += _pg_prename + ":cmd"  + " '" + std::to_string(_pg_user1->cmd) + "' '" + std::to_string(_pg_user2->cmd) + "'\n";

    if(_pg_user1->index != _pg_user2->index)
        _pg_report += _pg_prename + ":index"  + " '" + std::to_string(_pg_user1->index) + "' '" + std::to_string(_pg_user2->index) + "'\n";

    _pg_report += compareefiDateTime_t(_pg_prename + ":time", &_pg_user1->time, &_pg_user2->time);

    if(std::string(_pg_user1->name).compare(_pg_user2->name) != 0)
        _pg_report += _pg_prename + ":name strings differ\n";

    if(std::string(_pg_user1->description).compare(_pg_user2->description) != 0)
        _pg_report += _pg_prename + ":description strings differ\n";

    return _pg_report;

}// compareefiLogEntry_t

/*!
 * Compare two File packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiFilePkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiFile_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "File";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiFilePkt(_pg_pkt1, &_pg_struct1) || !decodeefiFilePkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiFile_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiFilePkt

/*!
 * Compare two efiFile_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiFile_t(const std::string& _pg_prename, const efiFile_t* _pg_user1, const efiFile_t* _pg_user2)
{
    std::string _pg_report;

    _pg_report += compareefiDate_t(_pg_prename + ":date", &_pg_user1->date, &_pg_user2->date);

    if(std::string(_pg_user1->filename).compare(_pg_user2->filename) != 0)
        _pg_report += _pg_prename + ":filename strings differ\n";

    return _pg_report;

}// compareefiFile_t

/*!
 * Compare two Comment packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiCommentPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiComment_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "Comment";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiCommentPkt(_pg_pkt1, &_pg_struct1) || !decodeefiCommentPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiComment_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiCommentPkt

/*!
 * Compare two efiComment_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiComment_t(const std::string& _pg_prename, const efiComment_t* _pg_user1, const efiComment_t* _pg_user2)
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        if(_pg_user1->userdata[_pg_i] != _pg_user2->userdata[_pg_i])
            _pg_report += _pg_prename + ":userdata"  + "[" + std::to_string(_pg_i) + "]" + " '" + std::to_string(_pg_user1->userdata[_pg_i]) + "' '" + std::to_string(_pg_user2->userdata[_pg_i]) + "'\n";

    if(std::string(_pg_user1->comment).compare(_pg_user2->comment) != 0)
        _pg_report += _pg_prename + ":comment strings differ\n";

    return _pg_report;

}// compareefiComment_t

/*!
 * Compare two LockControl packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiLockControlPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiLockControl_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "LockControl";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiLockControlPkt(_pg_pkt1, &_pg_struct1) || !decodeefiLockControlPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiLockControl_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiLockControlPkt

/*!
 * Compare two efiLockControl_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiLockControl_t(const std::string& _pg_prename, const efiLockControl_t* _pg_user1, const efiLockControl_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->tablesProtection != _pg_user2->tablesProtection)
        _pg_report += _pg_prename + ":tablesProtection"  + " '" + std::to_string(_pg_user1->tablesProtection) + "' '" + std::to_string(_pg_user2->tablesProtection) + "'\n";

    if(_pg_user1->governorProtection != _pg_user2->governorProtection)
        _pg_report += _pg_prename + ":governorProtection"  + " '" + std::to_string(_pg_user1->governorProtection) + "' '" + std::to_string(_pg_user2->governorProtection) + "'\n";

    if(_pg_user1->throttleProtection != _pg_user2->throttleProtection)
        _pg_report += _pg_prename + ":throttleProtection"  + " '" + std::to_string(_pg_user1->throttleProtection) + "' '" + std::to_string(_pg_user2->throttleProtection) + "'\n";

    if(_pg_user1->engineProtection != _pg_user2->engineProtection)
        _pg_report += _pg_prename + ":engineProtection"  + " '" + std::to_string(_pg_user1->engineProtection) + "' '" + std::to_string(_pg_user2->engineProtection) + "'\n";

    if(_pg_user1->injectorProtection != _pg_user2->injectorProtection)
        _pg_report += _pg_prename + ":injectorProtection"  + " '" + std::to_string(_pg_user1->injectorProtection) + "' '" + std::to_string(_pg_user2->injectorProtection) + "'\n";

    if(_pg_user1->pumpProtection != _pg_user2->pumpProtection)
        _pg_report += _pg_prename + ":pumpProtection"  + " '" + std::to_string(_pg_user1->pumpProtection) + "' '" + std::to_string(_pg_user2->pumpProtection) + "'\n";

    if(_pg_user1->sensorsProtection != _pg_user2->sensorsProtection)
        _pg_report += _pg_prename + ":sensorsProtection"  + " '" + std::to_string(_pg_user1->sensorsProtection) + "' '" + std::to_string(_pg_user2->sensorsProtection) + "'\n";

    if(_pg_user1->commsProtection != _pg_user2->commsProtection)
        _pg_report += _pg_prename + ":commsProtection"  + " '" + std::to_string(_pg_user1->commsProtection) + "' '" + std::to_string(_pg_user2->commsProtection) + "'\n";

    if(_pg_user1->maintenanceProtection != _pg_user2->maintenanceProtection)
        _pg_report += _pg_prename + ":maintenanceProtection"  + " '" + std::to_string(_pg_user1->maintenanceProtection) + "' '" + std::to_string(_pg_user2->maintenanceProtection) + "'\n";

    if(_pg_user1->coolingProtection != _pg_user2->coolingProtection)
        _pg_report += _pg_prename + ":coolingProtection"  + " '" + std::to_string(_pg_user1->coolingProtection) + "' '" + std::to_string(_pg_user2->coolingProtection) + "'\n";

    if(std::string(_pg_user1->password).compare(_pg_user2->password) != 0)
        _pg_report += _pg_prename + ":password strings differ\n";

    return _pg_report;

}// compareefiLockControl_t

/*!
 * Compare two ConfigHash packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiConfigHashPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiConfigHash_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "ConfigHash";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiConfigHashPkt(_pg_pkt1, &_pg_struct1) || !decodeefiConfigHashPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiConfigHash_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiConfigHashPkt

/*!
 * Compare two efiConfigHash_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiConfigHash_t(const std::string& _pg_prename, const efiConfigHash_t* _pg_user1, const efiConfigHash_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->storedParameterHash != _pg_user2->storedParameterHash)
        _pg_report += _pg_prename + ":storedParameterHash"  + " '" + std::to_string(_pg_user1->storedParameterHash) + "' '" + std::to_string(_pg_user2->storedParameterHash) + "'\n";

    if(_pg_user1->actualParameterHash != _pg_user2->actualParameterHash)
        _pg_report += _pg_prename + ":actualParameterHash"  + " '" + std::to_string(_pg_user1->actualParameterHash) + "' '" + std::to_string(_pg_user2->actualParameterHash) + "'\n";

    return _pg_report;

}// compareefiConfigHash_t

/*!
 * Compare two PumpConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiPumpConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiPumpConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "PumpConfiguration";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiPumpConfigurationPkt(_pg_pkt1, &_pg_struct1) || !decodeefiPumpConfigurationPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiPumpConfiguration_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiPumpConfigurationPkt

/*!
 * Compare two efiPumpConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiPumpConfiguration_t(const std::string& _pg_prename, const efiPumpConfiguration_t* _pg_user1, const efiPumpConfiguration_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->fuelPressureCmd != _pg_user2->fuelPressureCmd)
        _pg_report += _pg_prename + ":fuelPressureCmd"  + " '" + to_formatted_string(_pg_user1->fuelPressureCmd, 7) + "' '" + to_formatted_string(_pg_user2->fuelPressureCmd, 7) + "'\n";

    if(_pg_user1->fuelPressureErrorThreshold != _pg_user2->fuelPressureErrorThreshold)
        _pg_report += _pg_prename + ":fuelPressureErrorThreshold"  + " '" + to_formatted_string(_pg_user1->fuelPressureErrorThreshold, 7) + "' '" + to_formatted_string(_pg_user2->fuelPressureErrorThreshold, 7) + "'\n";

    if(_pg_user1->minDutyCycle != _pg_user2->minDutyCycle)
        _pg_report += _pg_prename + ":minDutyCycle"  + " '" + to_formatted_string(_pg_user1->minDutyCycle, 7) + "' '" + to_formatted_string(_pg_user2->minDutyCycle, 7) + "'\n";

    if(_pg_user1->maxDutyCycle != _pg_user2->maxDutyCycle)
        _pg_report += _pg_prename + ":maxDutyCycle"  + " '" + to_formatted_string(_pg_user1->maxDutyCycle, 7) + "' '" + to_formatted_string(_pg_user2->maxDutyCycle, 7) + "'\n";

    if(_pg_user1->fuelPressureBangBangThreshold != _pg_user2->fuelPressureBangBangThreshold)
        _pg_report += _pg_prename + ":fuelPressureBangBangThreshold"  + " '" + to_formatted_string(_pg_user1->fuelPressureBangBangThreshold, 7) + "' '" + to_formatted_string(_pg_user2->fuelPressureBangBangThreshold, 7) + "'\n";

    if(_pg_user1->proGain != _pg_user2->proGain)
        _pg_report += _pg_prename + ":proGain"  + " '" + to_formatted_string(_pg_user1->proGain, 7) + "' '" + to_formatted_string(_pg_user2->proGain, 7) + "'\n";

    if(_pg_user1->intGain != _pg_user2->intGain)
        _pg_report += _pg_prename + ":intGain"  + " '" + to_formatted_string(_pg_user1->intGain, 7) + "' '" + to_formatted_string(_pg_user2->intGain, 7) + "'\n";

    if(_pg_user1->forGain != _pg_user2->forGain)
        _pg_report += _pg_prename + ":forGain"  + " '" + to_formatted_string(_pg_user1->forGain, 7) + "' '" + to_formatted_string(_pg_user2->forGain, 7) + "'\n";

    if(_pg_user1->rpmEnablesPump != _pg_user2->rpmEnablesPump)
        _pg_report += _pg_prename + ":rpmEnablesPump"  + " '" + std::to_string(_pg_user1->rpmEnablesPump) + "' '" + std::to_string(_pg_user2->rpmEnablesPump) + "'\n";

    if(_pg_user1->primeTime != _pg_user2->primeTime)
        _pg_report += _pg_prename + ":primeTime"  + " '" + std::to_string(_pg_user1->primeTime) + "' '" + std::to_string(_pg_user2->primeTime) + "'\n";

    if(_pg_user1->maxIfFailure != _pg_user2->maxIfFailure)
        _pg_report += _pg_prename + ":maxIfFailure"  + " '" + std::to_string(_pg_user1->maxIfFailure) + "' '" + std::to_string(_pg_user2->maxIfFailure) + "'\n";

    if(_pg_user1->positiveRateLimit != _pg_user2->positiveRateLimit)
        _pg_report += _pg_prename + ":positiveRateLimit"  + " '" + to_formatted_string(_pg_user1->positiveRateLimit, 7) + "' '" + to_formatted_string(_pg_user2->positiveRateLimit, 7) + "'\n";

    if(_pg_user1->negativeRateLimit != _pg_user2->negativeRateLimit)
        _pg_report += _pg_prename + ":negativeRateLimit"  + " '" + to_formatted_string(_pg_user1->negativeRateLimit, 7) + "' '" + to_formatted_string(_pg_user2->negativeRateLimit, 7) + "'\n";

    if(_pg_user1->_outputRateLimit != _pg_user2->_outputRateLimit)
        _pg_report += _pg_prename + ":_outputRateLimit"  + " '" + to_formatted_string(_pg_user1->_outputRateLimit, 7) + "' '" + to_formatted_string(_pg_user2->_outputRateLimit, 7) + "'\n";

    if(_pg_user1->pwmPeriod != _pg_user2->pwmPeriod)
        _pg_report += _pg_prename + ":pwmPeriod"  + " '" + std::to_string(_pg_user1->pwmPeriod) + "' '" + std::to_string(_pg_user2->pwmPeriod) + "'\n";

    return _pg_report;

}// compareefiPumpConfiguration_t

/*!
 * Compare two efiCANconfig_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiCANconfig_t(const std::string& _pg_prename, const efiCANconfig_t* _pg_user1, const efiCANconfig_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->baud != _pg_user2->baud)
        _pg_report += _pg_prename + ":baud"  + " '" + std::to_string(_pg_user1->baud) + "' '" + std::to_string(_pg_user2->baud) + "'\n";

    if(_pg_user1->typeShift != _pg_user2->typeShift)
        _pg_report += _pg_prename + ":typeShift"  + " '" + std::to_string(_pg_user1->typeShift) + "' '" + std::to_string(_pg_user2->typeShift) + "'\n";

    if(_pg_user1->longid != _pg_user2->longid)
        _pg_report += _pg_prename + ":longid"  + " '" + std::to_string(_pg_user1->longid) + "' '" + std::to_string(_pg_user2->longid) + "'\n";

    if(_pg_user1->disableNativeInput != _pg_user2->disableNativeInput)
        _pg_report += _pg_prename + ":disableNativeInput"  + " '" + std::to_string(_pg_user1->disableNativeInput) + "' '" + std::to_string(_pg_user2->disableNativeInput) + "'\n";

    if(_pg_user1->inputBaseId != _pg_user2->inputBaseId)
        _pg_report += _pg_prename + ":inputBaseId"  + " '" + std::to_string(_pg_user1->inputBaseId) + "' '" + std::to_string(_pg_user2->inputBaseId) + "'\n";

    if(_pg_user1->disableNativeOutput != _pg_user2->disableNativeOutput)
        _pg_report += _pg_prename + ":disableNativeOutput"  + " '" + std::to_string(_pg_user1->disableNativeOutput) + "' '" + std::to_string(_pg_user2->disableNativeOutput) + "'\n";

    if(_pg_user1->outputBaseId != _pg_user2->outputBaseId)
        _pg_report += _pg_prename + ":outputBaseId"  + " '" + std::to_string(_pg_user1->outputBaseId) + "' '" + std::to_string(_pg_user2->outputBaseId) + "'\n";

    if(_pg_user1->disableNativeBroadcast != _pg_user2->disableNativeBroadcast)
        _pg_report += _pg_prename + ":disableNativeBroadcast"  + " '" + std::to_string(_pg_user1->disableNativeBroadcast) + "' '" + std::to_string(_pg_user2->disableNativeBroadcast) + "'\n";

    if(_pg_user1->broadcastBaseId != _pg_user2->broadcastBaseId)
        _pg_report += _pg_prename + ":broadcastBaseId"  + " '" + std::to_string(_pg_user1->broadcastBaseId) + "' '" + std::to_string(_pg_user2->broadcastBaseId) + "'\n";

    if(_pg_user1->forcePacketOverCAN != _pg_user2->forcePacketOverCAN)
        _pg_report += _pg_prename + ":forcePacketOverCAN"  + " '" + std::to_string(_pg_user1->forcePacketOverCAN) + "' '" + std::to_string(_pg_user2->forcePacketOverCAN) + "'\n";

    if(_pg_user1->cmdAndTmOnly != _pg_user2->cmdAndTmOnly)
        _pg_report += _pg_prename + ":cmdAndTmOnly"  + " '" + std::to_string(_pg_user1->cmdAndTmOnly) + "' '" + std::to_string(_pg_user2->cmdAndTmOnly) + "'\n";

    if(_pg_user1->enableGCU != _pg_user2->enableGCU)
        _pg_report += _pg_prename + ":enableGCU"  + " '" + std::to_string(_pg_user1->enableGCU) + "' '" + std::to_string(_pg_user2->enableGCU) + "'\n";

    if(_pg_user1->enablePE3ECU != _pg_user2->enablePE3ECU)
        _pg_report += _pg_prename + ":enablePE3ECU"  + " '" + std::to_string(_pg_user1->enablePE3ECU) + "' '" + std::to_string(_pg_user2->enablePE3ECU) + "'\n";

    if(_pg_user1->enableCurrawongECU != _pg_user2->enableCurrawongECU)
        _pg_report += _pg_prename + ":enableCurrawongECU"  + " '" + std::to_string(_pg_user1->enableCurrawongECU) + "' '" + std::to_string(_pg_user2->enableCurrawongECU) + "'\n";

    if(_pg_user1->enablePiccoloECU != _pg_user2->enablePiccoloECU)
        _pg_report += _pg_prename + ":enablePiccoloECU"  + " '" + std::to_string(_pg_user1->enablePiccoloECU) + "' '" + std::to_string(_pg_user2->enablePiccoloECU) + "'\n";

    if(_pg_user1->alternativeProtocolAddress != _pg_user2->alternativeProtocolAddress)
        _pg_report += _pg_prename + ":alternativeProtocolAddress"  + " '" + std::to_string(_pg_user1->alternativeProtocolAddress) + "' '" + std::to_string(_pg_user2->alternativeProtocolAddress) + "'\n";

    return _pg_report;

}// compareefiCANconfig_t

/*!
 * Compare two CommConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiCommConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiCommConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "CommConfiguration";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiCommConfigurationPkt(_pg_pkt1, &_pg_struct1) || !decodeefiCommConfigurationPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiCommConfiguration_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiCommConfigurationPkt

/*!
 * Compare two efiCommConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiCommConfiguration_t(const std::string& _pg_prename, const efiCommConfiguration_t* _pg_user1, const efiCommConfiguration_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->disableSDRecording != _pg_user2->disableSDRecording)
        _pg_report += _pg_prename + ":disableSDRecording"  + " '" + std::to_string(_pg_user1->disableSDRecording) + "' '" + std::to_string(_pg_user2->disableSDRecording) + "'\n";

    if(_pg_user1->fastTelemetrySDRate != _pg_user2->fastTelemetrySDRate)
        _pg_report += _pg_prename + ":fastTelemetrySDRate"  + " '" + std::to_string(_pg_user1->fastTelemetrySDRate) + "' '" + std::to_string(_pg_user2->fastTelemetrySDRate) + "'\n";

    if(_pg_user1->fastTelemetryRate != _pg_user2->fastTelemetryRate)
        _pg_report += _pg_prename + ":fastTelemetryRate"  + " '" + std::to_string(_pg_user1->fastTelemetryRate) + "' '" + std::to_string(_pg_user2->fastTelemetryRate) + "'\n";

    if(_pg_user1->recordSDAlways != _pg_user2->recordSDAlways)
        _pg_report += _pg_prename + ":recordSDAlways"  + " '" + std::to_string(_pg_user1->recordSDAlways) + "' '" + std::to_string(_pg_user2->recordSDAlways) + "'\n";

    if(_pg_user1->slowTelemetrySDRate != _pg_user2->slowTelemetrySDRate)
        _pg_report += _pg_prename + ":slowTelemetrySDRate"  + " '" + std::to_string(_pg_user1->slowTelemetrySDRate) + "' '" + std::to_string(_pg_user2->slowTelemetrySDRate) + "'\n";

    if(_pg_user1->slowTelemetryRate != _pg_user2->slowTelemetryRate)
        _pg_report += _pg_prename + ":slowTelemetryRate"  + " '" + std::to_string(_pg_user1->slowTelemetryRate) + "' '" + std::to_string(_pg_user2->slowTelemetryRate) + "'\n";

    if(_pg_user1->useSummaryPackets != _pg_user2->useSummaryPackets)
        _pg_report += _pg_prename + ":useSummaryPackets"  + " '" + std::to_string(_pg_user1->useSummaryPackets) + "' '" + std::to_string(_pg_user2->useSummaryPackets) + "'\n";

    if(_pg_user1->setToDefault != _pg_user2->setToDefault)
        _pg_report += _pg_prename + ":setToDefault"  + " '" + std::to_string(_pg_user1->setToDefault) + "' '" + std::to_string(_pg_user2->setToDefault) + "'\n";

    if(_pg_user1->enableCurrawongECU != _pg_user2->enableCurrawongECU)
        _pg_report += _pg_prename + ":enableCurrawongECU"  + " '" + std::to_string(_pg_user1->enableCurrawongECU) + "' '" + std::to_string(_pg_user2->enableCurrawongECU) + "'\n";

    if(_pg_user1->uartBaud != _pg_user2->uartBaud)
        _pg_report += _pg_prename + ":uartBaud"  + " '" + std::to_string(_pg_user1->uartBaud) + "' '" + std::to_string(_pg_user2->uartBaud) + "'\n";

    // Configuration data for CAN communciations
    _pg_report += compareefiCANconfig_t(_pg_prename + ":CANconfig", &_pg_user1->CANconfig, &_pg_user2->CANconfig);

    return _pg_report;

}// compareefiCommConfiguration_t

/*!
 * Compare two SensorConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiSensorConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiSensorConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "SensorConfiguration";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiSensorConfigurationPkt(_pg_pkt1, &_pg_struct1) || !decodeefiSensorConfigurationPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiSensorConfiguration_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiSensorConfigurationPkt

/*!
 * Compare two efiSensorConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiSensorConfiguration_t(const std::string& _pg_prename, const efiSensorConfiguration_t* _pg_user1, const efiSensorConfiguration_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->enabled != _pg_user2->enabled)
        _pg_report += _pg_prename + ":enabled"  + " '" + std::to_string(_pg_user1->enabled) + "' '" + std::to_string(_pg_user2->enabled) + "'\n";

    if(_pg_user1->kty84 != _pg_user2->kty84)
        _pg_report += _pg_prename + ":kty84"  + " '" + std::to_string(_pg_user1->kty84) + "' '" + std::to_string(_pg_user2->kty84) + "'\n";

    if(_pg_user1->sealedGauge != _pg_user2->sealedGauge)
        _pg_report += _pg_prename + ":sealedGauge"  + " '" + std::to_string(_pg_user1->sealedGauge) + "' '" + std::to_string(_pg_user2->sealedGauge) + "'\n";

    if(_pg_user1->sensor != _pg_user2->sensor)
        _pg_report += _pg_prename + ":sensor"  + " '" + std::to_string(_pg_user1->sensor) + "' '" + std::to_string(_pg_user2->sensor) + "'\n";

    if(_pg_user1->filterlpf != _pg_user2->filterlpf)
        _pg_report += _pg_prename + ":filterlpf"  + " '" + to_formatted_string(_pg_user1->filterlpf, 7) + "' '" + to_formatted_string(_pg_user2->filterlpf, 7) + "'\n";

    if(_pg_user1->offset != _pg_user2->offset)
        _pg_report += _pg_prename + ":offset"  + " '" + to_formatted_string(_pg_user1->offset, 7) + "' '" + to_formatted_string(_pg_user2->offset, 7) + "'\n";

    if(_pg_user1->gain != _pg_user2->gain)
        _pg_report += _pg_prename + ":gain"  + " '" + to_formatted_string(_pg_user1->gain, 7) + "' '" + to_formatted_string(_pg_user2->gain, 7) + "'\n";

    if(_pg_user1->failedvalue != _pg_user2->failedvalue)
        _pg_report += _pg_prename + ":failedvalue"  + " '" + to_formatted_string(_pg_user1->failedvalue, 7) + "' '" + to_formatted_string(_pg_user2->failedvalue, 7) + "'\n";

    if(_pg_user1->min != _pg_user2->min)
        _pg_report += _pg_prename + ":min"  + " '" + to_formatted_string(_pg_user1->min, 7) + "' '" + to_formatted_string(_pg_user2->min, 7) + "'\n";

    if(_pg_user1->max != _pg_user2->max)
        _pg_report += _pg_prename + ":max"  + " '" + to_formatted_string(_pg_user1->max, 7) + "' '" + to_formatted_string(_pg_user2->max, 7) + "'\n";

    if(_pg_user1->kty83 != _pg_user2->kty83)
        _pg_report += _pg_prename + ":kty83"  + " '" + std::to_string(_pg_user1->kty83) + "' '" + std::to_string(_pg_user2->kty83) + "'\n";

    if(_pg_user1->setToDefault != _pg_user2->setToDefault)
        _pg_report += _pg_prename + ":setToDefault"  + " '" + std::to_string(_pg_user1->setToDefault) + "' '" + std::to_string(_pg_user2->setToDefault) + "'\n";

    if(_pg_user1->calibrate != _pg_user2->calibrate)
        _pg_report += _pg_prename + ":calibrate"  + " '" + std::to_string(_pg_user1->calibrate) + "' '" + std::to_string(_pg_user2->calibrate) + "'\n";

    if(_pg_user1->calibrateoffset != _pg_user2->calibrateoffset)
        _pg_report += _pg_prename + ":calibrateoffset"  + " '" + std::to_string(_pg_user1->calibrateoffset) + "' '" + std::to_string(_pg_user2->calibrateoffset) + "'\n";

    if(_pg_user1->calibrategain != _pg_user2->calibrategain)
        _pg_report += _pg_prename + ":calibrategain"  + " '" + std::to_string(_pg_user1->calibrategain) + "' '" + std::to_string(_pg_user2->calibrategain) + "'\n";

    if(_pg_user1->enableAutocorrect != _pg_user2->enableAutocorrect)
        _pg_report += _pg_prename + ":enableAutocorrect"  + " '" + std::to_string(_pg_user1->enableAutocorrect) + "' '" + std::to_string(_pg_user2->enableAutocorrect) + "'\n";

    if(_pg_user1->platinum1000rtd != _pg_user2->platinum1000rtd)
        _pg_report += _pg_prename + ":platinum1000rtd"  + " '" + std::to_string(_pg_user1->platinum1000rtd) + "' '" + std::to_string(_pg_user2->platinum1000rtd) + "'\n";

    if(_pg_user1->calibrationvalue != _pg_user2->calibrationvalue)
        _pg_report += _pg_prename + ":calibrationvalue"  + " '" + to_formatted_string(_pg_user1->calibrationvalue, 7) + "' '" + to_formatted_string(_pg_user2->calibrationvalue, 7) + "'\n";

    return _pg_report;

}// compareefiSensorConfiguration_t

/*!
 * Compare two ThrottleConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiThrottleConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiThrottleConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "ThrottleConfiguration";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiThrottleConfigurationPkt(_pg_pkt1, &_pg_struct1) || !decodeefiThrottleConfigurationPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiThrottleConfiguration_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiThrottleConfigurationPkt

/*!
 * Compare two efiThrottleConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiThrottleConfiguration_t(const std::string& _pg_prename, const efiThrottleConfiguration_t* _pg_user1, const efiThrottleConfiguration_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->closedPWMoutput != _pg_user2->closedPWMoutput)
        _pg_report += _pg_prename + ":closedPWMoutput"  + " '" + std::to_string(_pg_user1->closedPWMoutput) + "' '" + std::to_string(_pg_user2->closedPWMoutput) + "'\n";

    if(_pg_user1->openPWMoutput != _pg_user2->openPWMoutput)
        _pg_report += _pg_prename + ":openPWMoutput"  + " '" + std::to_string(_pg_user1->openPWMoutput) + "' '" + std::to_string(_pg_user2->openPWMoutput) + "'\n";

    if(_pg_user1->inputfilterlpf != _pg_user2->inputfilterlpf)
        _pg_report += _pg_prename + ":inputfilterlpf"  + " '" + to_formatted_string(_pg_user1->inputfilterlpf, 7) + "' '" + to_formatted_string(_pg_user2->inputfilterlpf, 7) + "'\n";

    if(_pg_user1->outputRateLimit != _pg_user2->outputRateLimit)
        _pg_report += _pg_prename + ":outputRateLimit"  + " '" + to_formatted_string(_pg_user1->outputRateLimit, 7) + "' '" + to_formatted_string(_pg_user2->outputRateLimit, 7) + "'\n";

    if(_pg_user1->enableAnalogCmd != _pg_user2->enableAnalogCmd)
        _pg_report += _pg_prename + ":enableAnalogCmd"  + " '" + std::to_string(_pg_user1->enableAnalogCmd) + "' '" + std::to_string(_pg_user2->enableAnalogCmd) + "'\n";

    if(_pg_user1->enablePWMCmd != _pg_user2->enablePWMCmd)
        _pg_report += _pg_prename + ":enablePWMCmd"  + " '" + std::to_string(_pg_user1->enablePWMCmd) + "' '" + std::to_string(_pg_user2->enablePWMCmd) + "'\n";

    if(_pg_user1->efiDrivesThrottle != _pg_user2->efiDrivesThrottle)
        _pg_report += _pg_prename + ":efiDrivesThrottle"  + " '" + std::to_string(_pg_user1->efiDrivesThrottle) + "' '" + std::to_string(_pg_user2->efiDrivesThrottle) + "'\n";

    if(_pg_user1->enableAnalogTPS != _pg_user2->enableAnalogTPS)
        _pg_report += _pg_prename + ":enableAnalogTPS"  + " '" + std::to_string(_pg_user1->enableAnalogTPS) + "' '" + std::to_string(_pg_user2->enableAnalogTPS) + "'\n";

    if(_pg_user1->enablePWMTPS != _pg_user2->enablePWMTPS)
        _pg_report += _pg_prename + ":enablePWMTPS"  + " '" + std::to_string(_pg_user1->enablePWMTPS) + "' '" + std::to_string(_pg_user2->enablePWMTPS) + "'\n";

    if(_pg_user1->_enableCECANServo != _pg_user2->_enableCECANServo)
        _pg_report += _pg_prename + ":_enableCECANServo"  + " '" + std::to_string(_pg_user1->_enableCECANServo) + "' '" + std::to_string(_pg_user2->_enableCECANServo) + "'\n";

    if(_pg_user1->enableCECANTPS != _pg_user2->enableCECANTPS)
        _pg_report += _pg_prename + ":enableCECANTPS"  + " '" + std::to_string(_pg_user1->enableCECANTPS) + "' '" + std::to_string(_pg_user2->enableCECANTPS) + "'\n";

    if(_pg_user1->enableMAPTPS != _pg_user2->enableMAPTPS)
        _pg_report += _pg_prename + ":enableMAPTPS"  + " '" + std::to_string(_pg_user1->enableMAPTPS) + "' '" + std::to_string(_pg_user2->enableMAPTPS) + "'\n";

    _pg_report += compareefiTable1D_t(_pg_prename + ":curve", &_pg_user1->curve, &_pg_user2->curve);

    if(_pg_user1->startThrottle != _pg_user2->startThrottle)
        _pg_report += _pg_prename + ":startThrottle"  + " '" + to_formatted_string(_pg_user1->startThrottle, 7) + "' '" + to_formatted_string(_pg_user2->startThrottle, 7) + "'\n";

    if(_pg_user1->cecanAddress != _pg_user2->cecanAddress)
        _pg_report += _pg_prename + ":cecanAddress"  + " '" + std::to_string(_pg_user1->cecanAddress) + "' '" + std::to_string(_pg_user2->cecanAddress) + "'\n";

    if(_pg_user1->tpsErrorThreshold != _pg_user2->tpsErrorThreshold)
        _pg_report += _pg_prename + ":tpsErrorThreshold"  + " '" + to_formatted_string(_pg_user1->tpsErrorThreshold, 7) + "' '" + to_formatted_string(_pg_user2->tpsErrorThreshold, 7) + "'\n";

    if(_pg_user1->maxStartThrottle != _pg_user2->maxStartThrottle)
        _pg_report += _pg_prename + ":maxStartThrottle"  + " '" + to_formatted_string(_pg_user1->maxStartThrottle, 7) + "' '" + to_formatted_string(_pg_user2->maxStartThrottle, 7) + "'\n";

    if(_pg_user1->closedPWMinput != _pg_user2->closedPWMinput)
        _pg_report += _pg_prename + ":closedPWMinput"  + " '" + std::to_string(_pg_user1->closedPWMinput) + "' '" + std::to_string(_pg_user2->closedPWMinput) + "'\n";

    if(_pg_user1->openPWMinput != _pg_user2->openPWMinput)
        _pg_report += _pg_prename + ":openPWMinput"  + " '" + std::to_string(_pg_user1->openPWMinput) + "' '" + std::to_string(_pg_user2->openPWMinput) + "'\n";

    if(_pg_user1->tpsFeedbackIntGain != _pg_user2->tpsFeedbackIntGain)
        _pg_report += _pg_prename + ":tpsFeedbackIntGain"  + " '" + to_formatted_string(_pg_user1->tpsFeedbackIntGain, 7) + "' '" + to_formatted_string(_pg_user2->tpsFeedbackIntGain, 7) + "'\n";

    return _pg_report;

}// compareefiThrottleConfiguration_t

/*!
 * Compare two CoolingConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiCoolingConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiCoolingConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "CoolingConfiguration";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiCoolingConfigurationPkt(_pg_pkt1, &_pg_struct1) || !decodeefiCoolingConfigurationPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiCoolingConfiguration_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiCoolingConfigurationPkt

/*!
 * Compare two efiCoolingConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiCoolingConfiguration_t(const std::string& _pg_prename, const efiCoolingConfiguration_t* _pg_user1, const efiCoolingConfiguration_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->chtTooCold != _pg_user2->chtTooCold)
        _pg_report += _pg_prename + ":chtTooCold"  + " '" + to_formatted_string(_pg_user1->chtTooCold, 7) + "' '" + to_formatted_string(_pg_user2->chtTooCold, 7) + "'\n";

    if(_pg_user1->chtTooHot != _pg_user2->chtTooHot)
        _pg_report += _pg_prename + ":chtTooHot"  + " '" + to_formatted_string(_pg_user1->chtTooHot, 7) + "' '" + to_formatted_string(_pg_user2->chtTooHot, 7) + "'\n";

    if(_pg_user1->chtDesired != _pg_user2->chtDesired)
        _pg_report += _pg_prename + ":chtDesired"  + " '" + to_formatted_string(_pg_user1->chtDesired, 7) + "' '" + to_formatted_string(_pg_user2->chtDesired, 7) + "'\n";

    if(_pg_user1->derTime != _pg_user2->derTime)
        _pg_report += _pg_prename + ":derTime"  + " '" + to_formatted_string(_pg_user1->derTime, 7) + "' '" + to_formatted_string(_pg_user2->derTime, 7) + "'\n";

    if(_pg_user1->trajGain != _pg_user2->trajGain)
        _pg_report += _pg_prename + ":trajGain"  + " '" + to_formatted_string(_pg_user1->trajGain, 7) + "' '" + to_formatted_string(_pg_user2->trajGain, 7) + "'\n";

    if(_pg_user1->forGain != _pg_user2->forGain)
        _pg_report += _pg_prename + ":forGain"  + " '" + to_formatted_string(_pg_user1->forGain, 7) + "' '" + to_formatted_string(_pg_user2->forGain, 7) + "'\n";

    if(_pg_user1->proGain != _pg_user2->proGain)
        _pg_report += _pg_prename + ":proGain"  + " '" + to_formatted_string(_pg_user1->proGain, 7) + "' '" + to_formatted_string(_pg_user2->proGain, 7) + "'\n";

    if(_pg_user1->intGain != _pg_user2->intGain)
        _pg_report += _pg_prename + ":intGain"  + " '" + to_formatted_string(_pg_user1->intGain, 7) + "' '" + to_formatted_string(_pg_user2->intGain, 7) + "'\n";

    if(_pg_user1->derGain != _pg_user2->derGain)
        _pg_report += _pg_prename + ":derGain"  + " '" + to_formatted_string(_pg_user1->derGain, 7) + "' '" + to_formatted_string(_pg_user2->derGain, 7) + "'\n";

    if(_pg_user1->enableSplitCooling != _pg_user2->enableSplitCooling)
        _pg_report += _pg_prename + ":enableSplitCooling"  + " '" + std::to_string(_pg_user1->enableSplitCooling) + "' '" + std::to_string(_pg_user2->enableSplitCooling) + "'\n";

    if(_pg_user1->closedPWM1 != _pg_user2->closedPWM1)
        _pg_report += _pg_prename + ":closedPWM1"  + " '" + std::to_string(_pg_user1->closedPWM1) + "' '" + std::to_string(_pg_user2->closedPWM1) + "'\n";

    if(_pg_user1->openPWM1 != _pg_user2->openPWM1)
        _pg_report += _pg_prename + ":openPWM1"  + " '" + std::to_string(_pg_user1->openPWM1) + "' '" + std::to_string(_pg_user2->openPWM1) + "'\n";

    if(_pg_user1->closedPWM2 != _pg_user2->closedPWM2)
        _pg_report += _pg_prename + ":closedPWM2"  + " '" + std::to_string(_pg_user1->closedPWM2) + "' '" + std::to_string(_pg_user2->closedPWM2) + "'\n";

    if(_pg_user1->openPWM2 != _pg_user2->openPWM2)
        _pg_report += _pg_prename + ":openPWM2"  + " '" + std::to_string(_pg_user1->openPWM2) + "' '" + std::to_string(_pg_user2->openPWM2) + "'\n";

    if(_pg_user1->cecanAddress1 != _pg_user2->cecanAddress1)
        _pg_report += _pg_prename + ":cecanAddress1"  + " '" + std::to_string(_pg_user1->cecanAddress1) + "' '" + std::to_string(_pg_user2->cecanAddress1) + "'\n";

    if(_pg_user1->cecanAddress2 != _pg_user2->cecanAddress2)
        _pg_report += _pg_prename + ":cecanAddress2"  + " '" + std::to_string(_pg_user1->cecanAddress2) + "' '" + std::to_string(_pg_user2->cecanAddress2) + "'\n";

    return _pg_report;

}// compareefiCoolingConfiguration_t

/*!
 * Compare two EngineConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiEngineConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiEngineConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "EngineConfiguration";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiEngineConfigurationPkt(_pg_pkt1, &_pg_struct1) || !decodeefiEngineConfigurationPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiEngineConfiguration_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiEngineConfigurationPkt

/*!
 * Compare two efiEngineConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiEngineConfiguration_t(const std::string& _pg_prename, const efiEngineConfiguration_t* _pg_user1, const efiEngineConfiguration_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->displacement != _pg_user2->displacement)
        _pg_report += _pg_prename + ":displacement"  + " '" + to_formatted_string(_pg_user1->displacement, 7) + "' '" + to_formatted_string(_pg_user2->displacement, 7) + "'\n";

    if(_pg_user1->ignoreInputEnable != _pg_user2->ignoreInputEnable)
        _pg_report += _pg_prename + ":ignoreInputEnable"  + " '" + std::to_string(_pg_user1->ignoreInputEnable) + "' '" + std::to_string(_pg_user2->ignoreInputEnable) + "'\n";

    if(_pg_user1->preventNormalRotation != _pg_user2->preventNormalRotation)
        _pg_report += _pg_prename + ":preventNormalRotation"  + " '" + std::to_string(_pg_user1->preventNormalRotation) + "' '" + std::to_string(_pg_user2->preventNormalRotation) + "'\n";

    if(_pg_user1->preventReverseRotation != _pg_user2->preventReverseRotation)
        _pg_report += _pg_prename + ":preventReverseRotation"  + " '" + std::to_string(_pg_user1->preventReverseRotation) + "' '" + std::to_string(_pg_user2->preventReverseRotation) + "'\n";

    if(_pg_user1->_enableCrank2 != _pg_user2->_enableCrank2)
        _pg_report += _pg_prename + ":_enableCrank2"  + " '" + std::to_string(_pg_user1->_enableCrank2) + "' '" + std::to_string(_pg_user2->_enableCrank2) + "'\n";

    if(_pg_user1->enableSpark3 != _pg_user2->enableSpark3)
        _pg_report += _pg_prename + ":enableSpark3"  + " '" + std::to_string(_pg_user1->enableSpark3) + "' '" + std::to_string(_pg_user2->enableSpark3) + "'\n";

    if(_pg_user1->ignActiveHigh != _pg_user2->ignActiveHigh)
        _pg_report += _pg_prename + ":ignActiveHigh"  + " '" + std::to_string(_pg_user1->ignActiveHigh) + "' '" + std::to_string(_pg_user2->ignActiveHigh) + "'\n";

    if(_pg_user1->api8 != _pg_user2->api8)
        _pg_report += _pg_prename + ":api8"  + " '" + std::to_string(_pg_user1->api8) + "' '" + std::to_string(_pg_user2->api8) + "'\n";

    if(_pg_user1->maxIgnDwellTime != _pg_user2->maxIgnDwellTime)
        _pg_report += _pg_prename + ":maxIgnDwellTime"  + " '" + std::to_string(_pg_user1->maxIgnDwellTime) + "' '" + std::to_string(_pg_user2->maxIgnDwellTime) + "'\n";

    if(_pg_user1->minIgnActiveTime != _pg_user2->minIgnActiveTime)
        _pg_report += _pg_prename + ":minIgnActiveTime"  + " '" + std::to_string(_pg_user1->minIgnActiveTime) + "' '" + std::to_string(_pg_user2->minIgnActiveTime) + "'\n";

    if(_pg_user1->hardRevLimit != _pg_user2->hardRevLimit)
        _pg_report += _pg_prename + ":hardRevLimit"  + " '" + to_formatted_string(_pg_user1->hardRevLimit, 7) + "' '" + to_formatted_string(_pg_user2->hardRevLimit, 7) + "'\n";

    if(_pg_user1->softRevLimit != _pg_user2->softRevLimit)
        _pg_report += _pg_prename + ":softRevLimit"  + " '" + to_formatted_string(_pg_user1->softRevLimit, 7) + "' '" + to_formatted_string(_pg_user2->softRevLimit, 7) + "'\n";

    if(_pg_user1->rpmfilterlpf != _pg_user2->rpmfilterlpf)
        _pg_report += _pg_prename + ":rpmfilterlpf"  + " '" + to_formatted_string(_pg_user1->rpmfilterlpf, 7) + "' '" + to_formatted_string(_pg_user2->rpmfilterlpf, 7) + "'\n";

    if(_pg_user1->mapErrorThreshold != _pg_user2->mapErrorThreshold)
        _pg_report += _pg_prename + ":mapErrorThreshold"  + " '" + to_formatted_string(_pg_user1->mapErrorThreshold, 7) + "' '" + to_formatted_string(_pg_user2->mapErrorThreshold, 7) + "'\n";

    _pg_report += compareefiCrankSense_t(_pg_prename + ":crankSense1", &_pg_user1->crankSense1, &_pg_user2->crankSense1);

    _pg_report += compareefiCrankSense_t(_pg_prename + ":crankSense2", &_pg_user1->crankSense2, &_pg_user2->crankSense2);

    if(_pg_user1->chtReference != _pg_user2->chtReference)
        _pg_report += _pg_prename + ":chtReference"  + " '" + to_formatted_string(_pg_user1->chtReference, 7) + "' '" + to_formatted_string(_pg_user2->chtReference, 7) + "'\n";

    return _pg_report;

}// compareefiEngineConfiguration_t

/*!
 * Compare two InjectorConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiInjectorConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiInjectorConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "InjectorConfiguration";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiInjectorConfigurationPkt(_pg_pkt1, &_pg_struct1) || !decodeefiInjectorConfigurationPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiInjectorConfiguration_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiInjectorConfigurationPkt

/*!
 * Compare two efiInjectorConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiInjectorConfiguration_t(const std::string& _pg_prename, const efiInjectorConfiguration_t* _pg_user1, const efiInjectorConfiguration_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->enableInjector2 != _pg_user2->enableInjector2)
        _pg_report += _pg_prename + ":enableInjector2"  + " '" + std::to_string(_pg_user1->enableInjector2) + "' '" + std::to_string(_pg_user2->enableInjector2) + "'\n";

    if(_pg_user1->enableInjectorIndependence != _pg_user2->enableInjectorIndependence)
        _pg_report += _pg_prename + ":enableInjectorIndependence"  + " '" + std::to_string(_pg_user1->enableInjectorIndependence) + "' '" + std::to_string(_pg_user2->enableInjectorIndependence) + "'\n";

    if(_pg_user1->spareTempIsCHT != _pg_user2->spareTempIsCHT)
        _pg_report += _pg_prename + ":spareTempIsCHT"  + " '" + std::to_string(_pg_user1->spareTempIsCHT) + "' '" + std::to_string(_pg_user2->spareTempIsCHT) + "'\n";

    if(_pg_user1->spareTempIsMAT != _pg_user2->spareTempIsMAT)
        _pg_report += _pg_prename + ":spareTempIsMAT"  + " '" + std::to_string(_pg_user1->spareTempIsMAT) + "' '" + std::to_string(_pg_user2->spareTempIsMAT) + "'\n";

    if(_pg_user1->enableInjector3 != _pg_user2->enableInjector3)
        _pg_report += _pg_prename + ":enableInjector3"  + " '" + std::to_string(_pg_user1->enableInjector3) + "' '" + std::to_string(_pg_user2->enableInjector3) + "'\n";

    if(_pg_user1->injectorsAreRedundant != _pg_user2->injectorsAreRedundant)
        _pg_report += _pg_prename + ":injectorsAreRedundant"  + " '" + std::to_string(_pg_user1->injectorsAreRedundant) + "' '" + std::to_string(_pg_user2->injectorsAreRedundant) + "'\n";

    if(_pg_user1->phaseEdge != _pg_user2->phaseEdge)
        _pg_report += _pg_prename + ":phaseEdge"  + " '" + std::to_string(_pg_user1->phaseEdge) + "' '" + std::to_string(_pg_user2->phaseEdge) + "'\n";

    if(_pg_user1->fuelVolumePercentPerMAT != _pg_user2->fuelVolumePercentPerMAT)
        _pg_report += _pg_prename + ":fuelVolumePercentPerMAT"  + " '" + to_formatted_string(_pg_user1->fuelVolumePercentPerMAT, 7) + "' '" + to_formatted_string(_pg_user2->fuelVolumePercentPerMAT, 7) + "'\n";

    if(_pg_user1->multiplier != _pg_user2->multiplier)
        _pg_report += _pg_prename + ":multiplier"  + " '" + to_formatted_string(_pg_user1->multiplier, 7) + "' '" + to_formatted_string(_pg_user2->multiplier, 7) + "'\n";

    if(_pg_user1->nominalFuelPressure != _pg_user2->nominalFuelPressure)
        _pg_report += _pg_prename + ":nominalFuelPressure"  + " '" + to_formatted_string(_pg_user1->nominalFuelPressure, 7) + "' '" + to_formatted_string(_pg_user2->nominalFuelPressure, 7) + "'\n";

    if(_pg_user1->nominalFlowrate1 != _pg_user2->nominalFlowrate1)
        _pg_report += _pg_prename + ":nominalFlowrate1"  + " '" + to_formatted_string(_pg_user1->nominalFlowrate1, 7) + "' '" + to_formatted_string(_pg_user2->nominalFlowrate1, 7) + "'\n";

    if(_pg_user1->nominalFlowrate2 != _pg_user2->nominalFlowrate2)
        _pg_report += _pg_prename + ":nominalFlowrate2"  + " '" + to_formatted_string(_pg_user1->nominalFlowrate2, 7) + "' '" + to_formatted_string(_pg_user2->nominalFlowrate2, 7) + "'\n";

    if(_pg_user1->minOpeningTime1 != _pg_user2->minOpeningTime1)
        _pg_report += _pg_prename + ":minOpeningTime1"  + " '" + std::to_string(_pg_user1->minOpeningTime1) + "' '" + std::to_string(_pg_user2->minOpeningTime1) + "'\n";

    if(_pg_user1->minOpeningTime2 != _pg_user2->minOpeningTime2)
        _pg_report += _pg_prename + ":minOpeningTime2"  + " '" + std::to_string(_pg_user1->minOpeningTime2) + "' '" + std::to_string(_pg_user2->minOpeningTime2) + "'\n";

    if(_pg_user1->fuelUsedCorrector != _pg_user2->fuelUsedCorrector)
        _pg_report += _pg_prename + ":fuelUsedCorrector"  + " '" + to_formatted_string(_pg_user1->fuelUsedCorrector, 7) + "' '" + to_formatted_string(_pg_user2->fuelUsedCorrector, 7) + "'\n";

    if(_pg_user1->nominalFlowrate3 != _pg_user2->nominalFlowrate3)
        _pg_report += _pg_prename + ":nominalFlowrate3"  + " '" + to_formatted_string(_pg_user1->nominalFlowrate3, 7) + "' '" + to_formatted_string(_pg_user2->nominalFlowrate3, 7) + "'\n";

    if(_pg_user1->minOpeningTime3 != _pg_user2->minOpeningTime3)
        _pg_report += _pg_prename + ":minOpeningTime3"  + " '" + std::to_string(_pg_user1->minOpeningTime3) + "' '" + std::to_string(_pg_user2->minOpeningTime3) + "'\n";

    if(_pg_user1->oilPrimingFreq != _pg_user2->oilPrimingFreq)
        _pg_report += _pg_prename + ":oilPrimingFreq"  + " '" + to_formatted_string(_pg_user1->oilPrimingFreq, 7) + "' '" + to_formatted_string(_pg_user2->oilPrimingFreq, 7) + "'\n";

    if(_pg_user1->spareTempIsOilT != _pg_user2->spareTempIsOilT)
        _pg_report += _pg_prename + ":spareTempIsOilT"  + " '" + std::to_string(_pg_user1->spareTempIsOilT) + "' '" + std::to_string(_pg_user2->spareTempIsOilT) + "'\n";

    if(_pg_user1->injector2IsOilInj != _pg_user2->injector2IsOilInj)
        _pg_report += _pg_prename + ":injector2IsOilInj"  + " '" + std::to_string(_pg_user1->injector2IsOilInj) + "' '" + std::to_string(_pg_user2->injector2IsOilInj) + "'\n";

    if(_pg_user1->injector3IsOilInj != _pg_user2->injector3IsOilInj)
        _pg_report += _pg_prename + ":injector3IsOilInj"  + " '" + std::to_string(_pg_user1->injector3IsOilInj) + "' '" + std::to_string(_pg_user2->injector3IsOilInj) + "'\n";

    if(_pg_user1->oilForStarting != _pg_user2->oilForStarting)
        _pg_report += _pg_prename + ":oilForStarting"  + " '" + to_formatted_string(_pg_user1->oilForStarting, 7) + "' '" + to_formatted_string(_pg_user2->oilForStarting, 7) + "'\n";

    if(_pg_user1->oilUsedCorrector != _pg_user2->oilUsedCorrector)
        _pg_report += _pg_prename + ":oilUsedCorrector"  + " '" + to_formatted_string(_pg_user1->oilUsedCorrector, 7) + "' '" + to_formatted_string(_pg_user2->oilUsedCorrector, 7) + "'\n";

    return _pg_report;

}// compareefiInjectorConfiguration_t

/*!
 * Compare two RPMController packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiRPMControllerPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiRPMController_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "RPMController";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiRPMControllerPkt(_pg_pkt1, &_pg_struct1) || !decodeefiRPMControllerPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiRPMController_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiRPMControllerPkt

/*!
 * Compare two efiRPMController_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiRPMController_t(const std::string& _pg_prename, const efiRPMController_t* _pg_user1, const efiRPMController_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->minRPM != _pg_user2->minRPM)
        _pg_report += _pg_prename + ":minRPM"  + " '" + to_formatted_string(_pg_user1->minRPM, 7) + "' '" + to_formatted_string(_pg_user2->minRPM, 7) + "'\n";

    if(_pg_user1->maxRPM != _pg_user2->maxRPM)
        _pg_report += _pg_prename + ":maxRPM"  + " '" + to_formatted_string(_pg_user1->maxRPM, 7) + "' '" + to_formatted_string(_pg_user2->maxRPM, 7) + "'\n";

    if(_pg_user1->enableRPMfromThrottleCmd != _pg_user2->enableRPMfromThrottleCmd)
        _pg_report += _pg_prename + ":enableRPMfromThrottleCmd"  + " '" + std::to_string(_pg_user1->enableRPMfromThrottleCmd) + "' '" + std::to_string(_pg_user2->enableRPMfromThrottleCmd) + "'\n";

    if(_pg_user1->enableLowRPMLimiter != _pg_user2->enableLowRPMLimiter)
        _pg_report += _pg_prename + ":enableLowRPMLimiter"  + " '" + std::to_string(_pg_user1->enableLowRPMLimiter) + "' '" + std::to_string(_pg_user2->enableLowRPMLimiter) + "'\n";

    if(_pg_user1->enableHighRPMLimiter != _pg_user2->enableHighRPMLimiter)
        _pg_report += _pg_prename + ":enableHighRPMLimiter"  + " '" + std::to_string(_pg_user1->enableHighRPMLimiter) + "' '" + std::to_string(_pg_user2->enableHighRPMLimiter) + "'\n";

    if(_pg_user1->updateRate != _pg_user2->updateRate)
        _pg_report += _pg_prename + ":updateRate"  + " '" + to_formatted_string(_pg_user1->updateRate, 7) + "' '" + to_formatted_string(_pg_user2->updateRate, 7) + "'\n";

    if(_pg_user1->throttleAtMinRPM != _pg_user2->throttleAtMinRPM)
        _pg_report += _pg_prename + ":throttleAtMinRPM"  + " '" + to_formatted_string(_pg_user1->throttleAtMinRPM, 7) + "' '" + to_formatted_string(_pg_user2->throttleAtMinRPM, 7) + "'\n";

    if(_pg_user1->rpmToThrottlePower != _pg_user2->rpmToThrottlePower)
        _pg_report += _pg_prename + ":rpmToThrottlePower"  + " '" + to_formatted_string(_pg_user1->rpmToThrottlePower, 7) + "' '" + to_formatted_string(_pg_user2->rpmToThrottlePower, 7) + "'\n";

    if(_pg_user1->rpmCmdfilterlpf != _pg_user2->rpmCmdfilterlpf)
        _pg_report += _pg_prename + ":rpmCmdfilterlpf"  + " '" + to_formatted_string(_pg_user1->rpmCmdfilterlpf, 7) + "' '" + to_formatted_string(_pg_user2->rpmCmdfilterlpf, 7) + "'\n";

    if(_pg_user1->maxRateCmd != _pg_user2->maxRateCmd)
        _pg_report += _pg_prename + ":maxRateCmd"  + " '" + to_formatted_string(_pg_user1->maxRateCmd, 7) + "' '" + to_formatted_string(_pg_user2->maxRateCmd, 7) + "'\n";

    if(_pg_user1->trajGain != _pg_user2->trajGain)
        _pg_report += _pg_prename + ":trajGain"  + " '" + to_formatted_string(_pg_user1->trajGain, 7) + "' '" + to_formatted_string(_pg_user2->trajGain, 7) + "'\n";

    if(_pg_user1->gainScaler != _pg_user2->gainScaler)
        _pg_report += _pg_prename + ":gainScaler"  + " '" + to_formatted_string(_pg_user1->gainScaler, 7) + "' '" + to_formatted_string(_pg_user2->gainScaler, 7) + "'\n";

    if(_pg_user1->forGain != _pg_user2->forGain)
        _pg_report += _pg_prename + ":forGain"  + " '" + to_formatted_string(_pg_user1->forGain, 7) + "' '" + to_formatted_string(_pg_user2->forGain, 7) + "'\n";

    if(_pg_user1->proGain != _pg_user2->proGain)
        _pg_report += _pg_prename + ":proGain"  + " '" + to_formatted_string(_pg_user1->proGain, 7) + "' '" + to_formatted_string(_pg_user2->proGain, 7) + "'\n";

    if(_pg_user1->intGain != _pg_user2->intGain)
        _pg_report += _pg_prename + ":intGain"  + " '" + to_formatted_string(_pg_user1->intGain, 7) + "' '" + to_formatted_string(_pg_user2->intGain, 7) + "'\n";

    if(_pg_user1->derGain != _pg_user2->derGain)
        _pg_report += _pg_prename + ":derGain"  + " '" + to_formatted_string(_pg_user1->derGain, 7) + "' '" + to_formatted_string(_pg_user2->derGain, 7) + "'\n";

    if(_pg_user1->derivativeTime != _pg_user2->derivativeTime)
        _pg_report += _pg_prename + ":derivativeTime"  + " '" + to_formatted_string(_pg_user1->derivativeTime, 7) + "' '" + to_formatted_string(_pg_user2->derivativeTime, 7) + "'\n";

    if(_pg_user1->outputfilterlpf != _pg_user2->outputfilterlpf)
        _pg_report += _pg_prename + ":outputfilterlpf"  + " '" + to_formatted_string(_pg_user1->outputfilterlpf, 7) + "' '" + to_formatted_string(_pg_user2->outputfilterlpf, 7) + "'\n";

    if(_pg_user1->outputsoftband != _pg_user2->outputsoftband)
        _pg_report += _pg_prename + ":outputsoftband"  + " '" + to_formatted_string(_pg_user1->outputsoftband, 7) + "' '" + to_formatted_string(_pg_user2->outputsoftband, 7) + "'\n";

    return _pg_report;

}// compareefiRPMController_t

/*!
 * Compare two efiMaintenanceItemConfig_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiMaintenanceItemConfig_t(const std::string& _pg_prename, const efiMaintenanceItemConfig_t* _pg_user1, const efiMaintenanceItemConfig_t* _pg_user2)
{
    std::string _pg_report;

    if(_pg_user1->trigger != _pg_user2->trigger)
        _pg_report += _pg_prename + ":trigger"  + " '" + std::to_string(_pg_user1->trigger) + "' '" + std::to_string(_pg_user2->trigger) + "'\n";

    if(_pg_user1->interval != _pg_user2->interval)
        _pg_report += _pg_prename + ":interval"  + " '" + std::to_string(_pg_user1->interval) + "' '" + std::to_string(_pg_user2->interval) + "'\n";

    if(std::string(_pg_user1->description).compare(_pg_user2->description) != 0)
        _pg_report += _pg_prename + ":description strings differ\n";

    return _pg_report;

}// compareefiMaintenanceItemConfig_t

/*!
 * Compare two MaintenanceConfiguration packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiMaintenanceConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiMaintenanceConfiguration_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "MaintenanceConfiguration";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiMaintenanceConfigurationPkt(_pg_pkt1, &_pg_struct1) || !decodeefiMaintenanceConfigurationPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiMaintenanceConfiguration_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiMaintenanceConfigurationPkt

/*!
 * Compare two efiMaintenanceConfiguration_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiMaintenanceConfiguration_t(const std::string& _pg_prename, const efiMaintenanceConfiguration_t* _pg_user1, const efiMaintenanceConfiguration_t* _pg_user2)
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    if(_pg_user1->numItems != _pg_user2->numItems)
        _pg_report += _pg_prename + ":numItems"  + " '" + std::to_string(_pg_user1->numItems) + "' '" + std::to_string(_pg_user2->numItems) + "'\n";

    if(_pg_user1->hotTimeGain != _pg_user2->hotTimeGain)
        _pg_report += _pg_prename + ":hotTimeGain"  + " '" + to_formatted_string(_pg_user1->hotTimeGain, 7) + "' '" + to_formatted_string(_pg_user2->hotTimeGain, 7) + "'\n";

    if(_pg_user1->highLoadThreshold != _pg_user2->highLoadThreshold)
        _pg_report += _pg_prename + ":highLoadThreshold"  + " '" + to_formatted_string(_pg_user1->highLoadThreshold, 7) + "' '" + to_formatted_string(_pg_user2->highLoadThreshold, 7) + "'\n";

    // List of maintenance item
    for(_pg_i = 0; _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_report += compareefiMaintenanceItemConfig_t(_pg_prename + ":MaintenanceItemConfig" + "[" + std::to_string(_pg_i) + "]", &_pg_user1->MaintenanceItemConfig[_pg_i], &_pg_user2->MaintenanceItemConfig[_pg_i]);

    return _pg_report;

}// compareefiMaintenanceConfiguration_t

/*!
 * Compare two Table2D_1x packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiTable2D_1xPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiTable2D_1x_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "Table2D_1x";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiTable2D_1xPkt(_pg_pkt1, &_pg_struct1) || !decodeefiTable2D_1xPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiTable2D_1x_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiTable2D_1xPkt

/*!
 * Compare two efiTable2D_1x_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiTable2D_1x_t(const std::string& _pg_prename, const efiTable2D_1x_t* _pg_user1, const efiTable2D_1x_t* _pg_user2)
{
    std::string _pg_report;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    if(_pg_user1->enabled != _pg_user2->enabled)
        _pg_report += _pg_prename + ":enabled"  + " '" + std::to_string(_pg_user1->enabled) + "' '" + std::to_string(_pg_user2->enabled) + "'\n";

    if(_pg_user1->loadfrommap != _pg_user2->loadfrommap)
        _pg_report += _pg_prename + ":loadfrommap"  + " '" + std::to_string(_pg_user1->loadfrommap) + "' '" + std::to_string(_pg_user2->loadfrommap) + "'\n";

    if(_pg_user1->index != _pg_user2->index)
        _pg_report += _pg_prename + ":index"  + " '" + std::to_string(_pg_user1->index) + "' '" + std::to_string(_pg_user2->index) + "'\n";

    if(_pg_user1->numrows != _pg_user2->numrows)
        _pg_report += _pg_prename + ":numrows"  + " '" + std::to_string(_pg_user1->numrows) + "' '" + std::to_string(_pg_user2->numrows) + "'\n";

    if(_pg_user1->numcols != _pg_user2->numcols)
        _pg_report += _pg_prename + ":numcols"  + " '" + std::to_string(_pg_user1->numcols) + "' '" + std::to_string(_pg_user2->numcols) + "'\n";

    if(_pg_user1->numrows == _pg_user2->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)_pg_user1->numrows); _pg_i++)
        {
            if(_pg_user1->rowindices[_pg_i] != _pg_user2->rowindices[_pg_i])
                _pg_report += _pg_prename + ":rowindices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(_pg_user1->rowindices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user2->rowindices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":rowindices array dimension differs, array not compared\n";

    if(_pg_user1->numcols == _pg_user2->numcols)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_COLS) && (_pg_i < (unsigned)_pg_user1->numcols); _pg_i++)
        {
            if(_pg_user1->colindices[_pg_i] != _pg_user2->colindices[_pg_i])
                _pg_report += _pg_prename + ":colindices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(_pg_user1->colindices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user2->colindices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":colindices array dimension differs, array not compared\n";

    if(_pg_user1->numrows == _pg_user2->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)_pg_user1->numrows); _pg_i++)
        {
            if(_pg_user1->numcols == _pg_user2->numcols)
            {
                for(_pg_j = 0; (_pg_j < EFI_TABLE_MAX_COLS) && (_pg_j < (unsigned)_pg_user1->numcols); _pg_j++)
                {
                    if(_pg_user1->data[_pg_i][_pg_j] != _pg_user2->data[_pg_i][_pg_j])
                        _pg_report += _pg_prename + ":data"  + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + to_formatted_string(_pg_user1->data[_pg_i][_pg_j], 7) + "' '" + to_formatted_string(_pg_user2->data[_pg_i][_pg_j], 7) + "'\n";
                }
            }
            else
                _pg_report += _pg_prename + ":data 2nd array dimension differs, array not compared\n";
        }
    }
    else
        _pg_report += _pg_prename + ":data array dimension differs, array not compared\n";

    if(_pg_user1->numrows == _pg_user2->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)_pg_user1->numrows); _pg_i++)
        {
            if(_pg_user1->numcols == _pg_user2->numcols)
            {
                for(_pg_j = 0; (_pg_j < EFI_TABLE_MAX_COLS) && (_pg_j < (unsigned)_pg_user1->numcols); _pg_j++)
                {
                    if(_pg_user1->meta[_pg_i][_pg_j] != _pg_user2->meta[_pg_i][_pg_j])
                        _pg_report += _pg_prename + ":meta"  + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + std::to_string(_pg_user1->meta[_pg_i][_pg_j]) + "' '" + std::to_string(_pg_user2->meta[_pg_i][_pg_j]) + "'\n";
                }
            }
            else
                _pg_report += _pg_prename + ":meta 2nd array dimension differs, array not compared\n";
        }
    }
    else
        _pg_report += _pg_prename + ":meta array dimension differs, array not compared\n";

    return _pg_report;

}// compareefiTable2D_1x_t

/*!
 * Compare two Table2D packets and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_pkt1 is the first data to compare
 * \param _pg_pkt2 is the second data to compare
 * \return a string describing any differences between pk1 and pkt2. The string will be empty if there are no differences
 */
std::string compareefiTable2DPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt1, const efiPacket_t* _pg_pkt2)
{
    std::string _pg_report;

    // Structures to decode into
    efiTable2D_t _pg_struct1, _pg_struct2;

    if(_pg_prename.empty())
        _pg_prename = "Table2D";

    // All zeroes before decoding
    memset(&_pg_struct1, 0, sizeof(_pg_struct1));
    memset(&_pg_struct2, 0, sizeof(_pg_struct2));

    // Decode each packet
    if(!decodeefiTable2DPkt(_pg_pkt1, &_pg_struct1) || !decodeefiTable2DPkt(_pg_pkt2, &_pg_struct2))
    {
        _pg_report = _pg_prename + " packets failed to decode\n";
        return _pg_report;
    }

    // Check packet sizes. Even if sizes are different the packets may contain the same result
    if(geteficommsPacketSize(_pg_pkt1) != geteficommsPacketSize(_pg_pkt2))
        _pg_report += _pg_prename + " packet sizes are different\n";

    _pg_report += compareefiTable2D_t(_pg_prename, &_pg_struct1, &_pg_struct2);

    return _pg_report;

}// compareefiTable2DPkt

/*!
 * Compare two efiTable2D_t and generate a report of any differences.
 * \param _pg_prename is prepended to the name of the data field in the comparison report
 * \param _pg_user1 is the first data to compare
 * \param _pg_user1 is the second data to compare
 * \return a string describing any differences between _pg_user1 and _pg_user2. The string will be empty if there are no differences
 */
std::string compareefiTable2D_t(const std::string& _pg_prename, const efiTable2D_t* _pg_user1, const efiTable2D_t* _pg_user2)
{
    std::string _pg_report;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    if(_pg_user1->enabled != _pg_user2->enabled)
        _pg_report += _pg_prename + ":enabled"  + " '" + std::to_string(_pg_user1->enabled) + "' '" + std::to_string(_pg_user2->enabled) + "'\n";

    if(_pg_user1->index != _pg_user2->index)
        _pg_report += _pg_prename + ":index"  + " '" + std::to_string(_pg_user1->index) + "' '" + std::to_string(_pg_user2->index) + "'\n";

    if(_pg_user1->addone != _pg_user2->addone)
        _pg_report += _pg_prename + ":addone"  + " '" + std::to_string(_pg_user1->addone) + "' '" + std::to_string(_pg_user2->addone) + "'\n";

    if(_pg_user1->rowindex != _pg_user2->rowindex)
        _pg_report += _pg_prename + ":rowindex"  + " '" + std::to_string(_pg_user1->rowindex) + "' '" + std::to_string(_pg_user2->rowindex) + "'\n";

    if(_pg_user1->colindex != _pg_user2->colindex)
        _pg_report += _pg_prename + ":colindex"  + " '" + std::to_string(_pg_user1->colindex) + "' '" + std::to_string(_pg_user2->colindex) + "'\n";

    if(_pg_user1->multiplierindex != _pg_user2->multiplierindex)
        _pg_report += _pg_prename + ":multiplierindex"  + " '" + std::to_string(_pg_user1->multiplierindex) + "' '" + std::to_string(_pg_user2->multiplierindex) + "'\n";

    if(_pg_user1->dividerindex != _pg_user2->dividerindex)
        _pg_report += _pg_prename + ":dividerindex"  + " '" + std::to_string(_pg_user1->dividerindex) + "' '" + std::to_string(_pg_user2->dividerindex) + "'\n";

    if(std::string(_pg_user1->description).compare(_pg_user2->description) != 0)
        _pg_report += _pg_prename + ":description strings differ\n";

    if(_pg_user1->numrows != _pg_user2->numrows)
        _pg_report += _pg_prename + ":numrows"  + " '" + std::to_string(_pg_user1->numrows) + "' '" + std::to_string(_pg_user2->numrows) + "'\n";

    if(_pg_user1->numcols != _pg_user2->numcols)
        _pg_report += _pg_prename + ":numcols"  + " '" + std::to_string(_pg_user1->numcols) + "' '" + std::to_string(_pg_user2->numcols) + "'\n";

    if(_pg_user1->numrows == _pg_user2->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)_pg_user1->numrows); _pg_i++)
        {
            if(_pg_user1->rowindices[_pg_i] != _pg_user2->rowindices[_pg_i])
                _pg_report += _pg_prename + ":rowindices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(_pg_user1->rowindices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user2->rowindices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":rowindices array dimension differs, array not compared\n";

    if(_pg_user1->numcols == _pg_user2->numcols)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_COLS) && (_pg_i < (unsigned)_pg_user1->numcols); _pg_i++)
        {
            if(_pg_user1->colindices[_pg_i] != _pg_user2->colindices[_pg_i])
                _pg_report += _pg_prename + ":colindices"  + "[" + std::to_string(_pg_i) + "]" + " '" + to_formatted_string(_pg_user1->colindices[_pg_i], 7) + "' '" + to_formatted_string(_pg_user2->colindices[_pg_i], 7) + "'\n";
        }
    }
    else
        _pg_report += _pg_prename + ":colindices array dimension differs, array not compared\n";

    if(_pg_user1->numrows == _pg_user2->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)_pg_user1->numrows); _pg_i++)
        {
            if(_pg_user1->numcols == _pg_user2->numcols)
            {
                for(_pg_j = 0; (_pg_j < EFI_TABLE_MAX_COLS) && (_pg_j < (unsigned)_pg_user1->numcols); _pg_j++)
                {
                    if(_pg_user1->data[_pg_i][_pg_j] != _pg_user2->data[_pg_i][_pg_j])
                        _pg_report += _pg_prename + ":data"  + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + to_formatted_string(_pg_user1->data[_pg_i][_pg_j], 7) + "' '" + to_formatted_string(_pg_user2->data[_pg_i][_pg_j], 7) + "'\n";
                }
            }
            else
                _pg_report += _pg_prename + ":data 2nd array dimension differs, array not compared\n";
        }
    }
    else
        _pg_report += _pg_prename + ":data array dimension differs, array not compared\n";

    if(_pg_user1->numrows == _pg_user2->numrows)
    {
        for(_pg_i = 0; (_pg_i < EFI_TABLE_MAX_ROWS) && (_pg_i < (unsigned)_pg_user1->numrows); _pg_i++)
        {
            if(_pg_user1->numcols == _pg_user2->numcols)
            {
                for(_pg_j = 0; (_pg_j < EFI_TABLE_MAX_COLS) && (_pg_j < (unsigned)_pg_user1->numcols); _pg_j++)
                {
                    if(_pg_user1->meta[_pg_i][_pg_j] != _pg_user2->meta[_pg_i][_pg_j])
                        _pg_report += _pg_prename + ":meta"  + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + std::to_string(_pg_user1->meta[_pg_i][_pg_j]) + "' '" + std::to_string(_pg_user2->meta[_pg_i][_pg_j]) + "'\n";
                }
            }
            else
                _pg_report += _pg_prename + ":meta 2nd array dimension differs, array not compared\n";
        }
    }
    else
        _pg_report += _pg_prename + ":meta array dimension differs, array not compared\n";

    return _pg_report;

}// compareefiTable2D_t

// end of eficompareutil.cpp
