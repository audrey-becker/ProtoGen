// efiprintutil.cpp was generated by ProtoGen version 3.1.d

#include "efiprintutil.hpp"
#include <sstream>
#include <iomanip>
#include <cstring>
#include "fieldencode.h"

//! Create a numeric string with a specific number of decimal places
static std::string to_formatted_string(double number, int precision);

/*!
 * Create a numeric string with a specific number of decimal places
 * \param number is the number to convert to string
 * \param precision is the number of decimal places to output
 * \return the number as a string
 */
std::string to_formatted_string(double number, int precision)
{
    // This function exists becuase of a bug in GCC which prevents this from working correctly:
    // string = (std::stringstream() << std::setprecision(7) << _pg_user1->indices[_pg_i]).str()

    std::stringstream stream;
    stream << std::setprecision(precision);
    stream << number;
    return stream.str();

}// to_formatted_string

//! Extract text that is identified by a key
static std::string extractText(const std::string& key, const std::string& source, int* fieldcount);

/*!
 * Extract text that is identified by a key
 * \param key is the key, the text to extract follows the key and is on the same line
 * \param source is the source information to find the key in
 * \param fieldcount is incremented whenever the key is found in the source
 * \return the extracted text, which may be empty
 */
std::string extractText(const std::string& key, const std::string& source, int* fieldcount)
{
    std::string text;

    std::string::size_type index = source.find(key);

    if(index < source.size())
    {
        // This is the location of the first character after the key
        std::string::size_type first = index + key.size();

        // The location of the next linefeed after the key
        std::string::size_type linefeed = source.find("\n", first);

        // This is how many characters until we get to the linefeed
        if((linefeed > first) && (linefeed < source.size()))
        {
            // This is the number of characters to remove
            std::string::size_type length = linefeed - first;

            // Increment our field count
            (*fieldcount)++;

            // Extract the text between the key and the linefeed
            text = source.substr(first, length);

            // Remove the first " '" from the string
            if((text.size() > 1) && (text.at(0) == ' ') && (text.at(1) == '\''))
                text.erase(0, 2);

            // Remove the last "'" from the string
            if((text.size() > 0) && (text.back() == '\''))
                text.erase(text.size()-1, 1);
        }
    }

    return text;

}// extractText

/*!
 * Generate a string that describes the contents of a efiDate_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiDate_t(const std::string& _pg_prename, const efiDate_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":day" + " '" + std::to_string(_pg_user->day) + "'\n";

    _pg_report += _pg_prename + ":month" + " '" + std::to_string(_pg_user->month) + "'\n";

    _pg_report += _pg_prename + ":year" + " '" + std::to_string(_pg_user->year) + "'\n";

    return _pg_report;

}// textPrintefiDate_t

/*!
 * Read the contents of a efiDate_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiDate_t(const std::string& _pg_prename, const std::string& _pg_source, efiDate_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":day", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->day = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":month", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->month = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":year", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->year = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// textReadefiDate_t

/*!
 * Generate a string that describes the contents of a efiDateTime_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiDateTime_t(const std::string& _pg_prename, const efiDateTime_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":jiffytime" + " '" + std::to_string(_pg_user->jiffytime) + "'\n";

    _pg_report += _pg_prename + ":day" + " '" + std::to_string(_pg_user->day) + "'\n";

    _pg_report += _pg_prename + ":month" + " '" + std::to_string(_pg_user->month) + "'\n";

    _pg_report += _pg_prename + ":year" + " '" + std::to_string(_pg_user->year) + "'\n";

    return _pg_report;

}// textPrintefiDateTime_t

/*!
 * Read the contents of a efiDateTime_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiDateTime_t(const std::string& _pg_prename, const std::string& _pg_source, efiDateTime_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":jiffytime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->jiffytime = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":day", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->day = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":month", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->month = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":year", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->year = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// textReadefiDateTime_t

/*!
 * Generate a string that describes the contents of a efiCrankSense_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiCrankSense_t(const std::string& _pg_prename, const efiCrankSense_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":enableWheel" + " '" + std::to_string(_pg_user->enableWheel) + "'\n";

    _pg_report += _pg_prename + ":activeHigh" + " '" + std::to_string(_pg_user->activeHigh) + "'\n";

    _pg_report += _pg_prename + ":disableSensor" + " '" + std::to_string(_pg_user->disableSensor) + "'\n";

    _pg_report += _pg_prename + ":preferThisSensor" + " '" + std::to_string(_pg_user->preferThisSensor) + "'\n";

    _pg_report += _pg_prename + ":senseDelay" + " '" + std::to_string(_pg_user->senseDelay) + "'\n";

    _pg_report += _pg_prename + ":normalOffset" + " '" +  to_formatted_string(_pg_user->normalOffset, 7) + "'\n";

    _pg_report += _pg_prename + ":reverseOffset" + " '" +  to_formatted_string(_pg_user->reverseOffset, 7) + "'\n";

    _pg_report += _pg_prename + ":totalCount" + " '" + std::to_string(_pg_user->totalCount) + "'\n";

    _pg_report += _pg_prename + ":bigGapCount" + " '" + std::to_string(_pg_user->bigGapCount) + "'\n";

    _pg_report += _pg_prename + ":smallGapCount" + " '" + std::to_string(_pg_user->smallGapCount) + "'\n";

    _pg_report += _pg_prename + ":normalIntraGapCount" + " '" + std::to_string(_pg_user->normalIntraGapCount) + "'\n";

    _pg_report += _pg_prename + ":reverseIntraGapCount" + " '" + std::to_string(_pg_user->reverseIntraGapCount) + "'\n";

    return _pg_report;

}// textPrintefiCrankSense_t

/*!
 * Read the contents of a efiCrankSense_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiCrankSense_t(const std::string& _pg_prename, const std::string& _pg_source, efiCrankSense_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":enableWheel", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableWheel = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":activeHigh", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->activeHigh = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":disableSensor", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->disableSensor = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":preferThisSensor", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->preferThisSensor = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":senseDelay", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->senseDelay = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":normalOffset", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->normalOffset = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":reverseOffset", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->reverseOffset = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":totalCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->totalCount = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":bigGapCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->bigGapCount = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":smallGapCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->smallGapCount = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":normalIntraGapCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->normalIntraGapCount = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":reverseIntraGapCount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->reverseIntraGapCount = (uint8_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// textReadefiCrankSense_t

/*!
 * Generate a string that describes the contents of a efiTable1D_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiTable1D_t(const std::string& _pg_prename, const efiTable1D_t* _pg_user)
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    _pg_report += _pg_prename + ":enabled" + " '" + std::to_string(_pg_user->enabled) + "'\n";

    _pg_report += _pg_prename + ":num" + " '" + std::to_string(_pg_user->num) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        _pg_report += _pg_prename + ":indices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(_pg_user->indices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        _pg_report += _pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(_pg_user->data[_pg_i], 7) + "'\n";

    return _pg_report;

}// textPrintefiTable1D_t

/*!
 * Read the contents of a efiTable1D_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiTable1D_t(const std::string& _pg_prename, const std::string& _pg_source, efiTable1D_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;

    _pg_text = extractText(_pg_prename + ":enabled", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enabled = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":num", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->num = (unsigned)(std::stoul(_pg_text));

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":indices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            _pg_user->indices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->num && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            _pg_user->data[_pg_i] = std::stof(_pg_text);
    }

    return _pg_fieldcount;

}// textReadefiTable1D_t

/*!
 * Generate a string that describes the contents of a EngineWear packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiEngineWearPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiEngineWear_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "EngineWear";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiEngineWearPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiEngineWear_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiEngineWearPkt

/*!
 * Generate a string that describes the contents of a efiEngineWear_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiEngineWear_t(const std::string& _pg_prename, const efiEngineWear_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":hobbs" + " '" + std::to_string(_pg_user->hobbs) + "'\n";

    _pg_report += _pg_prename + ":revcount" + " '" + std::to_string(_pg_user->revcount) + "'\n";

    _pg_report += _pg_prename + ":hotTime" + " '" + std::to_string(_pg_user->hotTime) + "'\n";

    _pg_report += _pg_prename + ":highLoadTime" + " '" + std::to_string(_pg_user->highLoadTime) + "'\n";

    _pg_report += _pg_prename + ":peakCHT" + " '" +  to_formatted_string(_pg_user->peakCHT, 7) + "'\n";

    _pg_report += _pg_prename + ":numStarts" + " '" + std::to_string(_pg_user->numStarts) + "'\n";

    return _pg_report;

}// textPrintefiEngineWear_t

/*!
 * Read the contents of a efiEngineWear_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiEngineWear_t(const std::string& _pg_prename, const std::string& _pg_source, efiEngineWear_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":hobbs", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->hobbs = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":revcount", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->revcount = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":hotTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->hotTime = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":highLoadTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->highLoadTime = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":peakCHT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->peakCHT = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":numStarts", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->numStarts = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// textReadefiEngineWear_t

/*!
 * Generate a string that describes the contents of a efiMaintenanceItemStatus_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiMaintenanceItemStatus_t(const std::string& _pg_prename, const efiMaintenanceItemStatus_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":triggered" + " '" + std::to_string(_pg_user->triggered) + "'\n";

    _pg_report += _pg_prename + ":index" + " '" + std::to_string(_pg_user->index) + "'\n";

    _pg_report += textPrintefiDateTime_t(_pg_prename + ":servicetime", &_pg_user->servicetime);

    _pg_report += _pg_prename + ":lastdone" + " '" + std::to_string(_pg_user->lastdone) + "'\n";

    _pg_report += _pg_prename + ":name '" + std::string(_pg_user->name) + "'\n";

    return _pg_report;

}// textPrintefiMaintenanceItemStatus_t

/*!
 * Read the contents of a efiMaintenanceItemStatus_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiMaintenanceItemStatus_t(const std::string& _pg_prename, const std::string& _pg_source, efiMaintenanceItemStatus_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":triggered", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->triggered = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":index", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->index = (uint8_t)(std::stoul(_pg_text));

    _pg_fieldcount += textReadefiDateTime_t(_pg_prename + ":servicetime", _pg_source, &_pg_user->servicetime);

    _pg_text = extractText(_pg_prename + ":lastdone", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->lastdone = (uint32_t)(std::stoul(_pg_text));

    pgstrncpy(_pg_user->name, extractText(_pg_prename + ":name", _pg_source, &_pg_fieldcount).c_str(), maxNameCharacters);

    return _pg_fieldcount;

}// textReadefiMaintenanceItemStatus_t

/*!
 * Generate a string that describes the contents of a MaintenanceStatus packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiMaintenanceStatusPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiMaintenanceStatus_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "MaintenanceStatus";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiMaintenanceStatusPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiMaintenanceStatus_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiMaintenanceStatusPkt

/*!
 * Generate a string that describes the contents of a efiMaintenanceStatus_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiMaintenanceStatus_t(const std::string& _pg_prename, const efiMaintenanceStatus_t* _pg_user)
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    _pg_report += _pg_prename + ":domaintenance" + " '" + std::to_string(_pg_user->domaintenance) + "'\n";

    _pg_report += _pg_prename + ":setEngineSerial" + " '" + std::to_string(_pg_user->setEngineSerial) + "'\n";

    _pg_report += _pg_prename + ":numItems" + " '" + std::to_string(_pg_user->numItems) + "'\n";

    _pg_report += _pg_prename + ":engineSerial" + " '" + std::to_string(_pg_user->engineSerial) + "'\n";

    // List of maintenance item status
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_report += textPrintefiMaintenanceItemStatus_t(_pg_prename + ":MaintenanceItemStatus" + "[" + std::to_string(_pg_i) + "]", &_pg_user->MaintenanceItemStatus[_pg_i]);

    return _pg_report;

}// textPrintefiMaintenanceStatus_t

/*!
 * Read the contents of a efiMaintenanceStatus_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiMaintenanceStatus_t(const std::string& _pg_prename, const std::string& _pg_source, efiMaintenanceStatus_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;

    _pg_text = extractText(_pg_prename + ":domaintenance", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->domaintenance = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":setEngineSerial", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->setEngineSerial = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":numItems", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->numItems = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":engineSerial", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->engineSerial = (uint32_t)(std::stoul(_pg_text));

    // List of maintenance item status
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_fieldcount += textReadefiMaintenanceItemStatus_t(_pg_prename + ":MaintenanceItemStatus" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_user->MaintenanceItemStatus[_pg_i]);

    return _pg_fieldcount;

}// textReadefiMaintenanceStatus_t

/*!
 * Generate a string that describes the contents of a LogEntry packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiLogEntryPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiLogEntry_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "LogEntry";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiLogEntryPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiLogEntry_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiLogEntryPkt

/*!
 * Generate a string that describes the contents of a efiLogEntry_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiLogEntry_t(const std::string& _pg_prename, const efiLogEntry_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":cmd" + " '" + std::to_string(_pg_user->cmd) + "'\n";

    _pg_report += _pg_prename + ":index" + " '" + std::to_string(_pg_user->index) + "'\n";

    _pg_report += textPrintefiDateTime_t(_pg_prename + ":time", &_pg_user->time);

    _pg_report += _pg_prename + ":name '" + std::string(_pg_user->name) + "'\n";

    _pg_report += _pg_prename + ":description '" + std::string(_pg_user->description) + "'\n";

    return _pg_report;

}// textPrintefiLogEntry_t

/*!
 * Read the contents of a efiLogEntry_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiLogEntry_t(const std::string& _pg_prename, const std::string& _pg_source, efiLogEntry_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":cmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->cmd = (LogEntryCommands)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":index", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->index = (uint16_t)(std::stoul(_pg_text));

    _pg_fieldcount += textReadefiDateTime_t(_pg_prename + ":time", _pg_source, &_pg_user->time);

    pgstrncpy(_pg_user->name, extractText(_pg_prename + ":name", _pg_source, &_pg_fieldcount).c_str(), maxNameCharacters);

    pgstrncpy(_pg_user->description, extractText(_pg_prename + ":description", _pg_source, &_pg_fieldcount).c_str(), EFI_PACKET_SIZE - maxNameCharacters - 7);

    return _pg_fieldcount;

}// textReadefiLogEntry_t

/*!
 * Generate a string that describes the contents of a File packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiFilePkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiFile_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "File";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiFilePkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiFile_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiFilePkt

/*!
 * Generate a string that describes the contents of a efiFile_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiFile_t(const std::string& _pg_prename, const efiFile_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += textPrintefiDate_t(_pg_prename + ":date", &_pg_user->date);

    _pg_report += _pg_prename + ":filename '" + std::string(_pg_user->filename) + "'\n";

    return _pg_report;

}// textPrintefiFile_t

/*!
 * Read the contents of a efiFile_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiFile_t(const std::string& _pg_prename, const std::string& _pg_source, efiFile_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_fieldcount += textReadefiDate_t(_pg_prename + ":date", _pg_source, &_pg_user->date);

    pgstrncpy(_pg_user->filename, extractText(_pg_prename + ":filename", _pg_source, &_pg_fieldcount).c_str(), 128);

    return _pg_fieldcount;

}// textReadefiFile_t

/*!
 * Generate a string that describes the contents of a Comment packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiCommentPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiComment_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "Comment";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiCommentPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiComment_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiCommentPkt

/*!
 * Generate a string that describes the contents of a efiComment_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiComment_t(const std::string& _pg_prename, const efiComment_t* _pg_user)
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        _pg_report += _pg_prename + ":userdata" + "[" + std::to_string(_pg_i) + "]" + " '" + std::to_string(_pg_user->userdata[_pg_i]) + "'\n";

    _pg_report += _pg_prename + ":comment '" + std::string(_pg_user->comment) + "'\n";

    return _pg_report;

}// textPrintefiComment_t

/*!
 * Read the contents of a efiComment_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiComment_t(const std::string& _pg_prename, const std::string& _pg_source, efiComment_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;

    for(_pg_i = 0; _pg_i < 8; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":userdata" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            _pg_user->userdata[_pg_i] = (uint8_t)(std::stoul(_pg_text));
    }

    pgstrncpy(_pg_user->comment, extractText(_pg_prename + ":comment", _pg_source, &_pg_fieldcount).c_str(), 512);

    return _pg_fieldcount;

}// textReadefiComment_t

/*!
 * Generate a string that describes the contents of a LockControl packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiLockControlPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiLockControl_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "LockControl";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiLockControlPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiLockControl_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiLockControlPkt

/*!
 * Generate a string that describes the contents of a efiLockControl_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiLockControl_t(const std::string& _pg_prename, const efiLockControl_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":tablesProtection" + " '" + std::to_string(_pg_user->tablesProtection) + "'\n";

    _pg_report += _pg_prename + ":governorProtection" + " '" + std::to_string(_pg_user->governorProtection) + "'\n";

    _pg_report += _pg_prename + ":throttleProtection" + " '" + std::to_string(_pg_user->throttleProtection) + "'\n";

    _pg_report += _pg_prename + ":engineProtection" + " '" + std::to_string(_pg_user->engineProtection) + "'\n";

    _pg_report += _pg_prename + ":injectorProtection" + " '" + std::to_string(_pg_user->injectorProtection) + "'\n";

    _pg_report += _pg_prename + ":pumpProtection" + " '" + std::to_string(_pg_user->pumpProtection) + "'\n";

    _pg_report += _pg_prename + ":sensorsProtection" + " '" + std::to_string(_pg_user->sensorsProtection) + "'\n";

    _pg_report += _pg_prename + ":commsProtection" + " '" + std::to_string(_pg_user->commsProtection) + "'\n";

    _pg_report += _pg_prename + ":maintenanceProtection" + " '" + std::to_string(_pg_user->maintenanceProtection) + "'\n";

    _pg_report += _pg_prename + ":coolingProtection" + " '" + std::to_string(_pg_user->coolingProtection) + "'\n";

    _pg_report += _pg_prename + ":password '" + std::string(_pg_user->password) + "'\n";

    return _pg_report;

}// textPrintefiLockControl_t

/*!
 * Read the contents of a efiLockControl_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiLockControl_t(const std::string& _pg_prename, const std::string& _pg_source, efiLockControl_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":tablesProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->tablesProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":governorProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->governorProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":throttleProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->throttleProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":engineProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->engineProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":injectorProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->injectorProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":pumpProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->pumpProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":sensorsProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->sensorsProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":commsProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->commsProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":maintenanceProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->maintenanceProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":coolingProtection", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->coolingProtection = (efiprotectionlevels)(std::stoul(_pg_text));

    pgstrncpy(_pg_user->password, extractText(_pg_prename + ":password", _pg_source, &_pg_fieldcount).c_str(), 32);

    return _pg_fieldcount;

}// textReadefiLockControl_t

/*!
 * Generate a string that describes the contents of a ConfigHash packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiConfigHashPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiConfigHash_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "ConfigHash";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiConfigHashPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiConfigHash_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiConfigHashPkt

/*!
 * Generate a string that describes the contents of a efiConfigHash_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiConfigHash_t(const std::string& _pg_prename, const efiConfigHash_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":storedParameterHash" + " '" + std::to_string(_pg_user->storedParameterHash) + "'\n";

    _pg_report += _pg_prename + ":actualParameterHash" + " '" + std::to_string(_pg_user->actualParameterHash) + "'\n";

    return _pg_report;

}// textPrintefiConfigHash_t

/*!
 * Read the contents of a efiConfigHash_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiConfigHash_t(const std::string& _pg_prename, const std::string& _pg_source, efiConfigHash_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":storedParameterHash", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->storedParameterHash = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":actualParameterHash", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->actualParameterHash = (uint32_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// textReadefiConfigHash_t

/*!
 * Generate a string that describes the contents of a PumpConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiPumpConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiPumpConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "PumpConfiguration";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiPumpConfigurationPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiPumpConfiguration_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiPumpConfigurationPkt

/*!
 * Generate a string that describes the contents of a efiPumpConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiPumpConfiguration_t(const std::string& _pg_prename, const efiPumpConfiguration_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":fuelPressureCmd" + " '" +  to_formatted_string(_pg_user->fuelPressureCmd, 7) + "'\n";

    _pg_report += _pg_prename + ":fuelPressureErrorThreshold" + " '" +  to_formatted_string(_pg_user->fuelPressureErrorThreshold, 7) + "'\n";

    _pg_report += _pg_prename + ":minDutyCycle" + " '" +  to_formatted_string(_pg_user->minDutyCycle, 7) + "'\n";

    _pg_report += _pg_prename + ":maxDutyCycle" + " '" +  to_formatted_string(_pg_user->maxDutyCycle, 7) + "'\n";

    _pg_report += _pg_prename + ":fuelPressureBangBangThreshold" + " '" +  to_formatted_string(_pg_user->fuelPressureBangBangThreshold, 7) + "'\n";

    _pg_report += _pg_prename + ":proGain" + " '" +  to_formatted_string(_pg_user->proGain, 7) + "'\n";

    _pg_report += _pg_prename + ":intGain" + " '" +  to_formatted_string(_pg_user->intGain, 7) + "'\n";

    _pg_report += _pg_prename + ":forGain" + " '" +  to_formatted_string(_pg_user->forGain, 7) + "'\n";

    _pg_report += _pg_prename + ":rpmEnablesPump" + " '" + std::to_string(_pg_user->rpmEnablesPump) + "'\n";

    _pg_report += _pg_prename + ":primeTime" + " '" + std::to_string(_pg_user->primeTime) + "'\n";

    _pg_report += _pg_prename + ":maxIfFailure" + " '" + std::to_string(_pg_user->maxIfFailure) + "'\n";

    _pg_report += _pg_prename + ":positiveRateLimit" + " '" +  to_formatted_string(_pg_user->positiveRateLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":negativeRateLimit" + " '" +  to_formatted_string(_pg_user->negativeRateLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":_outputRateLimit" + " '" +  to_formatted_string(_pg_user->_outputRateLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":pwmPeriod" + " '" + std::to_string(_pg_user->pwmPeriod) + "'\n";

    return _pg_report;

}// textPrintefiPumpConfiguration_t

/*!
 * Read the contents of a efiPumpConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiPumpConfiguration_t(const std::string& _pg_prename, const std::string& _pg_source, efiPumpConfiguration_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":fuelPressureCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->fuelPressureCmd = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":fuelPressureErrorThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->fuelPressureErrorThreshold = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":minDutyCycle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->minDutyCycle = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":maxDutyCycle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->maxDutyCycle = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":fuelPressureBangBangThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->fuelPressureBangBangThreshold = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":proGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->proGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":intGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->intGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":forGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->forGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":rpmEnablesPump", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->rpmEnablesPump = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":primeTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->primeTime = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":maxIfFailure", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->maxIfFailure = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":positiveRateLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->positiveRateLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":negativeRateLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->negativeRateLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":_outputRateLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->_outputRateLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":pwmPeriod", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->pwmPeriod = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// textReadefiPumpConfiguration_t

/*!
 * Generate a string that describes the contents of a efiCANconfig_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiCANconfig_t(const std::string& _pg_prename, const efiCANconfig_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":baud" + " '" + std::to_string(_pg_user->baud) + "'\n";

    _pg_report += _pg_prename + ":typeShift" + " '" + std::to_string(_pg_user->typeShift) + "'\n";

    _pg_report += _pg_prename + ":longid" + " '" + std::to_string(_pg_user->longid) + "'\n";

    _pg_report += _pg_prename + ":disableNativeInput" + " '" + std::to_string(_pg_user->disableNativeInput) + "'\n";

    _pg_report += _pg_prename + ":inputBaseId" + " '" + std::to_string(_pg_user->inputBaseId) + "'\n";

    _pg_report += _pg_prename + ":disableNativeOutput" + " '" + std::to_string(_pg_user->disableNativeOutput) + "'\n";

    _pg_report += _pg_prename + ":outputBaseId" + " '" + std::to_string(_pg_user->outputBaseId) + "'\n";

    _pg_report += _pg_prename + ":disableNativeBroadcast" + " '" + std::to_string(_pg_user->disableNativeBroadcast) + "'\n";

    _pg_report += _pg_prename + ":broadcastBaseId" + " '" + std::to_string(_pg_user->broadcastBaseId) + "'\n";

    _pg_report += _pg_prename + ":forcePacketOverCAN" + " '" + std::to_string(_pg_user->forcePacketOverCAN) + "'\n";

    _pg_report += _pg_prename + ":cmdAndTmOnly" + " '" + std::to_string(_pg_user->cmdAndTmOnly) + "'\n";

    _pg_report += _pg_prename + ":enableGCU" + " '" + std::to_string(_pg_user->enableGCU) + "'\n";

    _pg_report += _pg_prename + ":enablePE3ECU" + " '" + std::to_string(_pg_user->enablePE3ECU) + "'\n";

    _pg_report += _pg_prename + ":enableCurrawongECU" + " '" + std::to_string(_pg_user->enableCurrawongECU) + "'\n";

    _pg_report += _pg_prename + ":enablePiccoloECU" + " '" + std::to_string(_pg_user->enablePiccoloECU) + "'\n";

    _pg_report += _pg_prename + ":alternativeProtocolAddress" + " '" + std::to_string(_pg_user->alternativeProtocolAddress) + "'\n";

    return _pg_report;

}// textPrintefiCANconfig_t

/*!
 * Read the contents of a efiCANconfig_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiCANconfig_t(const std::string& _pg_prename, const std::string& _pg_source, efiCANconfig_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":baud", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->baud = (CANBaudEnums)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":typeShift", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->typeShift = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":longid", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->longid = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":disableNativeInput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->disableNativeInput = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":inputBaseId", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->inputBaseId = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":disableNativeOutput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->disableNativeOutput = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":outputBaseId", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->outputBaseId = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":disableNativeBroadcast", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->disableNativeBroadcast = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":broadcastBaseId", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->broadcastBaseId = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":forcePacketOverCAN", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->forcePacketOverCAN = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":cmdAndTmOnly", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->cmdAndTmOnly = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableGCU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableGCU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enablePE3ECU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enablePE3ECU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableCurrawongECU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableCurrawongECU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enablePiccoloECU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enablePiccoloECU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":alternativeProtocolAddress", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->alternativeProtocolAddress = (uint16_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// textReadefiCANconfig_t

/*!
 * Generate a string that describes the contents of a CommConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiCommConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiCommConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "CommConfiguration";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiCommConfigurationPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiCommConfiguration_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiCommConfigurationPkt

/*!
 * Generate a string that describes the contents of a efiCommConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiCommConfiguration_t(const std::string& _pg_prename, const efiCommConfiguration_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":disableSDRecording" + " '" + std::to_string(_pg_user->disableSDRecording) + "'\n";

    _pg_report += _pg_prename + ":fastTelemetrySDRate" + " '" + std::to_string(_pg_user->fastTelemetrySDRate) + "'\n";

    _pg_report += _pg_prename + ":fastTelemetryRate" + " '" + std::to_string(_pg_user->fastTelemetryRate) + "'\n";

    _pg_report += _pg_prename + ":recordSDAlways" + " '" + std::to_string(_pg_user->recordSDAlways) + "'\n";

    _pg_report += _pg_prename + ":slowTelemetrySDRate" + " '" + std::to_string(_pg_user->slowTelemetrySDRate) + "'\n";

    _pg_report += _pg_prename + ":slowTelemetryRate" + " '" + std::to_string(_pg_user->slowTelemetryRate) + "'\n";

    _pg_report += _pg_prename + ":useSummaryPackets" + " '" + std::to_string(_pg_user->useSummaryPackets) + "'\n";

    _pg_report += _pg_prename + ":setToDefault" + " '" + std::to_string(_pg_user->setToDefault) + "'\n";

    _pg_report += _pg_prename + ":enableCurrawongECU" + " '" + std::to_string(_pg_user->enableCurrawongECU) + "'\n";

    _pg_report += _pg_prename + ":uartBaud" + " '" + std::to_string(_pg_user->uartBaud) + "'\n";

    // Configuration data for CAN communciations
    _pg_report += textPrintefiCANconfig_t(_pg_prename + ":CANconfig", &_pg_user->CANconfig);

    return _pg_report;

}// textPrintefiCommConfiguration_t

/*!
 * Read the contents of a efiCommConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiCommConfiguration_t(const std::string& _pg_prename, const std::string& _pg_source, efiCommConfiguration_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":disableSDRecording", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->disableSDRecording = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":fastTelemetrySDRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->fastTelemetrySDRate = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":fastTelemetryRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->fastTelemetryRate = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":recordSDAlways", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->recordSDAlways = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":slowTelemetrySDRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->slowTelemetrySDRate = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":slowTelemetryRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->slowTelemetryRate = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":useSummaryPackets", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->useSummaryPackets = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":setToDefault", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->setToDefault = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableCurrawongECU", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableCurrawongECU = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":uartBaud", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->uartBaud = (uint32_t)(std::stoul(_pg_text));

    // Configuration data for CAN communciations
    _pg_fieldcount += textReadefiCANconfig_t(_pg_prename + ":CANconfig", _pg_source, &_pg_user->CANconfig);

    return _pg_fieldcount;

}// textReadefiCommConfiguration_t

/*!
 * Generate a string that describes the contents of a SensorConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiSensorConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiSensorConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "SensorConfiguration";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiSensorConfigurationPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiSensorConfiguration_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiSensorConfigurationPkt

/*!
 * Generate a string that describes the contents of a efiSensorConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiSensorConfiguration_t(const std::string& _pg_prename, const efiSensorConfiguration_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":enabled" + " '" + std::to_string(_pg_user->enabled) + "'\n";

    _pg_report += _pg_prename + ":kty84" + " '" + std::to_string(_pg_user->kty84) + "'\n";

    _pg_report += _pg_prename + ":sealedGauge" + " '" + std::to_string(_pg_user->sealedGauge) + "'\n";

    _pg_report += _pg_prename + ":sensor" + " '" + std::to_string(_pg_user->sensor) + "'\n";

    _pg_report += _pg_prename + ":filterlpf" + " '" +  to_formatted_string(_pg_user->filterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":offset" + " '" +  to_formatted_string(_pg_user->offset, 7) + "'\n";

    _pg_report += _pg_prename + ":gain" + " '" +  to_formatted_string(_pg_user->gain, 7) + "'\n";

    _pg_report += _pg_prename + ":failedvalue" + " '" +  to_formatted_string(_pg_user->failedvalue, 7) + "'\n";

    _pg_report += _pg_prename + ":min" + " '" +  to_formatted_string(_pg_user->min, 7) + "'\n";

    _pg_report += _pg_prename + ":max" + " '" +  to_formatted_string(_pg_user->max, 7) + "'\n";

    _pg_report += _pg_prename + ":kty83" + " '" + std::to_string(_pg_user->kty83) + "'\n";

    _pg_report += _pg_prename + ":setToDefault" + " '" + std::to_string(_pg_user->setToDefault) + "'\n";

    _pg_report += _pg_prename + ":calibrate" + " '" + std::to_string(_pg_user->calibrate) + "'\n";

    _pg_report += _pg_prename + ":calibrateoffset" + " '" + std::to_string(_pg_user->calibrateoffset) + "'\n";

    _pg_report += _pg_prename + ":calibrategain" + " '" + std::to_string(_pg_user->calibrategain) + "'\n";

    _pg_report += _pg_prename + ":enableAutocorrect" + " '" + std::to_string(_pg_user->enableAutocorrect) + "'\n";

    _pg_report += _pg_prename + ":platinum1000rtd" + " '" + std::to_string(_pg_user->platinum1000rtd) + "'\n";

    _pg_report += _pg_prename + ":calibrationvalue" + " '" +  to_formatted_string(_pg_user->calibrationvalue, 7) + "'\n";

    return _pg_report;

}// textPrintefiSensorConfiguration_t

/*!
 * Read the contents of a efiSensorConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiSensorConfiguration_t(const std::string& _pg_prename, const std::string& _pg_source, efiSensorConfiguration_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":enabled", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enabled = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":kty84", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->kty84 = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":sealedGauge", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->sealedGauge = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":sensor", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->sensor = (efiSensorEnum)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":filterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->filterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":offset", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->offset = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":gain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->gain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":failedvalue", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->failedvalue = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":min", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->min = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":max", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->max = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":kty83", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->kty83 = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":setToDefault", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->setToDefault = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":calibrate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->calibrate = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":calibrateoffset", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->calibrateoffset = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":calibrategain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->calibrategain = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableAutocorrect", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableAutocorrect = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":platinum1000rtd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->platinum1000rtd = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":calibrationvalue", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->calibrationvalue = std::stof(_pg_text);

    return _pg_fieldcount;

}// textReadefiSensorConfiguration_t

/*!
 * Generate a string that describes the contents of a ThrottleConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiThrottleConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiThrottleConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "ThrottleConfiguration";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiThrottleConfigurationPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiThrottleConfiguration_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiThrottleConfigurationPkt

/*!
 * Generate a string that describes the contents of a efiThrottleConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiThrottleConfiguration_t(const std::string& _pg_prename, const efiThrottleConfiguration_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":closedPWMoutput" + " '" + std::to_string(_pg_user->closedPWMoutput) + "'\n";

    _pg_report += _pg_prename + ":openPWMoutput" + " '" + std::to_string(_pg_user->openPWMoutput) + "'\n";

    _pg_report += _pg_prename + ":inputfilterlpf" + " '" +  to_formatted_string(_pg_user->inputfilterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":outputRateLimit" + " '" +  to_formatted_string(_pg_user->outputRateLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":enableAnalogCmd" + " '" + std::to_string(_pg_user->enableAnalogCmd) + "'\n";

    _pg_report += _pg_prename + ":enablePWMCmd" + " '" + std::to_string(_pg_user->enablePWMCmd) + "'\n";

    _pg_report += _pg_prename + ":efiDrivesThrottle" + " '" + std::to_string(_pg_user->efiDrivesThrottle) + "'\n";

    _pg_report += _pg_prename + ":enableAnalogTPS" + " '" + std::to_string(_pg_user->enableAnalogTPS) + "'\n";

    _pg_report += _pg_prename + ":enablePWMTPS" + " '" + std::to_string(_pg_user->enablePWMTPS) + "'\n";

    _pg_report += _pg_prename + ":_enableCECANServo" + " '" + std::to_string(_pg_user->_enableCECANServo) + "'\n";

    _pg_report += _pg_prename + ":enableCECANTPS" + " '" + std::to_string(_pg_user->enableCECANTPS) + "'\n";

    _pg_report += _pg_prename + ":enableMAPTPS" + " '" + std::to_string(_pg_user->enableMAPTPS) + "'\n";

    _pg_report += textPrintefiTable1D_t(_pg_prename + ":curve", &_pg_user->curve);

    _pg_report += _pg_prename + ":startThrottle" + " '" +  to_formatted_string(_pg_user->startThrottle, 7) + "'\n";

    _pg_report += _pg_prename + ":cecanAddress" + " '" + std::to_string(_pg_user->cecanAddress) + "'\n";

    _pg_report += _pg_prename + ":tpsErrorThreshold" + " '" +  to_formatted_string(_pg_user->tpsErrorThreshold, 7) + "'\n";

    _pg_report += _pg_prename + ":maxStartThrottle" + " '" +  to_formatted_string(_pg_user->maxStartThrottle, 7) + "'\n";

    _pg_report += _pg_prename + ":closedPWMinput" + " '" + std::to_string(_pg_user->closedPWMinput) + "'\n";

    _pg_report += _pg_prename + ":openPWMinput" + " '" + std::to_string(_pg_user->openPWMinput) + "'\n";

    _pg_report += _pg_prename + ":tpsFeedbackIntGain" + " '" +  to_formatted_string(_pg_user->tpsFeedbackIntGain, 7) + "'\n";

    return _pg_report;

}// textPrintefiThrottleConfiguration_t

/*!
 * Read the contents of a efiThrottleConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiThrottleConfiguration_t(const std::string& _pg_prename, const std::string& _pg_source, efiThrottleConfiguration_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":closedPWMoutput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->closedPWMoutput = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":openPWMoutput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->openPWMoutput = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":inputfilterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->inputfilterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":outputRateLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->outputRateLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":enableAnalogCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableAnalogCmd = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enablePWMCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enablePWMCmd = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":efiDrivesThrottle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->efiDrivesThrottle = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableAnalogTPS", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableAnalogTPS = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enablePWMTPS", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enablePWMTPS = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":_enableCECANServo", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->_enableCECANServo = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableCECANTPS", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableCECANTPS = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableMAPTPS", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableMAPTPS = (uint8_t)(std::stoul(_pg_text));

    _pg_fieldcount += textReadefiTable1D_t(_pg_prename + ":curve", _pg_source, &_pg_user->curve);

    _pg_text = extractText(_pg_prename + ":startThrottle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->startThrottle = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":cecanAddress", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->cecanAddress = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":tpsErrorThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->tpsErrorThreshold = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":maxStartThrottle", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->maxStartThrottle = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":closedPWMinput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->closedPWMinput = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":openPWMinput", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->openPWMinput = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":tpsFeedbackIntGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->tpsFeedbackIntGain = std::stof(_pg_text);

    return _pg_fieldcount;

}// textReadefiThrottleConfiguration_t

/*!
 * Generate a string that describes the contents of a CoolingConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiCoolingConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiCoolingConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "CoolingConfiguration";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiCoolingConfigurationPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiCoolingConfiguration_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiCoolingConfigurationPkt

/*!
 * Generate a string that describes the contents of a efiCoolingConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiCoolingConfiguration_t(const std::string& _pg_prename, const efiCoolingConfiguration_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":chtTooCold" + " '" +  to_formatted_string(_pg_user->chtTooCold, 7) + "'\n";

    _pg_report += _pg_prename + ":chtTooHot" + " '" +  to_formatted_string(_pg_user->chtTooHot, 7) + "'\n";

    _pg_report += _pg_prename + ":chtDesired" + " '" +  to_formatted_string(_pg_user->chtDesired, 7) + "'\n";

    _pg_report += _pg_prename + ":derTime" + " '" +  to_formatted_string(_pg_user->derTime, 7) + "'\n";

    _pg_report += _pg_prename + ":trajGain" + " '" +  to_formatted_string(_pg_user->trajGain, 7) + "'\n";

    _pg_report += _pg_prename + ":forGain" + " '" +  to_formatted_string(_pg_user->forGain, 7) + "'\n";

    _pg_report += _pg_prename + ":proGain" + " '" +  to_formatted_string(_pg_user->proGain, 7) + "'\n";

    _pg_report += _pg_prename + ":intGain" + " '" +  to_formatted_string(_pg_user->intGain, 7) + "'\n";

    _pg_report += _pg_prename + ":derGain" + " '" +  to_formatted_string(_pg_user->derGain, 7) + "'\n";

    _pg_report += _pg_prename + ":enableSplitCooling" + " '" + std::to_string(_pg_user->enableSplitCooling) + "'\n";

    _pg_report += _pg_prename + ":closedPWM1" + " '" + std::to_string(_pg_user->closedPWM1) + "'\n";

    _pg_report += _pg_prename + ":openPWM1" + " '" + std::to_string(_pg_user->openPWM1) + "'\n";

    _pg_report += _pg_prename + ":closedPWM2" + " '" + std::to_string(_pg_user->closedPWM2) + "'\n";

    _pg_report += _pg_prename + ":openPWM2" + " '" + std::to_string(_pg_user->openPWM2) + "'\n";

    _pg_report += _pg_prename + ":cecanAddress1" + " '" + std::to_string(_pg_user->cecanAddress1) + "'\n";

    _pg_report += _pg_prename + ":cecanAddress2" + " '" + std::to_string(_pg_user->cecanAddress2) + "'\n";

    return _pg_report;

}// textPrintefiCoolingConfiguration_t

/*!
 * Read the contents of a efiCoolingConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiCoolingConfiguration_t(const std::string& _pg_prename, const std::string& _pg_source, efiCoolingConfiguration_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":chtTooCold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->chtTooCold = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":chtTooHot", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->chtTooHot = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":chtDesired", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->chtDesired = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":derTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->derTime = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":trajGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->trajGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":forGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->forGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":proGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->proGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":intGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->intGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":derGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->derGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":enableSplitCooling", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableSplitCooling = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":closedPWM1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->closedPWM1 = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":openPWM1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->openPWM1 = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":closedPWM2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->closedPWM2 = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":openPWM2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->openPWM2 = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":cecanAddress1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->cecanAddress1 = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":cecanAddress2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->cecanAddress2 = (uint8_t)(std::stoul(_pg_text));

    return _pg_fieldcount;

}// textReadefiCoolingConfiguration_t

/*!
 * Generate a string that describes the contents of a EngineConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiEngineConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiEngineConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "EngineConfiguration";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiEngineConfigurationPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiEngineConfiguration_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiEngineConfigurationPkt

/*!
 * Generate a string that describes the contents of a efiEngineConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiEngineConfiguration_t(const std::string& _pg_prename, const efiEngineConfiguration_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":displacement" + " '" +  to_formatted_string(_pg_user->displacement, 7) + "'\n";

    _pg_report += _pg_prename + ":ignoreInputEnable" + " '" + std::to_string(_pg_user->ignoreInputEnable) + "'\n";

    _pg_report += _pg_prename + ":preventNormalRotation" + " '" + std::to_string(_pg_user->preventNormalRotation) + "'\n";

    _pg_report += _pg_prename + ":preventReverseRotation" + " '" + std::to_string(_pg_user->preventReverseRotation) + "'\n";

    _pg_report += _pg_prename + ":_enableCrank2" + " '" + std::to_string(_pg_user->_enableCrank2) + "'\n";

    _pg_report += _pg_prename + ":enableSpark3" + " '" + std::to_string(_pg_user->enableSpark3) + "'\n";

    _pg_report += _pg_prename + ":ignActiveHigh" + " '" + std::to_string(_pg_user->ignActiveHigh) + "'\n";

    _pg_report += _pg_prename + ":api8" + " '" + std::to_string(_pg_user->api8) + "'\n";

    _pg_report += _pg_prename + ":maxIgnDwellTime" + " '" + std::to_string(_pg_user->maxIgnDwellTime) + "'\n";

    _pg_report += _pg_prename + ":minIgnActiveTime" + " '" + std::to_string(_pg_user->minIgnActiveTime) + "'\n";

    _pg_report += _pg_prename + ":hardRevLimit" + " '" +  to_formatted_string(_pg_user->hardRevLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":softRevLimit" + " '" +  to_formatted_string(_pg_user->softRevLimit, 7) + "'\n";

    _pg_report += _pg_prename + ":rpmfilterlpf" + " '" +  to_formatted_string(_pg_user->rpmfilterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":mapErrorThreshold" + " '" +  to_formatted_string(_pg_user->mapErrorThreshold, 7) + "'\n";

    _pg_report += textPrintefiCrankSense_t(_pg_prename + ":crankSense1", &_pg_user->crankSense1);

    _pg_report += textPrintefiCrankSense_t(_pg_prename + ":crankSense2", &_pg_user->crankSense2);

    _pg_report += _pg_prename + ":chtReference" + " '" +  to_formatted_string(_pg_user->chtReference, 7) + "'\n";

    return _pg_report;

}// textPrintefiEngineConfiguration_t

/*!
 * Read the contents of a efiEngineConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiEngineConfiguration_t(const std::string& _pg_prename, const std::string& _pg_source, efiEngineConfiguration_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":displacement", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->displacement = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":ignoreInputEnable", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->ignoreInputEnable = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":preventNormalRotation", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->preventNormalRotation = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":preventReverseRotation", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->preventReverseRotation = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":_enableCrank2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->_enableCrank2 = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableSpark3", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableSpark3 = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":ignActiveHigh", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->ignActiveHigh = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":api8", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->api8 = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":maxIgnDwellTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->maxIgnDwellTime = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":minIgnActiveTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->minIgnActiveTime = (uint16_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":hardRevLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->hardRevLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":softRevLimit", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->softRevLimit = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":rpmfilterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->rpmfilterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":mapErrorThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->mapErrorThreshold = std::stof(_pg_text);

    _pg_fieldcount += textReadefiCrankSense_t(_pg_prename + ":crankSense1", _pg_source, &_pg_user->crankSense1);

    _pg_fieldcount += textReadefiCrankSense_t(_pg_prename + ":crankSense2", _pg_source, &_pg_user->crankSense2);

    _pg_text = extractText(_pg_prename + ":chtReference", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->chtReference = std::stof(_pg_text);

    return _pg_fieldcount;

}// textReadefiEngineConfiguration_t

/*!
 * Generate a string that describes the contents of a InjectorConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiInjectorConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiInjectorConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "InjectorConfiguration";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiInjectorConfigurationPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiInjectorConfiguration_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiInjectorConfigurationPkt

/*!
 * Generate a string that describes the contents of a efiInjectorConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiInjectorConfiguration_t(const std::string& _pg_prename, const efiInjectorConfiguration_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":enableInjector2" + " '" + std::to_string(_pg_user->enableInjector2) + "'\n";

    _pg_report += _pg_prename + ":enableInjectorIndependence" + " '" + std::to_string(_pg_user->enableInjectorIndependence) + "'\n";

    _pg_report += _pg_prename + ":spareTempIsCHT" + " '" + std::to_string(_pg_user->spareTempIsCHT) + "'\n";

    _pg_report += _pg_prename + ":spareTempIsMAT" + " '" + std::to_string(_pg_user->spareTempIsMAT) + "'\n";

    _pg_report += _pg_prename + ":enableInjector3" + " '" + std::to_string(_pg_user->enableInjector3) + "'\n";

    _pg_report += _pg_prename + ":injectorsAreRedundant" + " '" + std::to_string(_pg_user->injectorsAreRedundant) + "'\n";

    _pg_report += _pg_prename + ":phaseEdge" + " '" + std::to_string(_pg_user->phaseEdge) + "'\n";

    _pg_report += _pg_prename + ":fuelVolumePercentPerMAT" + " '" +  to_formatted_string(_pg_user->fuelVolumePercentPerMAT, 7) + "'\n";

    _pg_report += _pg_prename + ":multiplier" + " '" +  to_formatted_string(_pg_user->multiplier, 7) + "'\n";

    _pg_report += _pg_prename + ":nominalFuelPressure" + " '" +  to_formatted_string(_pg_user->nominalFuelPressure, 7) + "'\n";

    _pg_report += _pg_prename + ":nominalFlowrate1" + " '" +  to_formatted_string(_pg_user->nominalFlowrate1, 7) + "'\n";

    _pg_report += _pg_prename + ":nominalFlowrate2" + " '" +  to_formatted_string(_pg_user->nominalFlowrate2, 7) + "'\n";

    _pg_report += _pg_prename + ":minOpeningTime1" + " '" + std::to_string(_pg_user->minOpeningTime1) + "'\n";

    _pg_report += _pg_prename + ":minOpeningTime2" + " '" + std::to_string(_pg_user->minOpeningTime2) + "'\n";

    _pg_report += _pg_prename + ":fuelUsedCorrector" + " '" +  to_formatted_string(_pg_user->fuelUsedCorrector, 7) + "'\n";

    _pg_report += _pg_prename + ":nominalFlowrate3" + " '" +  to_formatted_string(_pg_user->nominalFlowrate3, 7) + "'\n";

    _pg_report += _pg_prename + ":minOpeningTime3" + " '" + std::to_string(_pg_user->minOpeningTime3) + "'\n";

    _pg_report += _pg_prename + ":oilPrimingFreq" + " '" +  to_formatted_string(_pg_user->oilPrimingFreq, 7) + "'\n";

    _pg_report += _pg_prename + ":spareTempIsOilT" + " '" + std::to_string(_pg_user->spareTempIsOilT) + "'\n";

    _pg_report += _pg_prename + ":injector2IsOilInj" + " '" + std::to_string(_pg_user->injector2IsOilInj) + "'\n";

    _pg_report += _pg_prename + ":injector3IsOilInj" + " '" + std::to_string(_pg_user->injector3IsOilInj) + "'\n";

    _pg_report += _pg_prename + ":oilForStarting" + " '" +  to_formatted_string(_pg_user->oilForStarting, 7) + "'\n";

    _pg_report += _pg_prename + ":oilUsedCorrector" + " '" +  to_formatted_string(_pg_user->oilUsedCorrector, 7) + "'\n";

    return _pg_report;

}// textPrintefiInjectorConfiguration_t

/*!
 * Read the contents of a efiInjectorConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiInjectorConfiguration_t(const std::string& _pg_prename, const std::string& _pg_source, efiInjectorConfiguration_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":enableInjector2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableInjector2 = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableInjectorIndependence", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableInjectorIndependence = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":spareTempIsCHT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->spareTempIsCHT = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":spareTempIsMAT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->spareTempIsMAT = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableInjector3", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableInjector3 = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":injectorsAreRedundant", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->injectorsAreRedundant = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":phaseEdge", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->phaseEdge = (InjectorPhaseEdge)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":fuelVolumePercentPerMAT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->fuelVolumePercentPerMAT = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":multiplier", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->multiplier = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":nominalFuelPressure", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->nominalFuelPressure = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":nominalFlowrate1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->nominalFlowrate1 = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":nominalFlowrate2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->nominalFlowrate2 = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":minOpeningTime1", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->minOpeningTime1 = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":minOpeningTime2", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->minOpeningTime2 = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":fuelUsedCorrector", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->fuelUsedCorrector = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":nominalFlowrate3", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->nominalFlowrate3 = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":minOpeningTime3", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->minOpeningTime3 = (uint32_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":oilPrimingFreq", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->oilPrimingFreq = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":spareTempIsOilT", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->spareTempIsOilT = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":injector2IsOilInj", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->injector2IsOilInj = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":injector3IsOilInj", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->injector3IsOilInj = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":oilForStarting", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->oilForStarting = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":oilUsedCorrector", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->oilUsedCorrector = std::stof(_pg_text);

    return _pg_fieldcount;

}// textReadefiInjectorConfiguration_t

/*!
 * Generate a string that describes the contents of a RPMController packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiRPMControllerPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiRPMController_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "RPMController";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiRPMControllerPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiRPMController_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiRPMControllerPkt

/*!
 * Generate a string that describes the contents of a efiRPMController_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiRPMController_t(const std::string& _pg_prename, const efiRPMController_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":minRPM" + " '" +  to_formatted_string(_pg_user->minRPM, 7) + "'\n";

    _pg_report += _pg_prename + ":maxRPM" + " '" +  to_formatted_string(_pg_user->maxRPM, 7) + "'\n";

    _pg_report += _pg_prename + ":enableRPMfromThrottleCmd" + " '" + std::to_string(_pg_user->enableRPMfromThrottleCmd) + "'\n";

    _pg_report += _pg_prename + ":enableLowRPMLimiter" + " '" + std::to_string(_pg_user->enableLowRPMLimiter) + "'\n";

    _pg_report += _pg_prename + ":enableHighRPMLimiter" + " '" + std::to_string(_pg_user->enableHighRPMLimiter) + "'\n";

    _pg_report += _pg_prename + ":updateRate" + " '" +  to_formatted_string(_pg_user->updateRate, 7) + "'\n";

    _pg_report += _pg_prename + ":throttleAtMinRPM" + " '" +  to_formatted_string(_pg_user->throttleAtMinRPM, 7) + "'\n";

    _pg_report += _pg_prename + ":rpmToThrottlePower" + " '" +  to_formatted_string(_pg_user->rpmToThrottlePower, 7) + "'\n";

    _pg_report += _pg_prename + ":rpmCmdfilterlpf" + " '" +  to_formatted_string(_pg_user->rpmCmdfilterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":maxRateCmd" + " '" +  to_formatted_string(_pg_user->maxRateCmd, 7) + "'\n";

    _pg_report += _pg_prename + ":trajGain" + " '" +  to_formatted_string(_pg_user->trajGain, 7) + "'\n";

    _pg_report += _pg_prename + ":gainScaler" + " '" +  to_formatted_string(_pg_user->gainScaler, 7) + "'\n";

    _pg_report += _pg_prename + ":forGain" + " '" +  to_formatted_string(_pg_user->forGain, 7) + "'\n";

    _pg_report += _pg_prename + ":proGain" + " '" +  to_formatted_string(_pg_user->proGain, 7) + "'\n";

    _pg_report += _pg_prename + ":intGain" + " '" +  to_formatted_string(_pg_user->intGain, 7) + "'\n";

    _pg_report += _pg_prename + ":derGain" + " '" +  to_formatted_string(_pg_user->derGain, 7) + "'\n";

    _pg_report += _pg_prename + ":derivativeTime" + " '" +  to_formatted_string(_pg_user->derivativeTime, 7) + "'\n";

    _pg_report += _pg_prename + ":outputfilterlpf" + " '" +  to_formatted_string(_pg_user->outputfilterlpf, 7) + "'\n";

    _pg_report += _pg_prename + ":outputsoftband" + " '" +  to_formatted_string(_pg_user->outputsoftband, 7) + "'\n";

    return _pg_report;

}// textPrintefiRPMController_t

/*!
 * Read the contents of a efiRPMController_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiRPMController_t(const std::string& _pg_prename, const std::string& _pg_source, efiRPMController_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":minRPM", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->minRPM = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":maxRPM", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->maxRPM = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":enableRPMfromThrottleCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableRPMfromThrottleCmd = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableLowRPMLimiter", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableLowRPMLimiter = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":enableHighRPMLimiter", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enableHighRPMLimiter = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":updateRate", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->updateRate = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":throttleAtMinRPM", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->throttleAtMinRPM = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":rpmToThrottlePower", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->rpmToThrottlePower = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":rpmCmdfilterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->rpmCmdfilterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":maxRateCmd", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->maxRateCmd = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":trajGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->trajGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":gainScaler", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->gainScaler = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":forGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->forGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":proGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->proGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":intGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->intGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":derGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->derGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":derivativeTime", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->derivativeTime = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":outputfilterlpf", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->outputfilterlpf = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":outputsoftband", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->outputsoftband = std::stof(_pg_text);

    return _pg_fieldcount;

}// textReadefiRPMController_t

/*!
 * Generate a string that describes the contents of a efiMaintenanceItemConfig_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiMaintenanceItemConfig_t(const std::string& _pg_prename, const efiMaintenanceItemConfig_t* _pg_user)
{
    std::string _pg_report;

    _pg_report += _pg_prename + ":trigger" + " '" + std::to_string(_pg_user->trigger) + "'\n";

    _pg_report += _pg_prename + ":interval" + " '" + std::to_string(_pg_user->interval) + "'\n";

    _pg_report += _pg_prename + ":description '" + std::string(_pg_user->description) + "'\n";

    return _pg_report;

}// textPrintefiMaintenanceItemConfig_t

/*!
 * Read the contents of a efiMaintenanceItemConfig_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiMaintenanceItemConfig_t(const std::string& _pg_prename, const std::string& _pg_source, efiMaintenanceItemConfig_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;

    _pg_text = extractText(_pg_prename + ":trigger", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->trigger = (MaintenanceTriggers)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":interval", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->interval = (uint32_t)(std::stoul(_pg_text));

    pgstrncpy(_pg_user->description, extractText(_pg_prename + ":description", _pg_source, &_pg_fieldcount).c_str(), 64);

    return _pg_fieldcount;

}// textReadefiMaintenanceItemConfig_t

/*!
 * Generate a string that describes the contents of a MaintenanceConfiguration packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiMaintenanceConfigurationPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiMaintenanceConfiguration_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "MaintenanceConfiguration";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiMaintenanceConfigurationPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiMaintenanceConfiguration_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiMaintenanceConfigurationPkt

/*!
 * Generate a string that describes the contents of a efiMaintenanceConfiguration_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiMaintenanceConfiguration_t(const std::string& _pg_prename, const efiMaintenanceConfiguration_t* _pg_user)
{
    std::string _pg_report;
    unsigned _pg_i = 0;

    _pg_report += _pg_prename + ":numItems" + " '" + std::to_string(_pg_user->numItems) + "'\n";

    _pg_report += _pg_prename + ":hotTimeGain" + " '" +  to_formatted_string(_pg_user->hotTimeGain, 7) + "'\n";

    _pg_report += _pg_prename + ":highLoadThreshold" + " '" +  to_formatted_string(_pg_user->highLoadThreshold, 7) + "'\n";

    // List of maintenance item
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_report += textPrintefiMaintenanceItemConfig_t(_pg_prename + ":MaintenanceItemConfig" + "[" + std::to_string(_pg_i) + "]", &_pg_user->MaintenanceItemConfig[_pg_i]);

    return _pg_report;

}// textPrintefiMaintenanceConfiguration_t

/*!
 * Read the contents of a efiMaintenanceConfiguration_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiMaintenanceConfiguration_t(const std::string& _pg_prename, const std::string& _pg_source, efiMaintenanceConfiguration_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;

    _pg_text = extractText(_pg_prename + ":numItems", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->numItems = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":hotTimeGain", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->hotTimeGain = std::stof(_pg_text);

    _pg_text = extractText(_pg_prename + ":highLoadThreshold", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->highLoadThreshold = std::stof(_pg_text);

    // List of maintenance item
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numItems && _pg_i < maxMaintenanceItems; _pg_i++)
        _pg_fieldcount += textReadefiMaintenanceItemConfig_t(_pg_prename + ":MaintenanceItemConfig" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_user->MaintenanceItemConfig[_pg_i]);

    return _pg_fieldcount;

}// textReadefiMaintenanceConfiguration_t

/*!
 * Generate a string that describes the contents of a Table2D_1x packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiTable2D_1xPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiTable2D_1x_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "Table2D_1x";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiTable2D_1xPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiTable2D_1x_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiTable2D_1xPkt

/*!
 * Generate a string that describes the contents of a efiTable2D_1x_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiTable2D_1x_t(const std::string& _pg_prename, const efiTable2D_1x_t* _pg_user)
{
    std::string _pg_report;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    _pg_report += _pg_prename + ":enabled" + " '" + std::to_string(_pg_user->enabled) + "'\n";

    _pg_report += _pg_prename + ":loadfrommap" + " '" + std::to_string(_pg_user->loadfrommap) + "'\n";

    _pg_report += _pg_prename + ":index" + " '" + std::to_string(_pg_user->index) + "'\n";

    _pg_report += _pg_prename + ":numrows" + " '" + std::to_string(_pg_user->numrows) + "'\n";

    _pg_report += _pg_prename + ":numcols" + " '" + std::to_string(_pg_user->numcols) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        _pg_report += _pg_prename + ":rowindices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(_pg_user->rowindices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        _pg_report += _pg_prename + ":colindices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(_pg_user->colindices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)_pg_user->numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            _pg_report += _pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" +  to_formatted_string(_pg_user->data[_pg_i][_pg_j], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)_pg_user->numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            _pg_report += _pg_prename + ":meta" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + std::to_string(_pg_user->meta[_pg_i][_pg_j]) + "'\n";

    return _pg_report;

}// textPrintefiTable2D_1x_t

/*!
 * Read the contents of a efiTable2D_1x_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiTable2D_1x_t(const std::string& _pg_prename, const std::string& _pg_source, efiTable2D_1x_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    _pg_text = extractText(_pg_prename + ":enabled", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enabled = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":loadfrommap", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->loadfrommap = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":index", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->index = (efiOldTableList)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":numrows", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->numrows = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":numcols", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->numcols = (uint8_t)(std::stoul(_pg_text));

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":rowindices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            _pg_user->rowindices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":colindices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            _pg_user->colindices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)_pg_user->numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
        {
            _pg_text = extractText(_pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]", _pg_source, &_pg_fieldcount);
            if(!_pg_text.empty())
                _pg_user->data[_pg_i][_pg_j] = std::stof(_pg_text);
        }

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)_pg_user->numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
        {
            _pg_text = extractText(_pg_prename + ":meta" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]", _pg_source, &_pg_fieldcount);
            if(!_pg_text.empty())
                _pg_user->meta[_pg_i][_pg_j] = (uint8_t)(std::stoul(_pg_text));
        }

    return _pg_fieldcount;

}// textReadefiTable2D_1x_t

/*!
 * Generate a string that describes the contents of a Table2D packet
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_pkt is the data to print
 * \return a string describing the contents of _pg_pkt
 */
std::string textPrintefiTable2DPkt(std::string _pg_prename, const efiPacket_t* _pg_pkt)
{
    std::string _pg_report;

    // Structure to decode into
    efiTable2D_t _pg_user;

    if(_pg_prename.empty())
        _pg_prename = "Table2D";

    // All zeroes before decoding
    memset(&_pg_user, 0, sizeof(_pg_user));

    // Decode packet
    if(!decodeefiTable2DPkt(_pg_pkt, &_pg_user))
    {
        _pg_report = _pg_prename + " packet failed to decode\n";
        return _pg_report;
    }

    // Print the packet size
    _pg_report += _pg_prename + " packet size is " + std::to_string(geteficommsPacketSize(_pg_pkt)) + "\n";

    _pg_report += textPrintefiTable2D_t(_pg_prename, &_pg_user);

    return _pg_report;

}// textPrintefiTable2DPkt

/*!
 * Generate a string that describes the contents of a efiTable2D_t
 * \param _pg_prename is prepended to the name of the data field in the report
 * \param _pg_user is the structure to report
 * \return a string containing a report of the contents of user
 */
std::string textPrintefiTable2D_t(const std::string& _pg_prename, const efiTable2D_t* _pg_user)
{
    std::string _pg_report;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    _pg_report += _pg_prename + ":enabled" + " '" + std::to_string(_pg_user->enabled) + "'\n";

    _pg_report += _pg_prename + ":index" + " '" + std::to_string(_pg_user->index) + "'\n";

    _pg_report += _pg_prename + ":addone" + " '" + std::to_string(_pg_user->addone) + "'\n";

    _pg_report += _pg_prename + ":rowindex" + " '" + std::to_string(_pg_user->rowindex) + "'\n";

    _pg_report += _pg_prename + ":colindex" + " '" + std::to_string(_pg_user->colindex) + "'\n";

    _pg_report += _pg_prename + ":multiplierindex" + " '" + std::to_string(_pg_user->multiplierindex) + "'\n";

    _pg_report += _pg_prename + ":dividerindex" + " '" + std::to_string(_pg_user->dividerindex) + "'\n";

    _pg_report += _pg_prename + ":description '" + std::string(_pg_user->description) + "'\n";

    _pg_report += _pg_prename + ":numrows" + " '" + std::to_string(_pg_user->numrows) + "'\n";

    _pg_report += _pg_prename + ":numcols" + " '" + std::to_string(_pg_user->numcols) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        _pg_report += _pg_prename + ":rowindices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(_pg_user->rowindices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
        _pg_report += _pg_prename + ":colindices" + "[" + std::to_string(_pg_i) + "]" + " '" +  to_formatted_string(_pg_user->colindices[_pg_i], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)_pg_user->numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            _pg_report += _pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" +  to_formatted_string(_pg_user->data[_pg_i][_pg_j], 7) + "'\n";

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)_pg_user->numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
            _pg_report += _pg_prename + ":meta" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]" + " '" + std::to_string(_pg_user->meta[_pg_i][_pg_j]) + "'\n";

    return _pg_report;

}// textPrintefiTable2D_t

/*!
 * Read the contents of a efiTable2D_t structure from text
 * \param _pg_prename is prepended to the name of the data field to form the text key
 * \param _pg_source is text to search to find the data field keys
 * \param _pg_user receives any data read from the text source
 * \return The number of fields that were read from the text source
 */
int textReadefiTable2D_t(const std::string& _pg_prename, const std::string& _pg_source, efiTable2D_t* _pg_user)
{
    std::string _pg_text;
    int _pg_fieldcount = 0;
    unsigned _pg_i = 0;
    unsigned _pg_j = 0;

    _pg_text = extractText(_pg_prename + ":enabled", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->enabled = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":index", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->index = (efiTableList)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":addone", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->addone = (unsigned)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":rowindex", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->rowindex = (efiTableIndex)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":colindex", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->colindex = (efiTableIndex)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":multiplierindex", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->multiplierindex = (efiTableIndex)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":dividerindex", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->dividerindex = (efiTableIndex)(std::stoul(_pg_text));

    pgstrncpy(_pg_user->description, extractText(_pg_prename + ":description", _pg_source, &_pg_fieldcount).c_str(), 28);

    _pg_text = extractText(_pg_prename + ":numrows", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->numrows = (uint8_t)(std::stoul(_pg_text));

    _pg_text = extractText(_pg_prename + ":numcols", _pg_source, &_pg_fieldcount);
    if(!_pg_text.empty())
        _pg_user->numcols = (uint8_t)(std::stoul(_pg_text));

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":rowindices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            _pg_user->rowindices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numcols && _pg_i < EFI_TABLE_MAX_COLS; _pg_i++)
    {
        _pg_text = extractText(_pg_prename + ":colindices" + "[" + std::to_string(_pg_i) + "]", _pg_source, &_pg_fieldcount);
        if(!_pg_text.empty())
            _pg_user->colindices[_pg_i] = std::stof(_pg_text);
    }

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)_pg_user->numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
        {
            _pg_text = extractText(_pg_prename + ":data" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]", _pg_source, &_pg_fieldcount);
            if(!_pg_text.empty())
                _pg_user->data[_pg_i][_pg_j] = std::stof(_pg_text);
        }

    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->numrows && _pg_i < EFI_TABLE_MAX_ROWS; _pg_i++)
        for(_pg_j = 0; _pg_j < (unsigned)_pg_user->numcols && _pg_j < EFI_TABLE_MAX_COLS; _pg_j++)
        {
            _pg_text = extractText(_pg_prename + ":meta" + "[" + std::to_string(_pg_i) + "]" + "[" + std::to_string(_pg_j) + "]", _pg_source, &_pg_fieldcount);
            if(!_pg_text.empty())
                _pg_user->meta[_pg_i][_pg_j] = (uint8_t)(std::stoul(_pg_text));
        }

    return _pg_fieldcount;

}// textReadefiTable2D_t

// end of efiprintutil.cpp
