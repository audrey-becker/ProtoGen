// scaledencode.c was generated by ProtoGen version 3.1.d

#include "scaledencode.h"
#include "fieldencode.h"


#ifdef UINT64_MAX

/*!
 * Encode a double on a byte stream by floating point scaling to fit in 8
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo8UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 18446744073709551615ull)
        number = 18446744073709551615ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint64ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 8
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo8UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 18446744073709551615ull)
        number = 18446744073709551615ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint64ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 8
 * signed bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo8SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 9223372036854775807ll)
            number = 9223372036854775807ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-9223372036854775807ll - 1))
            number = (-9223372036854775807ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int64ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 8
 * signed bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo8SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 9223372036854775807ll)
            number = 9223372036854775807ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-9223372036854775807ll - 1))
            number = (-9223372036854775807ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int64ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 7
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo7UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 72057594037927935ull)
        number = 72057594037927935ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint56ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 7
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo7UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 72057594037927935ull)
        number = 72057594037927935ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint56ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 7
 * signed bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo7SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 36028797018963967ll)
            number = 36028797018963967ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-36028797018963967ll - 1))
            number = (-36028797018963967ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int56ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 7
 * signed bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo7SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 36028797018963967ll)
            number = 36028797018963967ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-36028797018963967ll - 1))
            number = (-36028797018963967ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int56ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 6
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo6UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 281474976710655ull)
        number = 281474976710655ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint48ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 6
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo6UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 281474976710655ull)
        number = 281474976710655ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint48ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 6
 * signed bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo6SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 140737488355327ll)
            number = 140737488355327ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-140737488355327ll - 1))
            number = (-140737488355327ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int48ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 6
 * signed bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo6SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 140737488355327ll)
            number = 140737488355327ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-140737488355327ll - 1))
            number = (-140737488355327ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int48ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 5
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo5UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 1099511627775ull)
        number = 1099511627775ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint40ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 5
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo5UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 1099511627775ull)
        number = 1099511627775ull;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint64_t)(scaledvalue + 0.5); // account for fractional truncation

    uint40ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 5
 * signed bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo5SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 549755813887ll)
            number = 549755813887ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-549755813887ll - 1))
            number = (-549755813887ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int40ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 5
 * signed bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo5SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int64_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 549755813887ll)
            number = 549755813887ll;
        else
            number = (int64_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-549755813887ll - 1))
            number = (-549755813887ll - 1);
        else
            number = (int64_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int40ToLeBytes(number, bytes, index);
}


/*!
 * Scale a double using floating point scaling to the base integer type used
 * for bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int float64ScaledToBitfield(double value, double min, double scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Protect from underflow
    if(value < min)
        return 0;

    // Scale the number
    value = (value - min)*scaler;

    // Protect from overflow
    if(value > max)
        return max;

    // Account for fractional truncation
    return (unsigned int)(value + 0.5);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 4
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo4UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 4294967295ul)
        number = 4294967295ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5); // account for fractional truncation

    uint32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 4
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo4UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 4294967295ul)
        number = 4294967295ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5); // account for fractional truncation

    uint32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 4
 * signed bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo4SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 2147483647l)
            number = 2147483647l;
        else
            number = (int32_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-2147483647l - 1))
            number = (-2147483647l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 4
 * signed bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo4SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 2147483647l)
            number = 2147483647l;
        else
            number = (int32_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-2147483647l - 1))
            number = (-2147483647l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 3
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo3UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 16777215ul)
        number = 16777215ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5); // account for fractional truncation

    uint24ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 3
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo3UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 16777215ul)
        number = 16777215ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5); // account for fractional truncation

    uint24ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 3
 * signed bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo3SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 8388607)
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-8388607l - 1))
            number = (-8388607l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int24ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 3
 * signed bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo3SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 8388607)
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-8388607l - 1))
            number = (-8388607l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int24ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 2
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo2UnsignedBeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 65535u)
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5); // account for fractional truncation

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 2
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo2UnsignedLeBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 65535u)
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5); // account for fractional truncation

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 2
 * signed bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo2SignedBeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 32767)
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-32767 - 1))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 2
 * signed bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo2SignedLeBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 32767)
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-32767 - 1))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 1
 * unsigned byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float64ScaledTo1UnsignedBytes(double value, uint8_t* bytes, int* index, double min, double scaler)
{
    // scale the number
    double scaledvalue = (double)((value - min)*scaler);
    uint8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 255u)
        number = 255u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint8_t)(scaledvalue + 0.5); // account for fractional truncation

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a double on a byte stream by floating point scaling to fit in 1
 * signed byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float64ScaledTo1SignedBytes(double value, uint8_t* bytes, int* index, double scaler)
{
    // scale the number
    double scaledvalue = (double)(value*scaler);
    int8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 127)
            number = 127;
        else
            number = (int8_t)(scaledvalue + 0.5); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-127 - 1))
            number = (-127 - 1);
        else
            number = (int8_t)(scaledvalue - 0.5); // account for fractional truncation
    }

    int8ToBytes(number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 8 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo8UnsignedBeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
    }

    uint64ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 8 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo8UnsignedLeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
    }

    uint64ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 8 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo8SignedBeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    int64ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 8 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo8SignedLeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    int64ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 7 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo7UnsignedBeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 72057594037927935ull)
            number = 72057594037927935ull;
    }

    uint56ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 7 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo7UnsignedLeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 72057594037927935ull)
            number = 72057594037927935ull;
    }

    uint56ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 7 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo7SignedBeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 36028797018963967ll)
        number = 36028797018963967ll;
    else if(number < (-36028797018963967ll - 1))
        number = (-36028797018963967ll - 1);

    int56ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 7 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo7SignedLeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 36028797018963967ll)
        number = 36028797018963967ll;
    else if(number < (-36028797018963967ll - 1))
        number = (-36028797018963967ll - 1);

    int56ToLeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 6 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo6UnsignedBeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 281474976710655ull)
            number = 281474976710655ull;
    }

    uint48ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 6 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo6UnsignedLeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 281474976710655ull)
            number = 281474976710655ull;
    }

    uint48ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 6 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo6SignedBeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 140737488355327ll)
        number = 140737488355327ll;
    else if(number < (-140737488355327ll - 1))
        number = (-140737488355327ll - 1);

    int48ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 6 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo6SignedLeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 140737488355327ll)
        number = 140737488355327ll;
    else if(number < (-140737488355327ll - 1))
        number = (-140737488355327ll - 1);

    int48ToLeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 5 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo5UnsignedBeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 1099511627775ull)
            number = 1099511627775ull;
    }

    uint40ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 5 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo5UnsignedLeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 1099511627775ull)
            number = 1099511627775ull;
    }

    uint40ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 5 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo5SignedBeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 549755813887ll)
        number = 549755813887ll;
    else if(number < (-549755813887ll - 1))
        number = (-549755813887ll - 1);

    int40ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 5 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo5SignedLeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 549755813887ll)
        number = 549755813887ll;
    else if(number < (-549755813887ll - 1))
        number = (-549755813887ll - 1);

    int40ToLeBytes((int64_t)number, bytes, index);
}


/*!
 * Scale a uint64_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint64ScaledToBitfield(uint64_t value, int64_t min, uint64_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo4UnsignedBeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 4294967295ul)
            number = 4294967295ul;
    }

    uint32ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo4UnsignedLeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 4294967295ul)
            number = 4294967295ul;
    }

    uint32ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo4SignedBeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 2147483647l)
        number = 2147483647l;
    else if(number < (-2147483647l - 1))
        number = (-2147483647l - 1);

    int32ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo4SignedLeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 2147483647l)
        number = 2147483647l;
    else if(number < (-2147483647l - 1))
        number = (-2147483647l - 1);

    int32ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo3UnsignedBeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo3UnsignedLeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo3SignedBeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo3SignedLeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo2UnsignedBeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo2UnsignedLeBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo2SignedBeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo2SignedLeBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint64ScaledTo1UnsignedBytes(uint64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a uint64_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint64ScaledTo1SignedBytes(uint64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 8 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo8UnsignedBeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
    }

    uint64ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 8 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo8UnsignedLeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
    }

    uint64ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 8 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo8SignedBeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    int64ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 8 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 8 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo8SignedLeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    int64ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 7 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo7UnsignedBeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 72057594037927935ull)
            number = 72057594037927935ull;
    }

    uint56ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 7 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo7UnsignedLeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 72057594037927935ull)
            number = 72057594037927935ull;
    }

    uint56ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 7 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo7SignedBeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 36028797018963967ll)
        number = 36028797018963967ll;
    else if(number < (-36028797018963967ll - 1))
        number = (-36028797018963967ll - 1);

    int56ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 7 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 7 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo7SignedLeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 36028797018963967ll)
        number = 36028797018963967ll;
    else if(number < (-36028797018963967ll - 1))
        number = (-36028797018963967ll - 1);

    int56ToLeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 6 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo6UnsignedBeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 281474976710655ull)
            number = 281474976710655ull;
    }

    uint48ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 6 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo6UnsignedLeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 281474976710655ull)
            number = 281474976710655ull;
    }

    uint48ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 6 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo6SignedBeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 140737488355327ll)
        number = 140737488355327ll;
    else if(number < (-140737488355327ll - 1))
        number = (-140737488355327ll - 1);

    int48ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 6 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 6 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo6SignedLeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 140737488355327ll)
        number = 140737488355327ll;
    else if(number < (-140737488355327ll - 1))
        number = (-140737488355327ll - 1);

    int48ToLeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 5 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo5UnsignedBeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 1099511627775ull)
            number = 1099511627775ull;
    }

    uint40ToBeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 5 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo5UnsignedLeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 1099511627775ull)
            number = 1099511627775ull;
    }

    uint40ToLeBytes((uint64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 5 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo5SignedBeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 549755813887ll)
        number = 549755813887ll;
    else if(number < (-549755813887ll - 1))
        number = (-549755813887ll - 1);

    int40ToBeBytes((int64_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 5 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 5 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo5SignedLeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 549755813887ll)
        number = 549755813887ll;
    else if(number < (-549755813887ll - 1))
        number = (-549755813887ll - 1);

    int40ToLeBytes((int64_t)number, bytes, index);
}


/*!
 * Scale a int64_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int64ScaledToBitfield(int64_t value, int64_t min, uint64_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo4UnsignedBeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 4294967295ul)
            number = 4294967295ul;
    }

    uint32ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo4UnsignedLeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 4294967295ul)
            number = 4294967295ul;
    }

    uint32ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo4SignedBeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 2147483647l)
        number = 2147483647l;
    else if(number < (-2147483647l - 1))
        number = (-2147483647l - 1);

    int32ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo4SignedLeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 2147483647l)
        number = 2147483647l;
    else if(number < (-2147483647l - 1))
        number = (-2147483647l - 1);

    int32ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo3UnsignedBeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo3UnsignedLeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo3SignedBeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo3SignedLeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo2UnsignedBeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo2UnsignedLeBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo2SignedBeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo2SignedLeBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int64ScaledTo1UnsignedBytes(int64_t value, uint8_t* bytes, int* index, int64_t min, uint64_t scaler)
{
    // scale the number
    uint64_t number = 0;

    // Make sure number fits in the range
    if(((int64_t)value) > min)
    {
        number = (uint64_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a int64_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int64ScaledTo1SignedBytes(int64_t value, uint8_t* bytes, int* index, uint64_t scaler)
{
    // scale the number
    int64_t number = (int64_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


#endif // UINT64_MAX

/*!
 * Scale a float using floating point scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int float32ScaledToBitfield(float value, float min, float scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Protect from underflow
    if(value < min)
        return 0;

    // Scale the number
    value = (value - min)*scaler;

    // Protect from overflow
    if(value > max)
        return max;

    // Account for fractional truncation
    return (unsigned int)(value + 0.5f);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 4
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo4UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 4294967295ul)
        number = 4294967295ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 4
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo4UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 4294967295ul)
        number = 4294967295ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo4SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 2147483647l)
            number = 2147483647l;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-2147483647l - 1))
            number = (-2147483647l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo4SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 2147483647l)
            number = 2147483647l;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-2147483647l - 1))
            number = (-2147483647l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo3UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 16777215ul)
        number = 16777215ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint24ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo3UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 16777215ul)
        number = 16777215ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint24ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo3SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 8388607)
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-8388607l - 1))
            number = (-8388607l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int24ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo3SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 8388607)
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-8388607l - 1))
            number = (-8388607l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int24ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo2UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 65535u)
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo2UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 65535u)
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo2SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 32767)
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-32767 - 1))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo2SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 32767)
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-32767 - 1))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 1
 * unsigned byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo1UnsignedBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 255u)
        number = 255u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint8_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo1SignedBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 127)
            number = 127;
        else
            number = (int8_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-127 - 1))
            number = (-127 - 1);
        else
            number = (int8_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int8ToBytes(number, bytes, index);
}


/*!
 * Scale a uint32_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint32ScaledToBitfield(uint32_t value, int32_t min, uint32_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo4UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo4UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo4SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo4SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo3UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo3UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo3SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo3SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo2UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo2UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo2SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo2SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo1UnsignedBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo1SignedBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a int32_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int32ScaledToBitfield(int32_t value, int32_t min, uint32_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo4UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo4UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo4SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo4SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo3UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo3UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo3SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo3SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo2UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo2UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo2SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo2SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo1UnsignedBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo1SignedBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a uint16_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint16ScaledToBitfield(uint16_t value, int16_t min, uint16_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint16ScaledTo2UnsignedBeBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint16ScaledTo2UnsignedLeBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint16ScaledTo2SignedBeBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint16ScaledTo2SignedLeBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint16ScaledTo1UnsignedBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint16ScaledTo1SignedBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a int16_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int16ScaledToBitfield(int16_t value, int16_t min, uint16_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int16ScaledTo2UnsignedBeBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int16ScaledTo2UnsignedLeBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int16ScaledTo2SignedBeBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int16ScaledTo2SignedLeBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int16ScaledTo1UnsignedBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int16ScaledTo1SignedBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a uint8_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint8ScaledToBitfield(uint8_t value, int8_t min, uint8_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint8_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint8ScaledTo1UnsignedBytes(uint8_t value, uint8_t* bytes, int* index, int8_t min, uint8_t scaler)
{
    // scale the number
    uint8_t number = 0;

    // Make sure number fits in the range
    if(((int8_t)value) > min)
    {
        number = (uint8_t)((value - min)*scaler);
    }

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a uint8_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint8ScaledTo1SignedBytes(uint8_t value, uint8_t* bytes, int* index, uint8_t scaler)
{
    // scale the number
    int8_t number = (int8_t)(value*scaler);

    int8ToBytes(number, bytes, index);
}


/*!
 * Scale a int8_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int8ScaledToBitfield(int8_t value, int8_t min, uint8_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int8_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int8ScaledTo1UnsignedBytes(int8_t value, uint8_t* bytes, int* index, int8_t min, uint8_t scaler)
{
    // scale the number
    uint8_t number = 0;

    // Make sure number fits in the range
    if(((int8_t)value) > min)
    {
        number = (uint8_t)((value - min)*scaler);
    }

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a int8_t on a byte stream by integer scaling to fit in 1 signed byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int8ScaledTo1SignedBytes(int8_t value, uint8_t* bytes, int* index, uint8_t scaler)
{
    // scale the number
    int8_t number = (int8_t)(value*scaler);

    int8ToBytes(number, bytes, index);
}


// end of scaledencode.c
